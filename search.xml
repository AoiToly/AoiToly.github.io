<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用github action对博客进行自动部署</title>
      <link href="/posts/5d1a6067/"/>
      <url>/posts/5d1a6067/</url>
      
        <content type="html"><![CDATA[<p>当我们厌烦了每次更新博客时都要重新部署时，可以尝试使用Github Action来自动部署</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo, github action </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.gitignore文件使用总结</title>
      <link href="/posts/7d157aaa/"/>
      <url>/posts/7d157aaa/</url>
      
        <content type="html"><![CDATA[<p>在使用Git进行项目管理的过程中，一些文件是没有必要被提交到git仓库的，此时，我们就需要用到.gitignore文件来对设置对应文件的忽略规则</p><p>此处短暂参考大佬的资料，日后再找机会去详细读书。</p><p>参考资料：<a href="https://www.cnblogs.com/kevingrace/p/5690241.html">Git忽略提交规则 - .gitignore配置运维总结 - 散尽浮华 - 博客园 (cnblogs.com)</a></p><p><strong>Git忽略文件的原则</strong></p><ul><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如产生的.log日志文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#               表示此为注释,将被Git忽略</span><br><span class="line">*.a             表示忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a          表示但lib.a除外</span><br><span class="line">/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">build/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；</span><br><span class="line">doc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txt</span><br><span class="line"> </span><br><span class="line">bin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件</span><br><span class="line">/bin:           表示忽略根目录下的bin文件</span><br><span class="line">/*.c:           表示忽略cat.c，不忽略 build/cat.c</span><br><span class="line">debug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj</span><br><span class="line">**/foo:         表示忽略/foo,a/foo,a/b/foo等</span><br><span class="line">a/**/b:         表示忽略a/b, a/x/b,a/x/y/b等</span><br><span class="line">!/bin/run.sh    表示不忽略bin目录下的run.sh文件</span><br><span class="line">*.log:          表示忽略所有 .log 文件</span><br><span class="line">config.php:     表示忽略当前路径的 config.php 文件</span><br><span class="line"> </span><br><span class="line">/mtk/           表示过滤整个文件夹</span><br><span class="line">*.zip           表示过滤所有.zip文件</span><br><span class="line">/mtk/do.c       表示过滤某个具体文件</span><br><span class="line"> </span><br><span class="line">被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。</span><br><span class="line"> </span><br><span class="line">需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：</span><br><span class="line">!*.zip</span><br><span class="line">!/mtk/one.txt</span><br><span class="line"> </span><br><span class="line">唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？</span><br><span class="line">想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：</span><br><span class="line">/mtk/*</span><br><span class="line">!/mtk/one.txt</span><br><span class="line"> </span><br><span class="line">假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！</span><br><span class="line">注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！</span><br><span class="line"> </span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">还有一些规则如下：</span><br><span class="line">fd1/*</span><br><span class="line">说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；</span><br><span class="line"> </span><br><span class="line">/fd1/*</span><br><span class="line">说明：忽略根目录下的 /fd1/ 目录的全部内容；</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">!.gitignore</span><br><span class="line">!/fw/ </span><br><span class="line">/fw/*</span><br><span class="line">!/fw/bin/</span><br><span class="line">!/fw/sf/</span><br><span class="line">说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0/"/>
      <url>/posts/0/</url>
      
        <content type="html"><![CDATA[<h2 id="基础数据类型字节大小"><a href="#基础数据类型字节大小" class="headerlink" title="基础数据类型字节大小"></a>基础数据类型字节大小</h2><table><thead><tr><th align="center">类型</th><th align="center">32位</th><th align="center">64位</th></tr></thead><tbody><tr><td align="center">bool</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">char</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">short</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">int</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">long</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">float</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">double</td><td align="center">8</td><td align="center">8</td></tr><tr><td align="center">指针</td><td align="center">4</td><td align="center">8</td></tr></tbody></table><h2 id="内存泄漏-amp-内存溢出"><a href="#内存泄漏-amp-内存溢出" class="headerlink" title="内存泄漏&amp;内存溢出"></a>内存泄漏&amp;内存溢出</h2><p>内存泄漏：申请了一块内存之后却没有被释放，导致系统和程序员都无法访问这块内存</p><p>​隐式内存泄漏：申请内存之后在某个时间段确实会释放这块内存，但间隔时间过长，无法及时释放仍然可能导致内存管理上的问题</p><p>内存溢出：在申请了一片内存区域之后，想在这片区域存储的内容超过了这片区域的大小</p><p>​上溢：栈满时进栈；下溢：栈空时出栈</p><h2 id="左值-amp-右值"><a href="#左值-amp-右值" class="headerlink" title="左值&amp;右值"></a>左值&amp;右值</h2><p>左值：表达式结束后依然存在的持久对象</p><p>右值：表达式结束后就不再存在的临时对象</p><h2 id="常引用返回值"><a href="#常引用返回值" class="headerlink" title="常引用返回值"></a>常引用返回值</h2><p>引用返回值：为了避免赋值时对象的复制过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用返回值会导致以下情况出现</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">foo1</span><span class="params">()</span> </span>&#123; <span class="type">int</span> a = <span class="number">1</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="built_in">foo1</span>() = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 为保证返回值的右值属性，可以使用常引用返回值</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">foo2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="comment">// foo2() = 3; 此处会报错</span></span><br></pre></td></tr></table></figure><p>因此，为了防止对临时变量进行一些无意义的赋值，需要使用常引用返回值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0/"/>
      <url>/posts/0/</url>
      
        <content type="html"><![CDATA[<h1 id="Apex-开镜灵敏度统一"><a href="#Apex-开镜灵敏度统一" class="headerlink" title="Apex 开镜灵敏度统一"></a>Apex 开镜灵敏度统一</h1><p>参考教程：<a href="https://www.bilibili.com/video/BV1cg411K7dt/?spm_id_from=333.337.search-card.all.click&vd_source=b15701b391138cb0fc7af5c3cf24873d">「APEX」超简单的统一开镜灵敏度 让所有倍镜拉枪统一手感_APEX英雄_教程 (bilibili.com)</a></p><h2 id="方法一（较为复杂）："><a href="#方法一（较为复杂）：" class="headerlink" title="方法一（较为复杂）："></a>方法一（较为复杂）：</h2><p>打开文件夹，输入地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%USERPROFILE%\Saved Games\Respawn\Apex\profile\profile.cfg</span><br></pre></td></tr></table></figure><p>找到cl_fovScale参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl_fovScale &quot;1.55&quot;</span><br></pre></td></tr></table></figure><p>打开网址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://jscalc.io/embed/Q1gf45VCY4tmm2dq</span><br></pre></td></tr></table></figure><p>其中，Field of View Input Units可以设置为In-game或Config File(cl_fovScale)，前者为Apex游戏设置中的fov，后者为cl_fovScale，并据此输入对应的fov</p><p>根据计算公式以及网站右侧的数据表，可以得到各倍镜的灵敏度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">倍镜灵敏度 = 倍镜HFOV / 腰射HFOV * 放大系数（Magnification）</span><br></pre></td></tr></table></figure><p>打开文件夹，输入地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%USERPROFILE%\Saved Games\Respawn\Apex\local\settings.cfg</span><br></pre></td></tr></table></figure><p>找到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mouse_zoomed_sensitivity_scalar</span><br></pre></td></tr></table></figure><p>其中0 - 6分别表示1 、2、3、4、6、8、10倍镜，将得到的结果依次输入即可</p><h2 id="方法二（究极暴力版）："><a href="#方法二（究极暴力版）：" class="headerlink" title="方法二（究极暴力版）："></a>方法二（究极暴力版）：</h2><p>打开Aim lab，打开设置-控制</p><p>选择Apex，并调整灵敏度和视野范围使其和游戏内一致，其单位可以选择游戏内，也可以选择配置文件</p><p>将灵敏度选项和视野范围选项改为进阶</p><p>将瞄具射击缩放改成显示器距离，并把下面水平距离（H）的 数值改成100</p><p>将瞄具射击档案改成对应的倍镜，即可看到统一后的倍镜灵敏度是多少</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UnityLearning</title>
      <link href="/posts/1d89cda/"/>
      <url>/posts/1d89cda/</url>
      
        <content type="html"><![CDATA[<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://space.bilibili.com/370283072/channel/collectiondetail?sid=2985">M_Studio – Unity开发教程：3D RPG Course | Core 核心功能</a></p><h1 id="M-Studio-–-Unity开发教程：3D-RPG-Course-Core-核心功能"><a href="#M-Studio-–-Unity开发教程：3D-RPG-Course-Core-核心功能" class="headerlink" title="M_Studio – Unity开发教程：3D RPG Course | Core 核心功能"></a>M_Studio – Unity开发教程：3D RPG Course | Core 核心功能</h1><h2 id="将普通项目升级为URP项目"><a href="#将普通项目升级为URP项目" class="headerlink" title="将普通项目升级为URP项目"></a>将普通项目升级为URP项目</h2><ol><li>在Package Manager中安装Universal RP包</li><li>在Project窗口中，点击加号-&gt;Rendering-&gt;Universal Renderer Pipeline-&gt;Pipeline Asset</li><li>创建Pipeline Settings文件夹，将步骤二中创建的资源放入其中统一管理</li><li>将内部资源转换成URP的资源<br>低版本：Edit-&gt;Render Pipeline-&gt;Universal Render Pipeline-&gt;Upgrade Project Materials to UniversalRP Materials<br>高版本：Windows-&gt;Rendering-&gt;Render Pipeline Converter，选择Built-in to URP，勾选前两个，Initialize Converters，Convert Assets</li></ol><h2 id="调整URP"><a href="#调整URP" class="headerlink" title="调整URP"></a>调整URP</h2><h1 id="一些名词解释"><a href="#一些名词解释" class="headerlink" title="一些名词解释"></a>一些名词解释</h1><h2 id="根骨骼动画-x2F-运动（Root-Motion）"><a href="#根骨骼动画-x2F-运动（Root-Motion）" class="headerlink" title="根骨骼动画&#x2F;运动（Root Motion）"></a>根骨骼动画&#x2F;运动（Root Motion）</h2><p>根骨骼动画：当动画中角色发生位移后，动作坐标原点跟随角色移动。例如一个向前跳跃的动画，如果在场景中重复该动画，能够看到角色一路往前跳跃，位置一直在前进。适用于有位移的放技能动作等。</p><p>非根骨骼动画：当动画中角色发生位移后，动作坐标原点始终保持在原地不变。例如一个向前跳跃的动画，如果在场景中重复该动画，能够看到角色往前跳跃后，完成一次该动画后角色的位置又会重置回去。适用于不能改变角色位置的动画，如闲置动作Idle。</p><p><a href="https://www.bilibili.com/read/cv13605889">参考资料</a></p><h1 id="一些实用技巧"><a href="#一些实用技巧" class="headerlink" title="一些实用技巧"></a>一些实用技巧</h1><h2 id="快捷键V"><a href="#快捷键V" class="headerlink" title="快捷键V"></a>快捷键V</h2><p>顶点吸附，帮助环境布置</p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>QWERTY</p><h2 id="快速调整相机视角"><a href="#快速调整相机视角" class="headerlink" title="快速调整相机视角"></a>快速调整相机视角</h2><p>在Scene场景中调整视角到合适的位置，然后选择对应的Camera，按下CTRL+SHIFT+F，相机会同步到Scene的视角</p><h1 id="一些资源获取途径"><a href="#一些资源获取途径" class="headerlink" title="一些资源获取途径"></a>一些资源获取途径</h1><p><a href="www.mixamo.com">mixamo–角色模型&amp;动画</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Games104</title>
      <link href="/posts/2cd2f5e6/"/>
      <url>/posts/2cd2f5e6/</url>
      
        <content type="html"><![CDATA[<h1 id="Lec1-游戏引擎导论"><a href="#Lec1-游戏引擎导论" class="headerlink" title="Lec1 游戏引擎导论"></a>Lec1 游戏引擎导论</h1><p><strong>What’s game engine?</strong><br>::point_right:Technology foundation of Matrix (黑客帝国)<br>::point_right:Productivity tools of creation<br>::point_right:Art of complexity</p><p><strong>引擎开发的难点：</strong><br>Realtime<br>Toolchain for creators<br>Developer platform<br>Update the engine on the fly</p><h1 id="Lec2-引擎架构分层"><a href="#Lec2-引擎架构分层" class="headerlink" title="Lec2 引擎架构分层"></a>Lec2 引擎架构分层</h1><h2 id="Tool-layer"><a href="#Tool-layer" class="headerlink" title="Tool layer"></a>Tool layer</h2><p>即编辑器，以及将DCC(Digital content creation)导入游戏引擎中的Asset Conditioning Pipeline</p><h2 id="Function-layer"><a href="#Function-layer" class="headerlink" title="Function layer"></a>Function layer</h2><p>tick，优先创建游戏世界，再创建观察者视角（渲染）</p><p><img src="/../images/Games104.assets/image-20230314222602138.png" alt="image-20230314222602138"></p><h2 id="Resource-layer"><a href="#Resource-layer" class="headerlink" title="Resource layer"></a>Resource layer</h2><p>将外部的资源转换成引擎的高效资源Asset，用于管理游戏中所有资产的生命周期（垃圾回收、延时加载技术）</p><h2 id="Core-layer"><a href="#Core-layer" class="headerlink" title="Core layer"></a>Core layer</h2><p>运算效率十分重要（如SMID） ，另外还负责Memory Management，以尽可能减少内存碎片</p><p><img src="/../images/Games104.assets/image-20230314222718731.png" alt="image-20230314222718731"></p><h2 id="Platform-layer"><a href="#Platform-layer" class="headerlink" title="Platform layer"></a>Platform layer</h2><p>用于在不同平台上发布时，开发者能尽可能忽视平台的区别</p><h2 id="3rd-party-libraries"><a href="#3rd-party-libraries" class="headerlink" title="3rd party libraries"></a>3rd party libraries</h2><p>第三方代码库，如一些物理引擎等</p><h2 id="题外话：内存管理的三条要点"><a href="#题外话：内存管理的三条要点" class="headerlink" title="题外话：内存管理的三条要点"></a>题外话：内存管理的三条要点</h2><p>:one:把数据放到一起管理</p><p>:two:访问数据时尽可能顺序访问</p><p>:three:数据处理时尽可能批量处理</p><h1 id="Lec3-如何构建游戏世界"><a href="#Lec3-如何构建游戏世界" class="headerlink" title="Lec3 如何构建游戏世界"></a>Lec3 如何构建游戏世界</h1><p>我们可以将任意一个Game Object分为两部分，即Property和Behaviour</p><p>:one: Everything is a game object in the game world.</p><p>:two: Game object could be described in the component-based way.</p><p>game object之间通过event来传递信息</p><p>为了保证消息传递的时序正确性，我们需要用“邮局”管理投递顺序，保证一致性</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Eigon</title>
      <link href="/posts/15e87e3f/"/>
      <url>/posts/15e87e3f/</url>
      
        <content type="html"><![CDATA[<p>Eigon库</p><p>using语法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> Mat2 = Matrix&lt;T, <span class="number">2</span>, <span class="number">2</span>&gt;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mat2&lt;<span class="type">int</span>&gt; mat1;</span><br><span class="line">mat1 &lt;&lt; <span class="number">1</span>, <span class="number">1</span>, </span><br><span class="line"><span class="number">1</span>, <span class="number">1</span>;</span><br><span class="line">couat &lt;&lt; mat1 &lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用矩阵</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MatrixXd mat1 = MatrixXd::<span class="built_in">Zero</span>(<span class="number">2</span>, <span class="number">2</span>);<span class="comment">// 全0矩阵</span></span><br><span class="line">MatrixXd mat2 = MatrixXd::<span class="built_in">Ones</span>(<span class="number">2</span>, <span class="number">2</span>);<span class="comment">// 全1矩阵</span></span><br><span class="line">MatrixXd mat3 = MatrixXd::<span class="built_in">Identity</span>(<span class="number">2</span>, <span class="number">2</span>);<span class="comment">// 单位矩阵</span></span><br><span class="line">MatrixXd mat4 = MatrixXd::<span class="built_in">Random</span>(<span class="number">2</span>, <span class="number">2</span>);<span class="comment">// 随机矩阵</span></span><br></pre></td></tr></table></figure><p>特殊矩阵</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MatrixXd mat = MatrixXd::<span class="built_in">Random</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; mat.<span class="built_in">transpose</span>() &lt;&lt;end;<span class="comment">// 转置矩阵</span></span><br><span class="line">cout &lt;&lt; mat.<span class="built_in">conjugate</span>() &lt;&lt;end;<span class="comment">// 共轭矩阵</span></span><br><span class="line">cout &lt;&lt; mat.<span class="built_in">inverse</span>() &lt;&lt;end;<span class="comment">// 逆矩阵</span></span><br><span class="line">cout &lt;&lt; mat.<span class="built_in">adjoint</span>() &lt;&lt;end;<span class="comment">// 伴随矩阵</span></span><br></pre></td></tr></table></figure><p>向量块操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ArrayXd <span class="title">vec</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">vec &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>;</span><br><span class="line">cout &lt;&lt; vec &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; vec.<span class="built_in">head</span>(<span class="number">3</span>) &lt;&lt; endl;<span class="comment">// 抽取前3个元素</span></span><br><span class="line">cout &lt;&lt; vec.<span class="built_in">tail</span>(<span class="number">3</span>) &lt;&lt; endl;<span class="comment">// 抽取后3个元素</span></span><br><span class="line">cout &lt;&lt; vec.<span class="built_in">segment</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt;endl;<span class="comment">// 从下标为3的元素开始，抽取4个元素</span></span><br></pre></td></tr></table></figure><p>矩阵块操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXd <span class="title">mat</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line"><span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, </span><br><span class="line"><span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>,</span><br><span class="line"><span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>;</span><br><span class="line">cout &lt;&lt; mat.<span class="built_in">col</span>(<span class="number">3</span>) &lt;&lt; endl;<span class="comment">// 打印第4列</span></span><br><span class="line">cout &lt;&lt; mat.<span class="built_in">row</span>(<span class="number">3</span>) &lt;&lt; endl;<span class="comment">// 打印第4行</span></span><br><span class="line">cout &lt;&lt; mat.<span class="built_in">block</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>) &lt;&lt; endl;<span class="comment">// 从点(1, 1)开始打印一个2 * 2的矩阵</span></span><br><span class="line">cout &lt;&lt; mat.<span class="built_in">block</span>&lt;<span class="number">2</span>, <span class="number">2</span>&gt;(<span class="number">1</span>, <span class="number">1</span>) &lt;&lt; endl;<span class="comment">// 从点(1, 1)开始打印一个2 * 2的矩阵</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编译原理</title>
      <link href="/posts/118b8ca3/"/>
      <url>/posts/118b8ca3/</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-引论"><a href="#第1章-引论" class="headerlink" title="第1章 引论"></a>第1章 引论</h1><h2 id="1-1-什么是编译程序"><a href="#1-1-什么是编译程序" class="headerlink" title="1.1 什么是编译程序"></a>1.1 什么是编译程序</h2><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220310084324406.png" alt="image-20220310084324406"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220310084332979.png" alt="image-20220310084332979"></p><p>预处理程序：将不同文件里的源程序合并+宏展开</p><p>编译程序：生成汇编代码</p><p>汇编程序：生成可再装配（或可重定位）的机器代码</p><p>装配&#x2F;连接编辑程序：生成真正能在机器上运行的代码</p><h2 id="1-2-编译过程和编译程序的结构"><a href="#1-2-编译过程和编译程序的结构" class="headerlink" title="1.2 编译过程和编译程序的结构"></a>1.2 编译过程和编译程序的结构</h2><h3 id="1-2-1-编译过程概述"><a href="#1-2-1-编译过程概述" class="headerlink" title="1.2.1 编译过程概述"></a>1.2.1 编译过程概述</h3><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220310085224130.png" alt="image-20220310085224130"></p><h4 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a>1. 词法分析</h4><p>任务：从左到右一个字符一个字符地读入源程序，对构成源程序的字符流进行扫描和分解，从而识别出一个个单词（一些场合下也称单词符号或符号）。</p><p>例如：</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220310085611006.png" alt="image-20220310085611006"></p><p>词法单元（token）形式：&lt;种别码, 属性值&gt;</p><table><thead><tr><th align="center"></th><th align="center">单词类型</th><th align="center">种别</th><th align="center">种别码</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">关键字</td><td align="center">program、if、else、then、…</td><td align="center">一词一码</td></tr><tr><td align="center">2</td><td align="center">标识符</td><td align="center">变量名、数组名、记录名、过程名、…</td><td align="center">多词一码</td></tr><tr><td align="center">3</td><td align="center">常量</td><td align="center">整型、浮点型、记录名、过程名、…</td><td align="center">一型一码</td></tr><tr><td align="center">4</td><td align="center">运算符</td><td align="center">算术（+ - &amp; &#x2F; ++ –）<br>关系（&gt; &lt; &#x3D;&#x3D; !&#x3D; &gt;&#x3D; &lt;&#x3D;）<br>逻辑（&amp; | ~）</td><td align="center">一词一码<br>或<br>一型一码</td></tr><tr><td align="center">5</td><td align="center">界限符</td><td align="center">; ( ) &#x3D; { } …</td><td align="center">一词一码</td></tr></tbody></table><h4 id="2-语法分析"><a href="#2-语法分析" class="headerlink" title="2. 语法分析"></a>2. 语法分析</h4><p>任务：在词法分析的基础上将单词序列分解成各类语法短语，如“程序”、“语句”、“表达式”等，这种语法短语也称为语法单位，可表示成语法树。</p><p>语法分析依据语言的语法规则，即描述程序结构的规则，通过语法分析确定整个输入串是否构成一个语法上正确的程序</p><p>程序的结构通常是由递归规则来表示的。</p><p>例如：</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220310090248450.png" alt="image-20220310090248450"></p><h4 id="3-语义分析"><a href="#3-语义分析" class="headerlink" title="3. 语义分析"></a>3. 语义分析</h4><p>任务：审查源程序有无语义错误，为代码生成阶段收集类型信息，并对可强制转换的对象进行处理。</p><h4 id="4-中间代码生成"><a href="#4-中间代码生成" class="headerlink" title="4. 中间代码生成"></a>4. 中间代码生成</h4><p>在经过上述阶段之后，有的编译程序会将源程序变成一种内部表示形式，即中间语言或中间代码。</p><p>所谓中间代码是一种结构简单、含义明确的记号系统，重要设计原则有两点：一是容易生成，二是容易将它翻译成目标代码。</p><p>很多编译程序采用了一种近似三地址格式的四元式中间代码：（运算符，运算对象1，运算对象2，结果）</p><p>例如，源程序sum :&#x3D; first + count * 10 可生成下图所示的四元式序列，其中$t_i$(i &#x3D; 1, 2, 3)是编译程序生成的临时名字，用于存放运算的中间结果</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220310091942655.png" alt="image-20220310091942655"></p><h4 id="5-代码优化"><a href="#5-代码优化" class="headerlink" title="5. 代码优化"></a>5. 代码优化</h4><p>任务：对前一阶段产生的中间代码进行变换或进行改造，目的是使生成的代码更为高效，即省时间和省空间。</p><p>将在第10章详细介绍</p><h4 id="6-目标代码生成"><a href="#6-目标代码生成" class="headerlink" title="6. 目标代码生成"></a>6. 目标代码生成</h4><p>这一阶段的任务是把中间代码变换成特定机器上的绝对指令代码或可重定位的指令代码或汇编指令代码</p><h3 id="1-2-2-编译程序的结构"><a href="#1-2-2-编译程序的结构" class="headerlink" title="1.2.2 编译程序的结构"></a>1.2.2 编译程序的结构</h3><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220310101626031.png" alt="image-20220310101626031"></p><p>表格管理：编译过程中源程序的各种信息被保留在种种不同的表格里，编译各阶段的工作都涉及构造、查找或更新有关的表格。</p><p>出错处理：如果编译过程中发现源程序有错误，编译程序应报告错误的性质和错误发生的地点并将错误所造成的影响控制在尽可能小的范围内，使得源程序的其余部分能继续被编译下去，有些编译程序还能自动校正错误。</p><h3 id="1-2-3-编译阶段的组合"><a href="#1-2-3-编译阶段的组合" class="headerlink" title="1.2.3 编译阶段的组合"></a>1.2.3 编译阶段的组合</h3><p>有时把编译的过程分为前端和后端</p><p>前端的工作主要依赖于源语言而于目标机无关，通常包括词法分析、语法分析、语义分析和中间代码生成，某些优化工作也可在前端做，还包括与前端每个阶段相关的出错处理工作和符号表管理工作。</p><p>后端指的是哪些依赖于目标机而一般不依赖于源语言，只与中间代码有关的那些阶段的工作，即目标代码生成，以及相关出错处理和符号表操作。</p><h2 id="1-3-解释程序和一些软件工具"><a href="#1-3-解释程序和一些软件工具" class="headerlink" title="1.3 解释程序和一些软件工具"></a>1.3 解释程序和一些软件工具</h2><h3 id="1-3-1-解释程序"><a href="#1-3-1-解释程序" class="headerlink" title="1.3.1 解释程序"></a>1.3.1 解释程序</h3><p>解释程序和编译程序的区别就是，编译程序是把整个源代码翻译完之后再运行，而解释程序是边翻译边运行。</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220310123142068.png" alt="image-20220310123142068"></p><h3 id="1-3-2-处理源程序的软件工具"><a href="#1-3-2-处理源程序的软件工具" class="headerlink" title="1.3.2 处理源程序的软件工具"></a>1.3.2 处理源程序的软件工具</h3><h4 id="1-语言的结构化编辑器"><a href="#1-语言的结构化编辑器" class="headerlink" title="1. 语言的结构化编辑器"></a>1. 语言的结构化编辑器</h4><p>用户可使用这种编辑器在语言的语法制导下编制出所需的源程序</p><p>具有通常的正文编辑器的正文编辑和修改功能，并能够执行一些对正确编制程序有帮助的附加的任务，如检查用户的输入是否正确、联想、begin或左括号和end或右括号匹配等功能</p><h4 id="2-语言程序的调试工具"><a href="#2-语言程序的调试工具" class="headerlink" title="2. 语言程序的调试工具"></a>2. 语言程序的调试工具</h4><h4 id="3-程序格式化工具"><a href="#3-程序格式化工具" class="headerlink" title="3. 程序格式化工具"></a>3. 程序格式化工具</h4><h4 id="4-语言程序测试工具"><a href="#4-语言程序测试工具" class="headerlink" title="4. 语言程序测试工具"></a>4. 语言程序测试工具</h4><p>静态分析器和动态测试器</p><h4 id="5-程序理解工具"><a href="#5-程序理解工具" class="headerlink" title="5. 程序理解工具"></a>5. 程序理解工具</h4><h4 id="6-高级语言之间的转换工具"><a href="#6-高级语言之间的转换工具" class="headerlink" title="6. 高级语言之间的转换工具"></a>6. 高级语言之间的转换工具</h4><h2 id="1-4-PL-x2F-0语言编译系统"><a href="#1-4-PL-x2F-0语言编译系统" class="headerlink" title="1.4 PL&#x2F;0语言编译系统"></a>1.4 PL&#x2F;0语言编译系统</h2><h3 id="1-4-1-PL-x2F-0语言编译系统构成"><a href="#1-4-1-PL-x2F-0语言编译系统构成" class="headerlink" title="1.4.1 PL&#x2F;0语言编译系统构成"></a>1.4.1 PL&#x2F;0语言编译系统构成</h3><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220310135306946.png" alt="image-20220310135306946"></p><p>为了描述方便，通常用T形图来表示一个编译程序涉及的三个方面的语言，即源语言、目标语言和编译程序的书写语言（实现语言）。T形图的左上角表示源语言，右上角表示目标语言，底部表示书写语言</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220310135925681.png" alt="image-20220310135925681"></p><h3 id="1-4-2-PL-x2F-0语言"><a href="#1-4-2-PL-x2F-0语言" class="headerlink" title="1.4.2 PL&#x2F;0语言"></a>1.4.2 PL&#x2F;0语言</h3><p>PL&#x2F;0语言是Pascal的一个子集</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220310140021880.png" alt="image-20220310140021880"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220310140031905.png" alt="image-20220310140031905"></p><p>在实践中，程序语言的语法描述常采用一种称为扩展巴克斯范式（EBNF）的形式来描述。</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220310140400669.png" alt="image-20220310140400669"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220310140430950.png" alt="image-20220310140430950"></p><h3 id="1-4-3-类P-code语言"><a href="#1-4-3-类P-code语言" class="headerlink" title="1.4.3 类P-code语言"></a>1.4.3 类P-code语言</h3><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220310140550747.png" alt="image-20220310140550747"></p><h3 id="1-4-4-PL-x2F-0编译程序"><a href="#1-4-4-PL-x2F-0编译程序" class="headerlink" title="1.4.4 PL&#x2F;0编译程序"></a>1.4.4 PL&#x2F;0编译程序</h3><h3 id="1-4-5-PL-x2F-0语言编译系统的驱动代码"><a href="#1-4-5-PL-x2F-0语言编译系统的驱动代码" class="headerlink" title="1.4.5 PL&#x2F;0语言编译系统的驱动代码"></a>1.4.5 PL&#x2F;0语言编译系统的驱动代码</h3><h1 id="第2章-文法和语言"><a href="#第2章-文法和语言" class="headerlink" title="第2章 文法和语言"></a>第2章 文法和语言</h1><h2 id="2-1-文法的直观概念"><a href="#2-1-文法的直观概念" class="headerlink" title="2.1 文法的直观概念"></a>2.1 文法的直观概念</h2><p>类似于语法，主谓宾</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220311153647455.png" alt="image-20220311153647455"></p><h2 id="2-2-符号和符号串"><a href="#2-2-符号和符号串" class="headerlink" title="2.2 符号和符号串"></a>2.2 符号和符号串</h2><h3 id="1-字母表"><a href="#1-字母表" class="headerlink" title="1. 字母表"></a>1. 字母表</h3><p>元素的非空有穷集合，字母表中的元素称为符号，因此字母表又称符号集</p><p>例如，汉语的字母表中包含汉字、数字及标点符号等；C语言的字母表由字母、数字、若干专用符号及char、structural、if、do之类的保留字组成</p><h3 id="2-符号串"><a href="#2-符号串" class="headerlink" title="2. 符号串"></a>2. 符号串</h3><p>由字母表中的符号组成的任何有穷序列称为符号串</p><ol><li><p>符号串的头尾，固有头和固有尾</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220311154136219.png" alt="image-20220311154136219"></p></li><li><p>符号串的连接</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220311154147529.png" alt="image-20220311154147529"></p></li><li><p>符号串的方幂</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220311154159514.png" alt="image-20220311154159514"></p></li><li><p>符号串集合</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220311154230566.png" alt="image-20220311154230566"></p></li></ol><h2 id="2-3-文法和语言的形式定义"><a href="#2-3-文法和语言的形式定义" class="headerlink" title="2.3 文法和语言的形式定义"></a>2.3 文法和语言的形式定义</h2><p>规则，也称重写规则、产生式或生成式</p><p>定义2.1 文法G定义为四元组$(V_N,V_T,P,S)$。</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220311160428296.png" alt="image-20220311160428296"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220311160657964.png" alt="image-20220311160657964"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220311160719531.png" alt="image-20220311160719531"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220311162813603.png" alt="image-20220311162813603"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220311162822034.png" alt="image-20220311162822034"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220311163041467.png" alt="image-20220311163041467"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220315102631728.png" alt="image-20220315102631728"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220315102903979.png" alt="image-20220315102903979"></p><h2 id="2-4-文法的类型"><a href="#2-4-文法的类型" class="headerlink" title="2.4 文法的类型"></a>2.4 文法的类型</h2><h3 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h3><p>无限制文法&#x2F;短语结构文法</p><p>$\alpha\rightarrow\beta$，$\forall\alpha\rightarrow\beta\in P$，$\alpha$中至少包含1个非终结符</p><p>0型语言：由0型文法G生成的语言</p><h3 id="1型文法"><a href="#1型文法" class="headerlink" title="1型文法"></a>1型文法</h3><p>上下文有关文法(Context-Sensitive Grammer, CSG)</p><p>$\alpha\rightarrow\beta$，$\forall\alpha\rightarrow\beta\in P$，$\alpha$中至少包含1个非终结符，且$|\alpha|\leq|\beta|$</p><p>产生式的一般形式：$\alpha_1A\alpha_2\rightarrow\alpha_1\beta\alpha_2(\beta\neq\varepsilon)$</p><p>CSG中不包含$\varepsilon$-产生式</p><p>上下文有关语言（1型语言）：由上下文有关文法（1型文法）G生成的语言L(G)</p><h3 id="2型文法"><a href="#2型文法" class="headerlink" title="2型文法"></a>2型文法</h3><p>上下文无关文法(Context-Free Grammar, CFG)</p><p>$\alpha\rightarrow\beta$，$\forall\alpha\rightarrow\beta\in P$, $\alpha\in V_N$</p><p>产生式的一般形式：$A\rightarrow\beta$</p><p>即每一个产生式的左部，必须是一个非终结符（A）</p><p>上下文无关语言（2型语言）：由上下文无关文法（2型文法）G生成的语言L(G)</p><h3 id="3型文法"><a href="#3型文法" class="headerlink" title="3型文法"></a>3型文法</h3><p>正则文法(Regular Grammar, RG)</p><p>右线性文法：$A\rightarrow wB$或$A\rightarrow w$（在右部为终结符w或在w的右边增加非终结符B来限制w）</p><p>左线性文法：$A\rightarrow Bw$或$A\rightarrow w$</p><p>左线性文法和右线性文法都成为正则文法</p><p>正则文法的右部最多只有一个非终结符，并且位置在同一侧</p><p>正则语言（3型语言）：由正则文法（3型文法）G生成的语言L(G)</p><p>正则文法能描述程序设计语言的多数单词</p><h4 id="四种文法之间的关系"><a href="#四种文法之间的关系" class="headerlink" title="四种文法之间的关系"></a>四种文法之间的关系</h4><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220315110237102.png" alt="image-20220315110237102"></p><h2 id="2-5-上下文无关文法及其语法树"><a href="#2-5-上下文无关文法及其语法树" class="headerlink" title="2.5 上下文无关文法及其语法树"></a>2.5 上下文无关文法及其语法树</h2><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220315110858129.png" alt="image-20220315110858129"></p><p>分析树是推导的图形化表示</p><h3 id="最左（最右）推导"><a href="#最左（最右）推导" class="headerlink" title="最左（最右）推导"></a>最左（最右）推导</h3><p>优先对最左（最右）非终结符进行替换</p><p>最右推导常被称为规范推导</p><h3 id="（句型的）短语"><a href="#（句型的）短语" class="headerlink" title="（句型的）短语"></a>（句型的）短语</h3><p>给定一个句型，其分析树中的每一颗子树的边缘称为该句型的一个短语</p><p>如果子树只有父子两代结点，那么这颗子树的边缘称为该句型的一个直接短语</p><p>直接短语一定是某产生式的右部，产生式的右部不一定是给定句型的直接短语</p><h3 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h3><p>二义性文法：如果一个文法可以为某个句子生成多颗分析树，则称这个文法是二义性的</p><p>二义性文法的判定：对于任意一个上下文无关文法，不存在一个算法，判定它是无二义性的，但能给出一组充分条件，满足这组充分条件的文法是无二义性的</p><h2 id="2-6-句型的分析"><a href="#2-6-句型的分析" class="headerlink" title="2.6 句型的分析"></a>2.6 句型的分析</h2><p>语法树又称为语法分析树或分析树</p><p>完成句型分析的程序称为分析程序或识别程序</p><p>分析算法又称识别算法</p><h3 id="2-6-1-自上而下的分析方法"><a href="#2-6-1-自上而下的分析方法" class="headerlink" title="2.6.1 自上而下的分析方法"></a>2.6.1 自上而下的分析方法</h3><h3 id="2-6-2-自下而上的分析方法"><a href="#2-6-2-自下而上的分析方法" class="headerlink" title="2.6.2 自下而上的分析方法"></a>2.6.2 自下而上的分析方法</h3><h3 id="2-6-3-句型分析的有关问题"><a href="#2-6-3-句型分析的有关问题" class="headerlink" title="2.6.3 句型分析的有关问题"></a>2.6.3 句型分析的有关问题</h3><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220322081156497.png" alt="image-20220322081156497"></p><h3 id="2-7-1-有关文法的实用限制"><a href="#2-7-1-有关文法的实用限制" class="headerlink" title="2.7.1 有关文法的实用限制"></a>2.7.1 有关文法的实用限制</h3><p>有害规则</p><p>  形如$U\rightarrow U$的产生式</p><p>多余规则</p><p>  文法中连一个句子的推导都用不到的规则。</p><ol><li>不可到达的非终结符</li></ol><p>  不在任何规则的右部出现的非终结符</p><ol start="2"><li>不可终止的非终结符</li></ol><p>  不能从它推出终结符号串的非终结符</p><p>对于文法G[S]，为了保证任一非终结符A在句子推导中出现，必须满足如下两个条件：</p><ol><li><p>A必须在某句型中出现, 即有$\Rightarrow SαAβ$，其中α，β∈V*</p></li><li><p>必须能够从A推出终结符号串t来, 即: $A&#x3D;^+t$，其中$t∈V_T^*$</p></li></ol><h3 id="2-7-2-上下文无关文法中的ε规则"><a href="#2-7-2-上下文无关文法中的ε规则" class="headerlink" title="2.7.2 上下文无关文法中的ε规则"></a>2.7.2 上下文无关文法中的ε规则</h3><h1 id="第3章-词法分析"><a href="#第3章-词法分析" class="headerlink" title="第3章 词法分析"></a>第3章 词法分析</h1><h2 id="3-1-正则表达式"><a href="#3-1-正则表达式" class="headerlink" title="3.1 正则表达式"></a>3.1 正则表达式</h2><p>正则表达式是一种用来描述正则语言的更紧凑的表示方法</p><p>正则表达式可以由较小的正则表达式按照特定规则递归地构建，每个正则表达式r定义一个语言，记为L(r)，这隔语言也是根据r的子表达式所表示的语言递归定义的</p><h3 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h3><p>ε是一个RE， L(ε) &#x3D; {ε}</p><p>如果 a∈ ∑，则a是一个RE， L(a) &#x3D; {a}  </p><p>假设 r和 s都是 RE，表示的语言分别是 L(r)和L(s)，则<br>    r|s 是一个RE， L( r|s ) &#x3D; L(r)∪ L(s)<br>    rs 是一个RE， L( rs ) &#x3D; L(r) L(s)<br>    r* 是一个RE， L( r* )&#x3D; (L(r))*<br>    (r) 是一个RE， L( (r) ) &#x3D; L(r)  </p><p>运算的优先级： *、 连接、 |  </p><p>例： C语言无符号整数的RE  </p><p>十进制整数的RE<br>    (1|…|9)(0|…|9)*|0</p><p>八进制整数的RE<br>    0(0|1|2|3|4|5|6|7)(0|1|2|3|4|5|6|7)*</p><p>十六进制整数的RE<br>    0x(0|1|…|9|a|…| f |A|…|F)(0|…|9|a|…| f |A|…|F )*</p><table><thead><tr><th align="center">定律</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">r｜ s &#x3D; s｜ r</td><td align="center">｜是可以交换的</td></tr><tr><td align="center">r｜（ s｜ t ） &#x3D;（ r｜ s）｜ t</td><td align="center">｜是可结合的</td></tr><tr><td align="center">r（ s t ） &#x3D;（ r s） t</td><td align="center">连接是可结合的</td></tr><tr><td align="center">r（ s｜ t ） &#x3D; r s｜ r t ; （ s｜ t） r &#x3D; s r｜ t r</td><td align="center">连接对｜ 是可分配的</td></tr><tr><td align="center">εr &#x3D; rε &#x3D; r</td><td align="center">ε 是连接的单位元</td></tr><tr><td align="center">r * &#x3D;（ r｜ ε ） *</td><td align="center">闭包中一定包含 ε</td></tr><tr><td align="center">r **&#x3D; r *</td><td align="center">* 具有幂等性</td></tr></tbody></table><p>正则文法与正则表达式等价：</p><ol><li>对任何正则文法 G，存在定义同一语言的正则表达式 r</li><li>对任何正则表达式 r，存在生成同一语言的正则文法 G</li></ol><h2 id="3-2-正则定义"><a href="#3-2-正则定义" class="headerlink" title="3.2 正则定义"></a>3.2 正则定义</h2><p>正则定义是具有如下形式的定义序列：<br>$d_1→r_1, d_2→r_2,…,d_n→r_n$<br>其中：<br>每个di都是一个新符号，它们都不在字母表 Σ中，而且各不相同<br>每个$r_i$是字母表 $Σ∪ {d_1 ,d_2 , … ,d_{i-1}}$上的正则表达式  </p><p>正则定义就是给一些RE命名，并在之后的RE中像使用字母表中的符号一样使用这些名字</p><p>例：（整型或浮点型）无符号数的正则定义</p><p>​digit → 0|1|2|…|9</p><p>​digits → digit digit*</p><p>​optionalFraction → .digits|ε</p><p>​optionalExponent → ( E(+|-|ε)digits )|ε</p><p>​number → digits optionalFraction optionalExponent</p><h2 id="3-3-有穷自动机（FA）"><a href="#3-3-有穷自动机（FA）" class="headerlink" title="3.3 有穷自动机（FA）"></a>3.3 有穷自动机（FA）</h2><p>有穷自动机是对一类处理系统建立的数学模型</p><p>这类系统具有一系列的输入输出信息和有穷数目的内部状态（状态：概括了对过去输入信息处理的状况）</p><p>系统只需要根据当前所处的状态和当前面临的输入信息就可以决定系统的后继行为。每当系统处理了当前的输入后，系统的内部状态也将发生改变</p><h3 id="3-3-1-FA模型"><a href="#3-3-1-FA模型" class="headerlink" title="3.3.1 FA模型"></a>3.3.1 FA模型</h3><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325152718438.png" alt="image-20220325152718438"></p><p>输入带：用来存放输入符号串</p><p>读头：从左向右逐个读取输入符号，不能修改（只读）、不能往返移动</p><p>有穷控制器：具有有穷个状态数，根据当前状态和当前输入符号转入下一状态</p><h3 id="3-3-2-FA的表示"><a href="#3-3-2-FA的表示" class="headerlink" title="3.3.2 FA的表示"></a>3.3.2 FA的表示</h3><h4 id="转换图"><a href="#转换图" class="headerlink" title="转换图"></a>转换图</h4><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325152954127.png" alt="image-20220325152954127"></p><p>结点：FA的状态</p><p>​初始状态（开始状态）：只有一个，由start箭头指向</p><p>​终止状态（接收状态）：可以有多个，用双圈表示</p><p>带标记的有向边：如果对于输入a，存在一个从状态p到状态q的转换，就在p、q之间画一条有向边，并标记上a</p><p>给定输入串x， 如果存在一个对应于串x的从初始状态到某个终止状态的转换序列，则称串x被该FA接收<br>由一个有穷自动机M接收的所有串构成的集合称为是该FA定义（或接收）的语言，记为L(M )  </p><h4 id="转换表"><a href="#转换表" class="headerlink" title="转换表"></a>转换表</h4><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325154945909.png" alt="image-20220325154945909"></p><p><strong>最长子串匹配原则</strong>  </p><p>当输入串的多个前缀与一个或多个模式匹配时，总是选择最长的前缀进行匹配</p><p>在到达某个终态之后，只要输入带上还有符号，DFA就继续前进，以便寻找尽可能长的匹配  </p><h2 id="3-4-有穷自动机的分类"><a href="#3-4-有穷自动机的分类" class="headerlink" title="3.4 有穷自动机的分类"></a>3.4 有穷自动机的分类</h2><h3 id="3-4-1-确定的有穷自动机（DFA）"><a href="#3-4-1-确定的有穷自动机（DFA）" class="headerlink" title="3.4.1 确定的有穷自动机（DFA）"></a>3.4.1 确定的有穷自动机（DFA）</h3><p>$M &#x3D; ( S， Σ ， δ， s_0， F )  $</p><p>S： 有穷状态集<br>Σ： 输入字母表，即输入符号集合。 假设ε不是 Σ中的元素<br>δ： 将S× Σ映射到S的转换函数。$\forall s∈ S, a∈ Σ, δ(s,a)$表示从状态s出发，沿着标记为a的边所能到达的状态。<br>$s_0$： 开始状态 (或初始状态)， $s_0∈ S$<br>F： 接收状态（或终止状态） 集合， F⊆ S  </p><h3 id="3-4-2-非确定的有穷自动机（NFA）"><a href="#3-4-2-非确定的有穷自动机（NFA）" class="headerlink" title="3.4.2 非确定的有穷自动机（NFA）"></a>3.4.2 非确定的有穷自动机（NFA）</h3><p>S：有穷状态集<br>Σ： 输入符号集合，即输入字母表。假设ε 不是Σ中的元素<br>δ： 将S× Σ映射到$2^S$的转换函数。 $\forall s∈ S, a∈ Σ, δ(s,a)$表示从状态s出发，沿着标记为a的边所能到达的状态集合<br>$s_0$：开始状态 (或初始状态)， $s_0∈ S$<br>F：接收状态（或终止状态）集合， F⊆ S  </p><p>例：一个NFA  </p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325155540223.png" alt="image-20220325155540223"></p><h3 id="3-4-3DFA和NFA的等价性"><a href="#3-4-3DFA和NFA的等价性" class="headerlink" title="3.4.3DFA和NFA的等价性"></a>3.4.3DFA和NFA的等价性</h3><p>对任何非确定的有穷自动机N ，存在定义同一语言的确定的有穷自动机D</p><p>对任何确定的有穷自动机D ，存在定义同一语言的非确定的有穷自动机N  </p><p>例：</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325155955149.png" alt="image-20220325155955149"></p><h3 id="3-4-4带有“ε-边”的NFA"><a href="#3-4-4带有“ε-边”的NFA" class="headerlink" title="3.4.4带有“ε-边”的NFA"></a>3.4.4带有“ε-边”的NFA</h3><p>M &#x3D; ( S， Σ ， δ， s0， F )<br>S：有穷状态集<br>Σ： 输入符号集合，即输入字母表。假设ε不是Σ中的元素<br>δ： 将S× (Σ∪ {ε})映射到2S的转换函数。 $\forall s∈ S, a∈ Σ∪ {ε}, δ(s,a)$表示从状态s出发，沿着标记为a的边所能到达的状态集合<br>$s_0$：开始状态 (或初始状态)， $s_0$∈ S<br>F：接收状态（或终止状态）集合， F⊆ S  </p><p>即状态A即使什么都不输入也能转化为状态B</p><p>**带有和不带有“ε-边”的NFA 的等价性  **</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325160613310.png" alt="image-20220325160613310"></p><h3 id="3-4-5-DFA的算法实现"><a href="#3-4-5-DFA的算法实现" class="headerlink" title="3.4.5 DFA的算法实现"></a>3.4.5 DFA的算法实现</h3><p>输入：以文件结束符eof结尾的字符串x。 DFA D 的开始状态$s_0$，接收状态集 F，转换函数move。<br>输出：如果 D接收 x，则回答“yes”，否则回答“no”。<br>方法：将下述算法应用于输入串 x。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = s0 ;</span><br><span class="line">c = nextChar（） ;</span><br><span class="line">while（c! = eof ）｛</span><br><span class="line">s = move ( s , c ) ;</span><br><span class="line">c = nextChar ( ) ;</span><br><span class="line">｝</span><br><span class="line">if (s在F中) return“yes” ;</span><br><span class="line">else return “no” ;</span><br></pre></td></tr></table></figure><p>函数nextChar( )返回输入串x的下一个符号<br>函数move(s, c)表示从状态s出发，沿着标记为c的边所能到达的状态  </p><h2 id="3-5-从正则表达式到有穷自动机"><a href="#3-5-从正则表达式到有穷自动机" class="headerlink" title="3.5 从正则表达式到有穷自动机"></a>3.5 从正则表达式到有穷自动机</h2><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325161345610.png" alt="image-20220325161345610"></p><h3 id="3-5-1-根据RE构造NFA"><a href="#3-5-1-根据RE构造NFA" class="headerlink" title="3.5.1 根据RE构造NFA"></a>3.5.1 根据RE构造NFA</h3><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325161419953.png" alt="image-20220325161419953"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325161547809.png" alt="image-20220325161547809"></p><p>*<em>例:r&#x3D;(a|b)<em>abb 对应的NFA</em></em></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325161617663.png" alt="image-20220325161617663"></p><h2 id="3-6-从NFA到DFA的转换"><a href="#3-6-从NFA到DFA的转换" class="headerlink" title="3.6 从NFA到DFA的转换"></a>3.6 从NFA到DFA的转换</h2><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325161909698.png" alt="image-20220325161909698"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325162423183.png" alt="image-20220325162423183"></p><h3 id="子集构造法"><a href="#子集构造法" class="headerlink" title="子集构造法"></a>子集构造法</h3><p>输入： NFA N<br>输出：接收同样语言的DFA D<br>方法： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">一开始， ε-closure（ s0 ）是Dstates 中的唯一状态，且它未加标记；</span><br><span class="line">while（在Dstates中有一个未标记状态T ）｛</span><br><span class="line">给T加上标记；</span><br><span class="line">for（每个输入符号a）｛</span><br><span class="line">U = ε-closure(move(T, a));</span><br><span class="line">if ( U不在Dstates中)</span><br><span class="line">将U加入到Dstates中，且不加标记；</span><br><span class="line">Dtran[T, a]=U ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>ε-closure ( s )</td><td>能够从NFA的状态s开始只通过ε转换到达的NFA状态集合</td></tr><tr><td>ε-closure ( T )</td><td>能够从T 中的某个NFA状态 s开始只通过ε转换到达的NFA状态集合,即$U_{s∈ T} ε-closure ( s )$</td></tr><tr><td>move( T , a)</td><td>能够从T 中的某个状态 s出发通过标号为a的转换到达的NFA状态的集合</td></tr></tbody></table><p>计算ε-closure (T ) </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">将T的所有状态压入stack中；</span><br><span class="line">将ε-closure（T ）初始化为 T ；</span><br><span class="line">while（stack非空）｛</span><br><span class="line">将栈顶元素 t 给弹出栈中；</span><br><span class="line">for（每个满足如下条件的u ：从t出发有一个标号为ε的转换到达状态u)</span><br><span class="line">if ( u不在ε-closure（T ）中）｛</span><br><span class="line">将u加入到ε-closure（T ）中；</span><br><span class="line">将u压入栈中;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-识别单词的DFA"><a href="#3-7-识别单词的DFA" class="headerlink" title="3.7 识别单词的DFA"></a>3.7 识别单词的DFA</h2><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325180711567.png" alt="image-20220325180711567"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325180723363.png" alt="image-20220325180723363"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325180737093.png" alt="image-20220325180737093"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325180751629.png" alt="image-20220325180751629"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325180759232.png" alt="image-20220325180759232"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220325180806993.png" alt="image-20220325180806993"></p><h3 id="词法分析阶段的错误处理"><a href="#词法分析阶段的错误处理" class="headerlink" title="词法分析阶段的错误处理"></a>词法分析阶段的错误处理</h3><p>词法分析阶段可检测错误的类型<br>    单词拼写错误<br>        例： int i &#x3D; 0x3G; float j &#x3D;1.05e;<br>    非法字符<br>        例： ~ @</p><p>词法错误检测<br>    如果当前状态与当前输入符号在转换表对应项中的信息为空， 而当前状态又不是终止状态，则调用错误处理程序</p><p>错误处理<br>    查找已扫描字符串中最后一个对应于某终态的字符<br>        如果找到了，将该字符与其前面的字符识别成一个单词。<br>            然后将输入指针退回到该字符，扫描器重新回到初始状态，继续识别下一个单词<br>    如果没找到，则确定出错，采用错误恢复策略  </p><p>错误恢复策略<br>    最简单的错误恢复策略：“恐慌模式 (panic mode)”恢复<br>        从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的字符为止</p><h1 id="第4章-语法分析"><a href="#第4章-语法分析" class="headerlink" title="第4章 语法分析"></a>第4章 语法分析</h1><h2 id="4-1-自顶向下分析概述"><a href="#4-1-自顶向下分析概述" class="headerlink" title="4.1 自顶向下分析概述"></a>4.1 自顶向下分析概述</h2><p><strong>自顶向下的分析</strong></p><p>从分析树的顶部（根节点）向底部（叶节点）方向构造分析树，可以看成是从文法开始符号S推导出词串w的过程</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220408150623454.png" alt="image-20220408150623454"></p><p>每一步推导中，都需要做两个选择：</p><ol><li>替换当前句型中的哪个非终结符</li><li>用该非终结符的哪个候选式进行替换</li></ol><p><strong>最左推导</strong>：在最左推导中，总是选择每个句型的最左非终结符进行替换</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220408150903005.png" alt="image-20220408150903005"></p><p>如果$S\Rightarrow_{lm}\alpha$，则称α是当前文法的最左句型（由最左推导得到的句型）</p><p><strong>最右推导</strong>：在最右推导中，总是选择每个句型的最右非终结符进行替换</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220408151918342.png" alt="image-20220408151918342"></p><p><strong>在自底向上的分析中，总是采用最左归约的方式</strong>，因此把最左归约称为规范归约，而最右推导相应地称为规范推导</p><p>最左推导和最右推导的唯一性，最左推导和最右推导的分析树是唯一的</p><p><strong>自顶向下的语法分析采用最左推导方式</strong></p><p>总是选择每个句型的最左非终结符进行替换</p><p>根据输入流中的下一个终结符，选择最左非终结符的一个候选  </p><p><strong>自顶向下语法分析的通用形式</strong></p><p>递归下降分析 (Recursive-Descent Parsing)<br>    由一组过程组成，每个过程对应一个非终结符<br>    从文法开始符号S对应的过程开始，其中递归调用文法中其它非终结符对应的过程。如果S对应的过程体恰好扫描了整个输入串，则成功完成语法分析</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220408152747334.png" alt="image-20220408152747334"></p><p><strong>预测分析</strong></p><p>预测分析是递归下降分析技术的一个特例，通过在输入中向前看固定个数（通常是一个） 符号来选择正确的A-产生式。</p><p>​可以对某些文法构造出向前看k个输入符号的预测分析器，该类文法有时也称为LL(k) 文法类</p><p>预测分析不需要回溯，是一种确定的自顶向下分析方法  </p><h2 id="4-2-文法转换"><a href="#4-2-文法转换" class="headerlink" title="4.2 文法转换"></a>4.2 文法转换</h2><p>含有A→Aα形式产生式的文法称为是直接左递归的</p><p>如果一个文法中有一个非终结符A使得对某个串α存在一个推导$A\Rightarrow^+Aα$ ，那么这个文法就是左递归  </p><p>经过两步或两步以上推导产生的左递归称为是间接左递的</p><p>左递归文法会使递归下降分析器陷入无限循环</p><p><strong>消除直接左递归</strong>：</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220408154917016.png" alt="image-20220408154917016"></p><p>消除直接左递归的一般形式：</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220408155011065.png" alt="image-20220408155011065"></p><p>消除左递归是要付出代价的——引进了一些非终结符和ε_产生式</p><p><strong>消除间接左递归</strong>：</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220408155239456.png" alt="image-20220408155239456"></p><p><strong>消除左递归算法</strong>：</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220408155324184.png" alt="image-20220408155324184"></p><p><strong>提取左公因子</strong>：</p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220408155700376.png" alt="image-20220408155700376"></p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220408155709293.png" alt="image-20220408155709293"></p><h2 id="4-3-LL-1-文法"><a href="#4-3-LL-1-文法" class="headerlink" title="4.3 LL(1)文法"></a>4.3 LL(1)文法</h2><p><strong>S_文法</strong>：</p><p>预测分析法的工作过程<br>    从文法开始符号出发，在每一步推导过程中根据当前句型的最左非终结符A和当前输入符号a，选择正确的A-产生式。为保证分析的确定性，选出的候选式必须是唯一的。</p><p>S_文法（简单的确定性文法）为符合上述要求，需满足以下条件：每个产生式的右部都以终结符开始，同一非终结符的各个候选式的首终结符都不同</p><p>S_文法中不包含ε产生式</p><p>什么时候使用ε产生式？<br>    如果当前某非终结符A与当前输入符a不匹配时，若存在A→ε，可以通过检查a是否可以出现在 A的后面，来决定是否使用产生式 A→ε（若文法中无 A→ε ，则应报错）</p><p><strong>非终结符的后继符号集</strong></p><p>可能在某个句型中紧跟在A后边的终结符a的集合，记为FOLLOW(A)<br>$FOLLOW(A)&#x3D;{a| S \Rightarrow ^* \alpha A\alpha \beta, \alpha \in V_T， \alpha,\beta \in (V_T \cup V_N)^*}$ </p><p><img src="/../images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20220408162916081.png" alt="image-20220408162916081"></p><p><strong>产生式的可选集</strong>：</p><p>产生式A→β的可选集是指可以选用该产生式进行推导时对应的输入符号的集合，记为SELECT( A→β )<br>    SELECT( A→aβ ) &#x3D; { a }<br>    SELECT( A→ε )&#x3D;FOLLOW(A)<br><strong>q_文法</strong><br>    每个产生式的右部或为ε ，或以终结符开始<br>    具有相同左部的产生式有不相交的可选集，q_文法不含右部以非终结符打头的  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构</title>
      <link href="/posts/5b917df5/"/>
      <url>/posts/5b917df5/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-计算机系统结构导论"><a href="#第一章-计算机系统结构导论" class="headerlink" title="第一章 计算机系统结构导论"></a>第一章 计算机系统结构导论</h1><p>计算机系统结构又称为计算机体系结构，本章重点叙述计算机系统的功能、结构及设计方法，并介绍现代计算机系统结构的研究方向</p><h2 id="1-1-计算机系统的基本概念"><a href="#1-1-计算机系统的基本概念" class="headerlink" title="1.1 计算机系统的基本概念"></a>1.1 计算机系统的基本概念</h2><p>冯诺依曼体系的基础：数据由二进制存储、指令按顺序执行、由五大部件组成</p><p>计算机系统三种说法：</p><ol><li>五大部件组成：运算器、控制器、存储器、输入输出设备</li><li>软件、硬件组成</li><li>人员、数据、设备、程序、规程组成</li></ol><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.assets/image-20220307103023062.png" alt="image-20220307103023062"></p><h2 id="1-2-计算机系统的发展"><a href="#1-2-计算机系统的发展" class="headerlink" title="1.2 计算机系统的发展"></a>1.2 计算机系统的发展</h2><h3 id="1-2-1-冯诺依曼结构的特点"><a href="#1-2-1-冯诺依曼结构的特点" class="headerlink" title="1.2.1 冯诺依曼结构的特点"></a>1.2.1 冯诺依曼结构的特点</h3><p>特点：存储程序、运算器为中心、集中控制</p><p>现代处理机对冯诺依曼结构的改进：</p><p>不变：存储程序</p><p>改变：存储器为中心、总线结构、分散控制</p><h3 id="1-2-2-器件发展的影响"><a href="#1-2-2-器件发展的影响" class="headerlink" title="1.2.2 器件发展的影响"></a>1.2.2 器件发展的影响</h3><p>第一代至第四代计算机以器件划分：</p><ol><li>第一代：电子管</li><li>第二代：晶体管</li><li>第三代：集成电路</li><li>第四代：大规模集成电路</li></ol><p>器件发展是提高计算机速度的主要途径</p><p>期间发展的特点：</p><ol><li>集成度迅速提高：每四年提高一个数量级</li><li>速度已接近极限</li><li>价格直线下降</li><li>可靠性越来越高</li></ol><h3 id="1-2-3-应用发展的影响"><a href="#1-2-3-应用发展的影响" class="headerlink" title="1.2.3 应用发展的影响"></a>1.2.3 应用发展的影响</h3><h3 id="1-2-4-算法的影响"><a href="#1-2-4-算法的影响" class="headerlink" title="1.2.4 算法的影响"></a>1.2.4 算法的影响</h3><p>在多个层次上，算法影响系统结构</p><h3 id="1-2-5-价格对系统结构的影响"><a href="#1-2-5-价格对系统结构的影响" class="headerlink" title="1.2.5 价格对系统结构的影响"></a>1.2.5 价格对系统结构的影响</h3><h3 id="1-2-6-功耗对系统结构的影响"><a href="#1-2-6-功耗对系统结构的影响" class="headerlink" title="1.2.6 功耗对系统结构的影响"></a>1.2.6 功耗对系统结构的影响</h3><p>功耗与电压正相关，电路延迟与电压负相关</p><h2 id="1-3-计算机系统的功能和结构"><a href="#1-3-计算机系统的功能和结构" class="headerlink" title="1.3 计算机系统的功能和结构"></a>1.3 计算机系统的功能和结构</h2><h3 id="1-3-1-计算机系统的层次结构"><a href="#1-3-1-计算机系统的层次结构" class="headerlink" title="1.3.1 计算机系统的层次结构"></a>1.3.1 计算机系统的层次结构</h3><p>虚拟计算机：</p><p>​计算机用于完成信息处理，不同观察者用不同语言（广义语言）来描述信息处理流程</p><p>​从不同角度所看到的计算机系统属性是不同的</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.assets/image-20220307110708374.png" alt="image-20220307110708374"></p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.assets/image-20220307110807690.png" alt="image-20220307110807690"></p><p>第二级属于计算机系统结构</p><p>级之间有交叉，例如第3级必须依赖第4级和第5级来实现</p><h3 id="1-3-2-计算机系统结构的定义"><a href="#1-3-2-计算机系统结构的定义" class="headerlink" title="1.3.2 计算机系统结构的定义"></a>1.3.2 计算机系统结构的定义</h3><h4 id="之一"><a href="#之一" class="headerlink" title="之一"></a>之一</h4><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.assets/image-20220307111504136.png" alt="image-20220307111504136"></p><h4 id="之二"><a href="#之二" class="headerlink" title="之二"></a>之二</h4><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.assets/image-20220307111522880.png" alt="image-20220307111522880"></p><h4 id="透明性"><a href="#透明性" class="headerlink" title="透明性"></a>透明性</h4><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.assets/image-20220307111549259.png" alt="image-20220307111549259"></p><h3 id="1-3-3-计算机组成"><a href="#1-3-3-计算机组成" class="headerlink" title="1.3.3 计算机组成"></a>1.3.3 计算机组成</h3><p>计算机组成是指计算机系统结构的逻辑实现</p><p>计算机实现是指计算机组成的物理实现</p><h3 id="1-3-4-计算机系统结构、组成和实现之间的关系"><a href="#1-3-4-计算机系统结构、组成和实现之间的关系" class="headerlink" title="1.3.4 计算机系统结构、组成和实现之间的关系"></a>1.3.4 计算机系统结构、组成和实现之间的关系</h3><p>计算机系统结构-&gt;确定软硬件界面</p><p>计算机组成-&gt;逻辑实现</p><p>计算机实现-&gt;物理实现</p><p>三者的设计原则：</p><ol><li>系统结构设计不要对组成﹑实现有过多和不合理限制</li><li>组成设计应在系统结构指导下，以目前可实现技术为基础</li><li>实现应在组成的逻辑结构指导下，以目前器件技术为基础,以性能价格比优化为目标</li></ol><h3 id="1-3-5-计算机系统的特性"><a href="#1-3-5-计算机系统的特性" class="headerlink" title="1.3.5 计算机系统的特性"></a>1.3.5 计算机系统的特性</h3><p>计算机等级：巨、大、中、小、微</p><p>系列机：具有相同的系统结构，但组成和实现技术不同的一系列计算机系统</p><h4 id="软件兼容"><a href="#软件兼容" class="headerlink" title="软件兼容"></a>软件兼容</h4><p>软件兼容:同一个软件的旦标程序可以不加修改地运行于系统结构相同的任何机器上<br>兼容种类:</p><p>​向后兼容:新机器能直接运行老机器的目标程序</p><p>​向上兼容:低档机上的目标软件能直接运行于高档机</p><p>​向下兼容:高档机器的目标程序不加修改可运行于低档 (不常见)</p><p>向后兼容必须做到，向上兼容尽量做到，向前兼容和向下兼容，可以不考虑</p><p>采用系列机方法的主要优点:</p><ol><li>系列机之间软件兼容，可移植性好</li><li>插件﹑接口等相互兼容</li><li>便于实现机间通信</li><li>便于维修﹑培训</li><li>有利于提高产量﹑降低成本采用</li></ol><p>系列机方法的主要缺点:</p><p>​限制了计算机系统结构的发展,如PC 系列机，其系统结构非常落后，使用也最普及</p><h4 id="模拟与仿真"><a href="#模拟与仿真" class="headerlink" title="模拟与仿真"></a>模拟与仿真</h4><p>定义:在某个系统结构之上实现另一种系统结构。在一台现有的计算机上实现另一台计算机的指令系统·全部用软件实现的叫模拟，用软件﹑硬件﹑固件混合实现的叫仿真</p><p>模拟的实现方法：在A计算机上通过一段机器语言程序解释实现B计算机的指令系统。A机器称为宿主机，B机器称为虚拟机。</p><p>仿真的实现方法：直接用A机器的一段微程序解释执行B机器的指令，A机器称为宿主机，B机器称为目标机</p><p>优缺点：</p><p>模拟方法灵活，可实现程序在任何机器之间的相互移植,但实现复杂﹑速度低，因此适合移植运行时间不长，使用次数少的程序</p><p>仿真速度快，但难以仿真存储系统和IO系统，因此只适应于系统结构差别不大的机器之间的移植</p><h2 id="1-4-计算机系统的设计方法"><a href="#1-4-计算机系统的设计方法" class="headerlink" title="1.4 计算机系统的设计方法"></a>1.4 计算机系统的设计方法</h2><h3 id="1-4-1-软硬件取舍"><a href="#1-4-1-软硬件取舍" class="headerlink" title="1.4.1 软硬件取舍"></a>1.4.1 软硬件取舍</h3><h3 id="1-4-2-计算机系统设计的定量原则"><a href="#1-4-2-计算机系统设计的定量原则" class="headerlink" title="1.4.2 计算机系统设计的定量原则"></a>1.4.2 计算机系统设计的定量原则</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件工程</title>
      <link href="/posts/7821ac43/"/>
      <url>/posts/7821ac43/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-软件工程学概述"><a href="#第一章-软件工程学概述" class="headerlink" title="第一章 软件工程学概述"></a>第一章 软件工程学概述</h1><h2 id="1-1-软件危机"><a href="#1-1-软件危机" class="headerlink" title="1.1 软件危机"></a>1.1 软件危机</h2><p>个体化的软件环境：规模较小的程序，不需要设计，也没什么资料留存下来，只有软件清单。</p><p>这使得软件维护等工作非常浪费资源、很难维护</p><h3 id="1-1-1-软件危机的介绍"><a href="#1-1-1-软件危机的介绍" class="headerlink" title="1.1.1 软件危机的介绍"></a>1.1.1 软件危机的介绍</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>软件危机指在计算机软件的开发和维护过程中所遇到的一系列严重问题。包括：</p><ol><li>如何开发软件，以满足软件日益增长的需求</li><li>如何维护数量不断膨胀的已有软件</li></ol><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>软件危机的特征：<strong>长期性</strong>和<strong>症状不明显</strong></p><h4 id="典型表现"><a href="#典型表现" class="headerlink" title="典型表现"></a>典型表现</h4><ol><li><strong>对软件开发成本和进度的估计常常很不准确</strong>：实际成本比预期成本高出一个数量级、实际进度比预期进度拖延几个月甚至几年</li><li><strong>用户对“已完成”的软件系统不满意的现象经常发生</strong>：软件开发人员常常对用户要求只有模糊的了解，甚至对要解决的问题没有确切认识的情况下，匆忙着手编写程序。开发人员和用户之间的信息交流往往很不充分</li><li><strong>软件产品的质量往往靠不住</strong>：软件质量保证技术（审查、复审、程序正确性证明和测试）没有应用到软件开发的全过程中</li><li><strong>软件常常是不可维护的</strong>：难以适应不同的硬件环境；难以根据用户需要在原有程序中加入新功能</li><li><strong>软件通常没有适当的文档资料</strong>：用于管理和评价软件开发工程的进展状况；作为通讯工具，帮助开发人员交流信息；帮助软件维护。文档资料应和程序代码完全一致</li><li><strong>软件成本在计算机系统总成本中所占的比例逐年上升</strong></li><li><strong>软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势</strong>：软件产品供不应求</li><li>etc…</li></ol><h3 id="1-1-2-产生软件危机的原因"><a href="#1-1-2-产生软件危机的原因" class="headerlink" title="1.1.2 产生软件危机的原因"></a>1.1.2 产生软件危机的原因</h3><ol><li>规模加大、复杂性提高</li><li>软件是逻辑产品，缺乏“可见性”</li><li>技术手段和管理方法缺乏</li><li>用户和软件开发人员的理解鸿沟（Gap)</li><li>错误认识</li></ol><p>​认为软件开发就是写程序并设法使之运行</p><p>​忽视软件需求分析的重要性</p><p>​轻视软件测试和软件维护</p><h3 id="1-1-3-应对软件危机的途径"><a href="#1-1-3-应对软件危机的途径" class="headerlink" title="1.1.3 应对软件危机的途径"></a>1.1.3 应对软件危机的途径</h3><ol><li><p>消除错误观念：<strong>“软件就是程序”</strong></p><p>一个软件由一个完整的配置组成，是程序、数据及相关文档的完整集合</p></li><li><p>软件是产品，软件开发是工程项目</p></li><li><p>成功的软件开发技术和方法</p></li><li><p>软件工具和软件工程支撑环境</p></li></ol><h2 id="1-1-软件工程"><a href="#1-1-软件工程" class="headerlink" title="1.1 软件工程"></a>1.1 软件工程</h2><h3 id="1-2-1-软件工程的介绍"><a href="#1-2-1-软件工程的介绍" class="headerlink" title="1.2.1 软件工程的介绍"></a>1.2.1 软件工程的介绍</h3><p>概括地说：软件工程是指导计算机软件开发和维护的一门工程学科</p><p><strong>1968年NATO会议</strong>：软件工程就是为了<strong>经济地</strong>获得<strong>可靠的</strong>且能在实际机器上有效地运行的软件，而建立和使用完善的<strong>工程原理</strong></p><p><strong>IEEE标准</strong>：软件工程是：①把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程。即把工程应用于软件；②研究①中的途径</p><p>软件工程<strong>本质特性</strong>：</p><ol><li>关注<strong>大型程序</strong>的构造</li><li>中心课题是控制<strong>复杂性</strong></li><li>软件经常<strong>变化</strong></li><li>开发<strong>效率</strong>非常重要</li><li>和谐<strong>合作</strong>：标准、规程，纪律是软件开发项目的一个关键</li><li>软件必须有效地支持它的用户（<strong>V &amp; V</strong>）</li><li>一种文化背景的人替另一种文化背景的人创造<strong>产品</strong></li></ol><h3 id="1-2-2-软件工程的基本原理"><a href="#1-2-2-软件工程的基本原理" class="headerlink" title="1.2.2 软件工程的基本原理"></a>1.2.2 软件工程的基本原理</h3><ol><li>分阶段的生命周期（控制复杂性）</li><li>阶段评审（V&amp;V、控制复杂性）</li><li>严格的产品控制（变化管理、理解鸿沟）</li><li>采用现代的程序设计技术（效率）</li><li>结果应能清楚地审查（V&amp;V）</li><li>开发小组成员少而精（开发效率）</li><li>不断改进软件工程实践</li></ol><h3 id="1-2-3-软件工程方法学"><a href="#1-2-3-软件工程方法学" class="headerlink" title="1.2.3 软件工程方法学"></a>1.2.3 软件工程方法学</h3><p>软件生命周期全过程中使用的一整套技术方法的集合，也称为范型(paradigm)</p><img src="../images/软件工程.assets/image-20211201150505179.png" alt="image-20211201150505179" style="zoom:75%;" /><p>方法：完成软件开发的各项任务的技术方法（”怎么做“）</p><p>工具：运用方法而提供的自动的或半自动的软件工程支撑环境</p><p>过程：为了获得高质量的软件所需要完成的一系列任务的框架，规定了完成各项任务的工作步骤</p><h4 id="传统方法学"><a href="#传统方法学" class="headerlink" title="传统方法学"></a>传统方法学</h4><ol><li>生命周期方法学或结构化范型</li><li>采用结构化技术(结构化分析、设计和实现)</li><li>面向行为或面向数据</li></ol><p>一个阶段一个阶段顺序开发，前一个阶段的完成是开始后一个阶段工作的前提和基础，后一阶段任务的完成通常是使前一阶段提出的解法更进一步具体化，加进了更多的实现细节。一个阶段的结束标准是后一阶段的开始标准</p><h4 id="面向对象方法学"><a href="#面向对象方法学" class="headerlink" title="面向对象方法学"></a>面向对象方法学</h4><ol><li><p>以数据为主线，封装数据和对数据的操作</p></li><li><p>4个要点</p><p>(1) 把对象作为融合了数据及在数据上的操作行为的统一的软件构件。（用对象分解取代了传统方法的功能分解）</p><p>(2) 把所有对象都划分成类(class)。</p><p>(3) 按照父类和子类的关系，把若干个相关类组成一个层次结构的系统（也称为类等级）。</p><p>(4) 对象彼此间仅能通过发送消息互相联系。（封装性，不能直接处理对象内的数据，需要调用对象的操作）</p></li></ol><p>面向对象方法&#x3D;对象+类+继承+消息通信</p><h4 id="传统方法和面向对象方法的比较"><a href="#传统方法和面向对象方法的比较" class="headerlink" title="传统方法和面向对象方法的比较"></a>传统方法和面向对象方法的比较</h4><img src="../images/软件工程.assets/image-20211201154037017.png" alt="image-20211201154037017" style="zoom:67%;" /><p>传统方法强调自顶向下地完成软件开发的各阶段任务</p><p>面向对象方法尽量模拟人类习惯的思维方式</p><p><img src="/../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211201154941734.png" alt="image-20211201154941734"></p><h2 id="1-3-软件生命周期"><a href="#1-3-软件生命周期" class="headerlink" title="1.3 软件生命周期"></a>1.3 软件生命周期</h2><p>软件产品或系统的一系列相关活动的全周期</p><p>3大阶段：软件定义、软件开发、软件维护</p><h3 id="1-3-1-软件定义"><a href="#1-3-1-软件定义" class="headerlink" title="1.3.1 软件定义"></a>1.3.1 软件定义</h3><p>要解决的问题：</p><ol><li>确定软件开发工程必须完成的总目标</li><li>确定工程的可行性</li><li>导出应该采用的策略及系统必须完成的功能</li><li>估计资源和成本</li><li>制定进度</li></ol><p>三阶段：问题定义、可行性研究、需求分析</p><h4 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h4><p>要解决的问题是什么，确定工程的目标和规模</p><h4 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h4><p>有可行的解决办法吗？</p><p>经济可行性、技术可行性、操作可行性等，不同的方案</p><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>为了解决问题，目标系统必须做什么</p><p>确定系统的功能和性能，运行环境，预测发展前景</p><p>书写规格说明书(specification)</p><h3 id="1-3-2-软件开发"><a href="#1-3-2-软件开发" class="headerlink" title="1.3.2 软件开发"></a>1.3.2 软件开发</h3><p>具体设计和实现在前一个时期定义的软件</p><p>四阶段：系统设计（总体设计、详细设计）、系统实现（编码和单元测试、综合测试）</p><h4 id="总体设计（概要设计）"><a href="#总体设计（概要设计）" class="headerlink" title="总体设计（概要设计）"></a>总体设计（概要设计）</h4><p>概括地说，应该怎样实现目标系统</p><p>分析目标系统的几种可能方案，推荐一个最佳方案</p><p>设计程序的体系结构（程序由哪些模块组成及模块间的关系）</p><h4 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h4><p>怎样具体地实现目标系统，设计程序的详细规格说明</p><h4 id="编码和单元测试"><a href="#编码和单元测试" class="headerlink" title="编码和单元测试"></a>编码和单元测试</h4><p>写出易理解、易维护的程序模块并测试每个模块</p><h4 id="综合测试"><a href="#综合测试" class="headerlink" title="综合测试"></a>综合测试</h4><p>集成测试和验收测试，现场测试或平行运行</p><h3 id="1-3-3-软件维护"><a href="#1-3-3-软件维护" class="headerlink" title="1.3.3 软件维护"></a>1.3.3 软件维护</h3><p>使软件持久地满足用户的需要</p><p>改正错误、适配新环境、跟进用户新需求</p><p>改正性维护（改正软件错误）、适应性维护（适配新环境）、完善性维护（跟进用户新需求）、预防性维护（未雨绸缪，准备下一次维护）</p><h2 id="1-4-软件过程"><a href="#1-4-软件过程" class="headerlink" title="1.4 软件过程"></a>1.4 软件过程</h2><p>定义：为了获得高质量软件所需要的一系列任务的框架，它规定了完成各项任务的工作步骤</p><p>即什么人、什么时候、做什么和怎样做</p><p>把<strong>生命周期</strong>划分成<strong>阶段</strong>及<strong>各个阶段的执行顺序</strong></p><p>ISO9000把过程定义为：使用资源将输入转化为输出的活动所构成的系统</p><p>此处，系统的含义是广义的：系统是相互关联或相互作用的一组要素</p><h3 id="1-4-1-瀑布模型"><a href="#1-4-1-瀑布模型" class="headerlink" title="1.4.1 瀑布模型"></a>1.4.1 瀑布模型</h3><p>传统软件工程方法学的软件过程，基本可以用瀑布模型描述</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><p>阶段间具有顺序性和依赖性</p><p>必须等前一阶段的工作完成之后，才能开始后一阶段的工作</p><p>前一阶段的输出文档就是后一阶段的输入文档</p></li><li><p>推迟实现</p><p>区分逻辑设计与物理设计，推迟程序的物理实现</p></li><li><p>质量保证(<strong>文档驱动</strong>)</p><p>每个阶段必须完成规定的文档</p><p>每个阶段结束前都要对所完成的文档进行评审</p></li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>强迫开发人员使用规范化的方法</p><p>严格规定每个阶段必须提交的文档</p><p>每个阶段的产品都必须经过质量保证小组的仔细验证</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>开发过程不能逆转，否则代价太大。难适应变化</p><p>软件的实际情况必须到开发后期才能看到</p><p>用户难以通过文档实际体验软件，依靠实践而产生新的需求或改动无法及时传达</p><p><img src="../images/软件工程.assets/image-20211201205434803.png" alt="image-20211201205434803" style="zoom:50%;" /><img src="软件工程.assets/image-20211201205439302.png" alt="image-20211201205439302" style="zoom:50%;" /></p><p>右图：反馈环</p><h3 id="1-4-2-快速原型模型"><a href="#1-4-2-快速原型模型" class="headerlink" title="1.4.2 快速原型模型"></a>1.4.2 快速原型模型</h3><p>快速建立可运行的程序，完成最终产品的功能子集</p><p><img src="软件工程.assets/image-20211201210933168.png" alt="image-20211201210933168" style="zoom:50%;" /><img src="../images/软件工程.assets/image-20211201210940598.png" alt="image-20211201210940598" style="zoom: 50%;" /></p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>本质是“快速”</p><p>获取用户需求，适应需求变化</p><p>利于开发与培训的同步</p><h4 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h4><p>用户需求不完全或不准确,有快速原型开发工具</p><p>项目招投标</p><p>产品移植、升级或客户化</p><h3 id="1-4-3-增量模型"><a href="#1-4-3-增量模型" class="headerlink" title="1.4.3 增量模型"></a>1.4.3 增量模型</h3><p>瀑布&#x2F;快速原型：交付一个完整可用的产品</p><p>增量模型：把软件作为一系列增量构件来开发</p><p><img src="/../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211202160503695.png" alt="image-20211202160503695"></p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>分阶段交付可用产品</li><li>减少全新产品给客户带来的心理上的影响</li><li>需求经常变化，增量模型的灵活性使其具有更加优越的适用性</li></ol><h4 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h4><p>​需要一个开放的结构，方便构件的加入</p><h4 id="风险更大的增量模型"><a href="#风险更大的增量模型" class="headerlink" title="风险更大的增量模型"></a>风险更大的增量模型</h4><p>不同的构件并行构建，速度加快，风险更大</p><p><img src="/../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211202160946387.png" alt="image-20211202160946387"></p><h3 id="1-4-4-螺旋模型"><a href="#1-4-4-螺旋模型" class="headerlink" title="1.4.4 螺旋模型"></a>1.4.4 螺旋模型</h3><p>基本思想：使用原型及其他方法来尽量降低风险，强调风险分析</p><p>可以看作在每个阶段之前都增加了风险分析过程的快速原型 模型</p><p><img src="软件工程.assets/image-20211202201800815.png" alt="image-20211202201800815" style="zoom:67%;" /><img src="../images/软件工程.assets/image-20211202201813187.png" alt="image-20211202201813187" style="zoom:67%;" /></p><h3 id="1-4-5-喷泉模型"><a href="#1-4-5-喷泉模型" class="headerlink" title="1.4.5 喷泉模型"></a>1.4.5 喷泉模型</h3><p>迭代：软件开发过程的一种内在属性</p><p>阶段间的迭代</p><p>阶段内工作步骤的迭代</p><p>工作重点：分析阶段</p><p>定义面向问题的对象，不断充实和扩充对象</p><p>对生命周期各阶段的区分不重要、不明显</p><p>无缝连接：分析得到的对象模型也适用设计和实现</p><p><img src="/../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211207132357142.png" alt="image-20211207132357142"></p><h3 id="1-4-6-RUP过程"><a href="#1-4-6-RUP过程" class="headerlink" title="1.4.6 RUP过程"></a>1.4.6 RUP过程</h3><p>RUP: Rational Unified Process</p><p><strong>最佳实践</strong></p><p>​迭代式开发</p><p>​管理需求（需求连续变化，用例驱动）</p><p>​基于构件的体系结构</p><p>​可视化建模（UML）</p><p>​验证软件质量（内建的贯穿整个开发过程）</p><p>​控制软件变更</p><p><strong>四个阶段</strong></p><p>​开始：建立业务模型，定义项目范围</p><p>​精化：系统的体系结构、项目计划、 资源需求</p><p>​构造：构件开发，软件产品</p><p>​移交：软件产品移交给用户</p><p><img src="/../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211207133033816.png" alt="image-20211207133033816"></p><p><img src="/../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211207133115575.png" alt="image-20211207133115575"></p><p><img src="/../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211207133119470.png" alt="image-20211207133119470"></p><h3 id="1-4-7-敏捷过程与极限编程"><a href="#1-4-7-敏捷过程与极限编程" class="headerlink" title="1.4.7 敏捷过程与极限编程"></a>1.4.7 敏捷过程与极限编程</h3><h4 id="1-敏捷过程"><a href="#1-敏捷过程" class="headerlink" title="1. 敏捷过程"></a>1. 敏捷过程</h4><ol><li>个体和交互胜过过程和工具</li><li>可以工作的软件胜过面面俱到的文档</li><li>客户合作胜过合同谈判</li><li>响应变化胜过遵循计划</li></ol><h4 id="2-极限编程"><a href="#2-极限编程" class="headerlink" title="2. 极限编程"></a>2. 极限编程</h4><ol><li><p>极限编程的有效实践</p><p>客户作为开发团队的成员</p><p>使用用户素材</p><p>短交付周期</p><p>验收测试</p><p>结对编程</p><p>测试驱动开发</p><p>集成所有</p><p>持续集成</p><p>可持续的开发速度</p><p>开放的工作空间</p><p>及时调整计划</p><p>简单的设计</p><p>重构</p><p>使用隐喻</p></li><li><p>极限编程的整体开发过程</p></li></ol><p><img src="/../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211207134033610.png" alt="image-20211207134033610"></p><ol start="3"><li>极限编程的迭代过程</li></ol><p><img src="/../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211207134054094.png" alt="image-20211207134054094"></p><h3 id="1-4-8-微软过程"><a href="#1-4-8-微软过程" class="headerlink" title="1.4.8 微软过程"></a>1.4.8 微软过程</h3><ol><li><p>微软过程准则</p><p>项目计划兼顾未来的不确定因素</p><p>经常快速测试过渡版本</p><p>快速循环、递进的开发过程</p><p>小型项目组并行开发</p><p>原型验证</p><p>里程碑评审、切忌相互指责</p></li></ol><h1 id="第2章-可行性研究"><a href="#第2章-可行性研究" class="headerlink" title="第2章 可行性研究"></a>第2章 可行性研究</h1><h2 id="2-1-可行性研究的任务"><a href="#2-1-可行性研究的任务" class="headerlink" title="2.1 可行性研究的任务"></a>2.1 可行性研究的任务</h2><p>技术可行性</p><p>经济可行性</p><p>操作可行性</p><h2 id="2-2-可行性研究过程"><a href="#2-2-可行性研究过程" class="headerlink" title="2.2 可行性研究过程"></a>2.2 可行性研究过程</h2><ol><li>复查系统规模和目标</li><li>研究目前正在使用的系统</li><li>到处新系统的高层逻辑模型</li><li>进一步定义问题</li><li>导出和评价供选择的解法</li><li>推荐行动方针</li><li>草拟开发计划</li><li>书写文档提交审查</li></ol><h2 id="2-3-系统流程图"><a href="#2-3-系统流程图" class="headerlink" title="2.3 系统流程图"></a>2.3 系统流程图</h2><p>系统流程图是物理数据流图</p><h3 id="2-3-1-符号"><a href="#2-3-1-符号" class="headerlink" title="2.3.1 符号"></a>2.3.1 符号</h3><p><img src="/../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211207150819016.png" alt="image-20211207150819016"></p><p><img src="/../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211207150835649.png" alt="image-20211207150835649"></p><h3 id="2-3-2-例子"><a href="#2-3-2-例子" class="headerlink" title="2.3.2 例子"></a>2.3.2 例子</h3><p><img src="/../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211207151634634.png" alt="image-20211207151634634"></p><h3 id="2-3-3-分层"><a href="#2-3-3-分层" class="headerlink" title="2.3.3 分层"></a>2.3.3 分层</h3><p>对复杂系统，较好方法是分层次描绘这个系统</p><p>首先用一张高层次的系统流程图描绘系统总体概貌，表明系统的关键功能</p><p>然后分别把每个关键功能扩展到适当的详细程度，画在单独的一张纸上</p><h2 id="2-4-数据流图"><a href="#2-4-数据流图" class="headerlink" title="2.4 数据流图"></a>2.4 数据流图</h2><p>数据流图是系统逻辑功能的图形表示，只需考虑系统必须完成的基本逻辑功能</p><h3 id="2-4-1-符号"><a href="#2-4-1-符号" class="headerlink" title="2.4.1 符号"></a>2.4.1 符号</h3><p><img src="/../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211207153343540.png" alt="image-20211207153343540"></p><p><img src="/../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.assets/image-20211207153830193.png" alt="image-20211207153830193"></p><h3 id="2-4剩下的不想记了，烦死了"><a href="#2-4剩下的不想记了，烦死了" class="headerlink" title="2.4剩下的不想记了，烦死了"></a>2.4剩下的不想记了，烦死了</h3><h2 id="2-5-数据字典"><a href="#2-5-数据字典" class="headerlink" title="2.5 数据字典"></a>2.5 数据字典</h2><p>数据字典是关于数据的信息的集合，是对数据流图中包含的所有元素的定义的集合</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理</title>
      <link href="/posts/e518e14/"/>
      <url>/posts/e518e14/</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-数据库发展史"><a href="#第1章-数据库发展史" class="headerlink" title="第1章 数据库发展史"></a>第1章 数据库发展史</h1><h2 id="1-1-数据管理技术的发展"><a href="#1-1-数据管理技术的发展" class="headerlink" title="1.1 数据管理技术的发展"></a>1.1 数据管理技术的发展</h2><h3 id="1-1-1-人工管理阶段"><a href="#1-1-1-人工管理阶段" class="headerlink" title="1.1.1 人工管理阶段"></a>1.1.1 人工管理阶段</h3><p>时间：20世纪50年代中期以前，计算机本身的水平较低。</p><p>硬件方面：计算机的运算速度低、内存容量小，外存还没有磁盘等直接存取的存储设备</p><p>软件方面：还没有操作系统，没有管理数据的软件。</p><p><strong>特点</strong>：</p><ol><li>数据不保存在计算机内</li><li>没有专用的软件对数据进行管理</li><li>只有程序，没有文件的概念</li><li>数据面向程序</li></ol><h3 id="1-1-2-文件系统阶段"><a href="#1-1-2-文件系统阶段" class="headerlink" title="1.1.2 文件系统阶段"></a>1.1.2 文件系统阶段</h3><p>时间：从20世纪50年代后期到60年代中期，计算机的硬件、软件都有了很大发展</p><p>硬件：有了磁盘、磁鼓等直接存取的存储设备</p><p>软件：有了操作系统，其中有专门管理数据的文件系统。</p><p>从处理方式讲，不仅有了文件批处理，而且能够联机实时处理。此时，计算机不仅用于科学计算，还大量用于管理。</p><img src="../images/数据库原理.assets/image-20211201223703591.png" alt="image-20211201223703591" style="zoom:67%;" /><p><strong>特点</strong>：</p><ol><li>数据以文件形式长期保存在磁盘上</li><li>数据的逻辑结构与物理结构有了区别</li><li>文件组织多样化</li><li>数据不再属于某个特定的程序，可以重复使用</li><li>对数据的操作以记录为单位</li></ol><img src="../images/数据库原理.assets/image-20211201223714129.png" alt="image-20211201223714129" style="zoom:67%;" /><h3 id="1-1-3-文件系统的缺陷"><a href="#1-1-3-文件系统的缺陷" class="headerlink" title="1.1.3 文件系统的缺陷"></a>1.1.3 文件系统的缺陷</h3><p><strong>数据的冗余性</strong>：文件之间缺乏联系，每个应用程序对应的文件中可能有重复存储的数据</p><p><strong>数据不一致性</strong>：往往由数据冗余造成，文件更新时，相同的数据在不同文件中不一样。</p><p><strong>数据联系弱</strong>：文件之间相互独立，缺乏联系</p><h3 id="1-1-4-倒排文件系统阶段"><a href="#1-1-4-倒排文件系统阶段" class="headerlink" title="1.1.4 倒排文件系统阶段"></a>1.1.4 倒排文件系统阶段</h3><p>倒排文件是索引文件的推广，每个字段提供单独的索引，方便用户检索，但数据的更新比较复杂和困难</p><h2 id="1-2-数据库技术的产生和发展"><a href="#1-2-数据库技术的产生和发展" class="headerlink" title="1.2 数据库技术的产生和发展"></a>1.2 数据库技术的产生和发展</h2><h3 id="1-2-1-数据库技术的产生"><a href="#1-2-1-数据库技术的产生" class="headerlink" title="1.2.1 数据库技术的产生"></a>1.2.1 数据库技术的产生</h3><p><strong>IMS系统</strong></p><p>1968年IBM公司研制IMS系统，在IBM360&#x2F;370机上运行。层次</p><p><strong>DBTG报告</strong></p><p>1969年CODASYL（美国数据系统语言协会）的DBTG小组出一份报告，即DBTG报告。网状</p><p><strong>E.F.Codd的文章</strong></p><p>E.F.Codd于1970年在美国计算机学会通信杂志发表一文。关系</p><h3 id="1-2-2-数据库阶段的数据管理特点"><a href="#1-2-2-数据库阶段的数据管理特点" class="headerlink" title="1.2.2 数据库阶段的数据管理特点"></a>1.2.2 数据库阶段的数据管理特点</h3><ol><li><p>采用复杂的数据模型表示数据结构</p><p>描述数据之间的关系，通过存取路径实现，面向整个应用系统</p><p>数据库系统和传统文件系统的根本区别：数据库系统通过所有存取路径表示自然的数据联系</p></li><li><p>有较高的数据独立性：物理独立性、逻辑独立性</p><p>数据独立性：数据和程序分离，解耦</p><p>物理数据独立性：物理结构的改变尽量不影响整体逻辑结构、用户的逻辑结构以及应用程序</p><p>逻辑数据独立性：整体逻辑结构改变时，尽量不影响用户的逻辑结构及应用程序</p></li><li><p>提供了方便的用户接口</p></li><li><p>提供四个方面的数据控制功能</p><p>并发控制、恢复、完整性、安全性</p></li><li><p>数据操作灵活</p></li></ol><img src="../images/数据库原理.assets/image-20211201224931993.png" alt="image-20211201224931993" style="zoom:67%;" /><h3 id="1-2-3-数据库技术的术语"><a href="#1-2-3-数据库技术的术语" class="headerlink" title="1.2.3 数据库技术的术语"></a>1.2.3 数据库技术的术语</h3><p><strong>数据库（DB）</strong>：</p><p>是统一管理的相关数据的集合。</p><p><strong>数据库管理系统（DBMS）</strong>：</p><p>是位于用户与操作系统之间的一层数据管理软件，为用户和应用程序提供访问DB的方法，包括DB的建立、查询、更新及各种数据控制。</p><p><strong>数据库系统（DBS）</strong>：</p><p>是实现有组织地、动态地存储大量关联数据，方便多用户的计算机软件、硬件和数据资源组成的系统，即采用了数据库技术的计算机系统。</p><p><strong>数据库技术</strong>：</p><p>是一门研究数据库的结构、存储、管理和使用的软件学科。</p><h3 id="1-2-4-数据库技术的发展"><a href="#1-2-4-数据库技术的发展" class="headerlink" title="1.2.4 数据库技术的发展"></a>1.2.4 数据库技术的发展</h3><p>分布式数据库技术（区块链）</p><p>面向对象数据库技术</p><p>数据仓库</p><p>云数据库（Amazon AWS）</p><p>大数据（5V）</p><p>其他数据库技术</p><h1 id="第2章-数据库系统结构"><a href="#第2章-数据库系统结构" class="headerlink" title="第2章 数据库系统结构"></a>第2章 数据库系统结构</h1><h2 id="2-1-数据描述"><a href="#2-1-数据描述" class="headerlink" title="2.1 数据描述"></a>2.1 数据描述</h2><h3 id="2-1-1-概念设计中的数据描述"><a href="#2-1-1-概念设计中的数据描述" class="headerlink" title="2.1.1 概念设计中的数据描述"></a>2.1.1 概念设计中的数据描述</h3><p>概念设计：根据用户的需求设计数据库的概念结构</p><p><strong>实体(Entity)</strong></p><p>实体是客观存在、可以相互区分的事物，既可以是实际存在的对象，也可以是某种概念。例如：一个工厂、一个车间、一种操作流程等。</p><p><strong>属性(Attribute)</strong></p><p>事物是有特性的。反映在实体上，就是实体的属性。一个实体具有有限个属性，也可以说是这些属性的总和组成了这个实体。</p><p><strong>实体集(Entityset)</strong></p><p>所有属性名完全相同的实体往往集合在一起，称为实体集。例如：全体职工就是一个实体集。为了区分实体集，每个实体集都有一个名称，即实体名。。</p><p><strong>实体标识符(Identifier)</strong></p><p>能惟一标识实体的属性或属性集。也称关键码，或键。</p><h3 id="2-1-2-逻辑设计中的数据描述"><a href="#2-1-2-逻辑设计中的数据描述" class="headerlink" title="2.1.2 逻辑设计中的数据描述"></a>2.1.2 逻辑设计中的数据描述</h3><p>逻辑设计：根据概念设计得到的概念结构来设计的数据库逻辑结构，即表达方式和实现方法</p><p><strong>字段（Field）</strong></p><p>标记实体属性的命名单位。也称数据项。</p><p><strong>记录（Record）</strong></p><p>字段的有序集合。</p><p><strong>文件（File）</strong></p><p>同一类记录的集合。</p><p><strong>关键码（Key）</strong></p><p>能惟一标识文件中每个记录的字段。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20211201230929836.png" alt="image-20211201230929836"></p><h3 id="2-1-3-存储介质层次及数据描述"><a href="#2-1-3-存储介质层次及数据描述" class="headerlink" title="2.1.3 存储介质层次及数据描述"></a>2.1.3 存储介质层次及数据描述</h3><p><strong>物理存储介质层次</strong>：</p><p>高速缓冲存储器</p><p>主存储器</p><p>快擦写存储器（快闪存）</p><p>磁盘存储器</p><p>光存储器</p><p>磁带</p><p><strong>物理存储中的数据描述</strong>：位、字节、字、块、桶、卷</p><h3 id="2-1-4-数据联系的描述"><a href="#2-1-4-数据联系的描述" class="headerlink" title="2.1.4 数据联系的描述"></a>2.1.4 数据联系的描述</h3><p>实体集内部（实体和实体之间）的联系</p><p>实体间的联系有三种：</p><ol><li><p>同一实体集中各实体之间的联系(一元联系)。</p></li><li><p>两个实体集中各实体之间的联系(两元联系)。</p></li><li><p>三个实体集中各实体之间的联系(三元联系)。</p></li></ol><p>二元联系的实体间联系有三种情况：</p><ol><li>一对一 （1：1）</li><li>一对多 （1：N）</li><li>多对多 （M：N）</li></ol><h2 id="2-2-数据模型"><a href="#2-2-数据模型" class="headerlink" title="2.2 数据模型"></a>2.2 数据模型</h2><h3 id="2-2-1-数据模型的定义"><a href="#2-2-1-数据模型的定义" class="headerlink" title="2.2.1 数据模型的定义"></a>2.2.1 数据模型的定义</h3><p>数据模型分两种：</p><ol><li>概念数据模型：用于建立信息世界的数据模型，与硬件、DBMS无关，实现方法是“实体联系模型”。（用户观点）</li><li>结构（逻辑）数据模型：直接面向数据库的逻辑结构，与硬件、DBMS有关，有三部分构成：<strong>数据结构</strong>、<strong>数据操作</strong>、<strong>数据完整性约束</strong></li></ol><p><strong>数据结构</strong>是指对实体类型和实体间联系的表达和实现。</p><p><strong>数据操作</strong>是指对数据库的检索和更新（包括插入、删除和修改〉两类操作。</p><p><strong>数据完整性约束</strong>给出数据及其联系应具有的制约和依赖规则。</p><h3 id="2-2-2-实体联系模型"><a href="#2-2-2-实体联系模型" class="headerlink" title="2.2.2 实体联系模型"></a>2.2.2 实体联系模型</h3><p>P.P.S.Chen（陈品山）于1976年提出的“实体―联系模型” （Entity―Relationship Approach,简称E―R模型）</p><p>ER图中四个基本成分：</p><ol><li><p><strong>矩形框：表示实体类型</strong></p></li><li><p><strong>菱形框：表示联系类型</strong></p></li><li><p><strong>椭圆形框：表示实体类型或联系类型的属性</strong></p></li><li><p><strong>连线：实体与属性之间、实体与联系之间</strong></p></li></ol><p>多元联系：两个及以上实体集之间的联系</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20211202115641372.png" alt="image-20211202115641372"></p><p>自身联系：在一个联系中,一个实体集可以出现两次或多次, 扮演多个不同角色, 此种情况称为实体集的自身联系。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20211202115850591.png" alt="image-20211202115850591"></p><h3 id="2-2-3-层次模型"><a href="#2-2-3-层次模型" class="headerlink" title="2.2.3 层次模型"></a>2.2.3 层次模型</h3><p>用<strong>树</strong>形（层次）结构表示实体类型及实体间联系的数据模型称为<strong>层次模型</strong>。</p><p>树的结点是记录类型，每个非根结点有且只有一个父节点，上一层和下一层记录类型之间的联系是1:N联系</p><p><strong>特点</strong>：</p><ol><li>有且仅有一个结点无父结点,这样的结点称为根结点；</li><li>非根结点都有且仅有一个父结点。</li><li>记录之间的联系通过<strong>指针</strong>实现，查询效率高</li></ol><p><strong>优点</strong>：</p><ol><li>查询效率高</li><li>用户面对逻辑数据，不必过多考虑物理细节，逻辑与物理数据的转换由DBMS完成</li></ol><p><strong>缺点</strong>：</p><ol><li>只能表示1:N联系，M:N联系实现复杂，用户不易掌握</li><li>层次顺序严格和复杂，导致数据的查询和更新操作复杂，使程序编写复杂</li></ol><h3 id="2-2-4-网状模型"><a href="#2-2-4-网状模型" class="headerlink" title="2.2.4 网状模型"></a>2.2.4 网状模型</h3><p>用有向<strong>图</strong>结构表示实体类型及实体间联系的数据模型称为<strong>网状模型</strong>。</p><p>有向图中的结点是记录类型，箭头表示从箭尾的记录类型到箭头的记录类型间的联系是1:N联系</p><p>换句话说：把层次模型的限制放开： 一个结点可以有一个以上的父结点, 就得到网状模型。</p><p><strong>特点</strong>：</p><ol><li>可能有一个以上的结点无父结点</li><li>结点与其父结点之间的联系可以不止一个</li><li>记录之间的联系通过<strong>指针</strong>实现，查询效率高</li></ol><p><strong>缺点</strong>：数据结构复杂和编程复杂</p><h3 id="2-2-5-关系模型"><a href="#2-2-5-关系模型" class="headerlink" title="2.2.5 关系模型"></a>2.2.5 关系模型</h3><p>关系模型的主要特征是用二维<strong>表</strong>格表达实体集。</p><p><strong>特点</strong>：数据结构是<strong>表格</strong>，记录之间的联系通过模式的键体现</p><h3 id="2-2-6-面向对象模型"><a href="#2-2-6-面向对象模型" class="headerlink" title="2.2.6 面向对象模型"></a>2.2.6 面向对象模型</h3><p>面向对象模型是一种可扩充的数据模型,在该数据模型中,数据模型是可扩充的,即用户可根据需要,自己定义新的数据类型及相应的约束和操作。</p><p>基本的概念是对象和类</p><p><strong>对象</strong>：对象是面向对象数据模型的基本结构,是面向对象数据库系统的核心。 一个对象是由一些数据以及能够作用在这些数据上的操作组成。 例如,一个职工对象,将包含与职工相关的数据（职工号、 姓名、 性别、 职称、 部门等）以及能够在这些职工数据上进行的操作（增加职工、 删除职工、改变职称等等）。</p><p><strong>类</strong>：在组织信息时,人们总是将具有相似特性的对象归为一类。 类中的每个对象称为类的一个实例（Instance）。 一个类中的所有对象其特性必须相同,即具有相同的属性、 响应相同的消息、 使用相同的方法。</p><p>如果说类的概念相当于关系模型中的关系模式,那么类的实例类似于元组,类的实例之间和类之间可以有复杂的联系。</p><h2 id="2-3-数据库的体系结构"><a href="#2-3-数据库的体系结构" class="headerlink" title="2.3 数据库的体系结构"></a>2.3 数据库的体系结构</h2><h3 id="2-3-1-三级模式结构"><a href="#2-3-1-三级模式结构" class="headerlink" title="2.3.1 三级模式结构"></a>2.3.1 三级模式结构</h3><p>数据的三级模式结构包含有外模式、模式和内模式。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20211202134527810.png" alt="image-20211202134527810"></p><h3 id="2-3-2-三级结构和两级映像"><a href="#2-3-2-三级结构和两级映像" class="headerlink" title="2.3.2 三级结构和两级映像"></a>2.3.2 三级结构和两级映像</h3><h4 id="三级结构"><a href="#三级结构" class="headerlink" title="三级结构"></a>三级结构</h4><p><strong>模式</strong>（Schema）</p><p>​模式也称概念模式，是数据库中全体数据在逻辑上的视图。</p><p>​不涉及到存储结构、访问技术等细节，以达到物理数据独立性。</p><p><strong>外模式</strong>（External Schema）</p><p>​外模式也称子模式，是个别用户的数据视图，即个别用户涉及到的数据的逻辑结构。</p><p><strong>内模式</strong>（Internal Schema）</p><p>​内模式也称存储模式。它既定义了数据库中全部数据的物理结构，还定义了数据的存储方法、存取策略等。</p><h4 id="二级映像"><a href="#二级映像" class="headerlink" title="二级映像"></a>二级映像</h4><p><strong>外模式&#x2F;模式映像</strong>：存在于外部级与概念级之间，用于定义外模式和概念模式之间的对应性</p><p><strong>模式&#x2F;内模式映像</strong>：存在于概念级和内部级之间，用于定义概念模式和内模式之间的对应性</p><p>在外模式与模式之间通过外模式&#x2F;模式映象进行转换。当模式改变时，只要相应改变外模式&#x2F;模式映象，可使外模式保持不变。在模式与内模式之间通过模式&#x2F;内模式映象进行转换。</p><h3 id="2-3-3-两级数据独立性"><a href="#2-3-3-两级数据独立性" class="headerlink" title="2.3.3 两级数据独立性"></a>2.3.3 两级数据独立性</h3><p><strong>数据独立性</strong>：应用程序和数据库的数据结构之间相互独立，不受影响</p><p>分为<strong>物理数据独立性</strong>和<strong>逻辑数据独立性</strong></p><p>当数据库的存储结构改变时，只要相应改变模式&#x2F;内模式映象，可使模式保持不变，从而，外模式也可保持不变。这二级转换使数据库系统的数据具有较高的逻辑独立性和物理独立性。</p><h3 id="2-3-4-用户及用户界面"><a href="#2-3-4-用户及用户界面" class="headerlink" title="2.3.4 用户及用户界面"></a>2.3.4 用户及用户界面</h3><p>用户是指使用数据库的应用程序或联机终端用户。</p><p>编写应用程序的语言是高级程序设计语言，称为主语言。</p><p>DBMS还提供数据操纵语言DML。</p><h2 id="2-4-数据库管理系统"><a href="#2-4-数据库管理系统" class="headerlink" title="2.4 数据库管理系统"></a>2.4 数据库管理系统</h2><h3 id="2-4-1-DBMS的工作模式"><a href="#2-4-1-DBMS的工作模式" class="headerlink" title="2.4.1 DBMS的工作模式"></a>2.4.1 DBMS的工作模式</h3><p>接受应用程序的数据请求和处理请求</p><p>将用户的数据请求（高级指令）转换成复杂的机器代码（底层指令）</p><p>实现对数据库的操作</p><p>从对数据库的操作中接受查询结果</p><p>对查询结果进行处理（格式转换）</p><p>将处理结果返回给用户</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20211202152250570.png" alt="image-20211202152250570"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20211202152337297.png" alt="image-20211202152337297"></p><h3 id="2-4-2-DBMS的主要功能"><a href="#2-4-2-DBMS的主要功能" class="headerlink" title="2.4.2 DBMS的主要功能"></a>2.4.2 DBMS的主要功能</h3><p><strong>数据库的定义功能</strong></p><p>DBMS提供DDL来定义模式、外模式和内模式</p><p><strong>数据库的操纵功能</strong></p><p>DBMS应提供数据操纵语言（DML）供用户对数据库中的数据进行检索、修改、删除以及插入工作。</p><p><strong>数据库的保护功能</strong></p><p>数据库的恢复、并发控制、完整性、安全性</p><p><strong>数据库的维护功能</strong></p><p><strong>数据字典DD</strong></p><h3 id="2-4-3-DBMS的模块组成"><a href="#2-4-3-DBMS的模块组成" class="headerlink" title="2.4.3 DBMS的模块组成"></a>2.4.3 DBMS的模块组成</h3><p>两大模块：查询处理器和存储管理器</p><p><strong>查询处理器</strong></p><p>DML编译器、嵌入型DML的预编译器、DML编译器、查询运行核心程序。</p><p><strong>存储管理器</strong> </p><p>授权和完整性管理器、事务管理器、文件管理器、缓冲区管理器。</p><h2 id="2-5-数据库系统"><a href="#2-5-数据库系统" class="headerlink" title="2.5 数据库系统"></a>2.5 数据库系统</h2><p><strong>数据库</strong></p><p>物理数据库，描述数据库。</p><p><strong>硬件</strong></p><p>计算机硬件，存储设备。</p><p><strong>软件</strong></p><p>DBMS、OS、各种宿主语言和应用开发支撑软件。</p><p><strong>数据库管理员（DBA）</strong></p><p>控制数据整体结构，负责DBS的正常运行。</p><p>DBA的<strong>职责</strong>：</p><ol><li>定义模式</li><li>定义内模式</li><li>与用户的联络（定义外模式、应用程序设计、提供技术培训等专业服务）</li><li>定义安全性规则，对用户访问数据库的授权</li><li>定义完整性规则，监督数据库的运行</li><li>数据库的转储与恢复工作</li></ol><p>DBA的工具：DD系统和一系列实用程序</p><h3 id="2-5-2-DBS的全局结构"><a href="#2-5-2-DBS的全局结构" class="headerlink" title="2.5.2 DBS的全局结构"></a>2.5.2 DBS的全局结构</h3><p><strong>数据库用户</strong></p><p>DBA、专业用户、应用程序员、最终用户。</p><p><strong>DBMS的查询处理器</strong></p><p>DML编译器、嵌入型DML的预编译器、DDL编译器、查询运行核心程序。</p><p><strong>DBMS的存储管理器</strong></p><p>授权和完整性管理器、事务管理器、文件管理器、缓冲区管理器。</p><p><strong>磁盘存储器中的数据结构</strong></p><p>数据文件、数据字典、索引文件、统计数据、日志</p><h3 id="2-5-3-DBS结构的分类"><a href="#2-5-3-DBS结构的分类" class="headerlink" title="2.5.3 DBS结构的分类"></a>2.5.3 DBS结构的分类</h3><p><strong>集中式DBS</strong></p><p><strong>客户&#x2F;服务器式DBS</strong></p><p><strong>并行式DBS</strong></p><p><strong>分布式DBS</strong></p><h3 id="2-5-4-DBS的效益"><a href="#2-5-4-DBS的效益" class="headerlink" title="2.5.4 DBS的效益"></a>2.5.4 DBS的效益</h3><p><strong>灵活性</strong></p><p><strong>简易性</strong></p><p><strong>面向用户</strong></p><p><strong>有效的数据控制</strong></p><p><strong>加快应用系统的开发速度</strong></p><p><strong>程序设计方便可维护性</strong></p><p><strong>标准化</strong></p><h2 id="第3章-关系运算"><a href="#第3章-关系运算" class="headerlink" title="第3章 关系运算"></a>第3章 关系运算</h2><h2 id="3-1-关系数据模型"><a href="#3-1-关系数据模型" class="headerlink" title="3.1 关系数据模型"></a>3.1 关系数据模型</h2><h3 id="3-1-1-关系数据模型的定义"><a href="#3-1-1-关系数据模型的定义" class="headerlink" title="3.1.1 关系数据模型的定义"></a>3.1.1 关系数据模型的定义</h3><p>关系操作是集合操作。 操作的对象是集合， 操作的结果也是集合。 因此， 关系操作的基础是集合代数。</p><p>可以用如下方式理解：</p><ol><li><p>表：关系</p></li><li><p>行：元组、记录</p></li><li><p>列：属性、字段</p></li></ol><p>域（Domain）：值的集合，即属性的取值范围</p><p>关系：</p><ol><li>用集合论的观点定义关系：关系是一个元数为 K 的元组的集合。即这个关系中有若干个元组，每个元组有 K 个属性值。 把关系看成一个集合，集合中的元素是元组。</li><li>用值域的观点定义关系：关系是属性值域笛卡儿积的一个子集。</li></ol><p>关系的性质：</p><ol><li>列具有相同的性质，不同的列可有相同的域</li><li>任意两个元组不能相同，元组的次序可交换</li><li>每个属性值（分量）都是不可分的数据项（即属性值为最小单位）</li></ol><h3 id="3-1-2-关键码和表之间的关系"><a href="#3-1-2-关键码和表之间的关系" class="headerlink" title="3.1.2 关键码和表之间的关系"></a>3.1.2 关键码和表之间的关系</h3><p>超键：在关系中能惟一标识元组的属性集称为关系模型的超键。</p><p>候选键：不含有多余属性的超键称为候选键。</p><p>主键：用户选作元组标识的一个候选键称为主键。</p><p>外键：该属性不是本关系的主键，正好是另外一个关系的主键，则该属性称为本关系的外键。  </p><h3 id="3-1-3-关系模式、关系子模式和存储模式"><a href="#3-1-3-关系模式、关系子模式和存储模式" class="headerlink" title="3.1.3 关系模式、关系子模式和存储模式"></a>3.1.3 关系模式、关系子模式和存储模式</h3><p>三级体系结构</p><p>关系模式实际上是记录类型（模式）</p><p>关系子模式是关系模式的逻辑子集（外模式）</p><p>存储模式是文件结构的描述（内模式）</p><h3 id="3-1-4-关系模式的完整性规则"><a href="#3-1-4-关系模式的完整性规则" class="headerlink" title="3.1.4 关系模式的完整性规则"></a>3.1.4 关系模式的完整性规则</h3><p>关系模型的三类完整性规则：</p><ol><li><p>实体完整性规则：实体主键属性值不能为空。</p></li><li><p>参照完整性规则：不引用不存在的实体。外键值或为空，或为参照关系中的某个主键值。</p></li><li><p>用户定义的完整性规则：由用户的应用环境决定。</p></li></ol><h3 id="3-1-5-关系模式的形式定义"><a href="#3-1-5-关系模式的形式定义" class="headerlink" title="3.1.5 关系模式的形式定义"></a>3.1.5 关系模式的形式定义</h3><p>关系模型有三部分组成：</p><ol><li>数据结构：关系。</li><li>数据操作：关系代数和关系演算。</li><li>完整性规则：三类。</li></ol><h2 id="3-2-关系代数"><a href="#3-2-关系代数" class="headerlink" title="3.2 关系代数"></a>3.2 关系代数</h2><h3 id="3-2-1-关系查询语言和关系运算"><a href="#3-2-1-关系查询语言和关系运算" class="headerlink" title="3.2.1 关系查询语言和关系运算"></a>3.2.1 关系查询语言和关系运算</h3><p>关系数据库语言由查询语句（描述用户的检索操作）和更新语句（描述用户的插入、修改和删除等操作）两大类组成。</p><p>关系代数是通过对关系的运算来表达查询的。 它的运算对象是关系，运算结果也是关系。</p><p>关系运算理论分为关系代数和关系演算两种。</p><p>关系查询语言分为：</p><ol><li>关系代数语言：以集合操作为基础；</li><li>关系演算语言：以谓词演算为基础； 元组关系演算语言和域关系演算语言；</li><li>基于关系代数和关系演算语言双重特点的语言：SQL</li></ol><h3 id="3-2-2-关系代数的五个基本操作"><a href="#3-2-2-关系代数的五个基本操作" class="headerlink" title="3.2.2 关系代数的五个基本操作"></a>3.2.2 关系代数的五个基本操作</h3><p>关系代数是由一组以关系作为运算对象的特定的运算符组成，常用的运算为九种：并、交、差、笛卡尔积、联接、自然联接、投影、选择、除运算等，其中五种为基本运算：并、差、笛卡尔积、投影、选择运算</p><p>设有两个关系 R 和 S 具有相同的关系模式。  </p><ol><li><p>并（∪）<br>R∪S≡{t∣t∈R∨t∈S},t 为元组变量，R 和S 结构相同。<br>其含义为：任取元组t, 当且仅当t 属于R 或t 属于S 时,t 属于R ∪ S 。 R ∪ S 是一个n 目关系。</p></li><li><p>差（ - ）<br>R-S≡{t∣t∈R∧t∉S},t 为元组变量，R 和S 结构相同。<br>其含义为：当且仅当t 属于R 并且不属于S 时,t 属于R-S 。 R-S 也是一个n目关系</p></li><li><p>笛卡尔积（ Χ ）<br>设关系 R 和关系 S 的元数分别为 r 和 s 。定义R 和 S 的笛卡儿积 R×S 是一个（ r+s ）元的元组集合，每个元组的前 r 个分量（属性值）来自 R 的一个元组，后 s 个分量是 S 的一个元组，记为 R×S 。<br>RΧS≡{t∣t&#x3D; 〈 $t^r$,$t^s$ 〉∧ $t^r$∈R∧$t^s$∈S}<br>设 R 为 n 目关系 ,S 为 m 目关系 , $t_r$ $t_s$ 表示由两个元组 $t_r$ 和 $t_s$ 前后有序连接而成的一个元组。<br>任取元组 $t_r$ 和 $t_s$, 当且仅当 $t_r$ 属于 R 且 $t_s$ 属于 S 时 , $t_r$ 和 $t_s$ 的有序连接即为 R×S 的一个元组</p></li><li><p>投影 (Π)<br>对一个关系进行垂直分割 , 消去某些列，并重新安排列的顺序 , 再删去重复元组。<br>$Π_{i1,…,im}(R)≡{t∣t&#x3D; 〈 t_i1,…,t_im 〉 ∧ 〈 t_1, …, t_k 〉∈ R}$<br>从 R 中逐次取出一个元组 , 首先 , 去掉不在 &lt; 属性名表 &gt; 上的诸属性值 , 接着 , 按 &lt; 属性名表 &gt; 的次序重新排列剩下各分量后 , 作为一个新元组送入投影结果（但若投影结果关系中已有此元组 , 则必须舍弃之）  </p></li><li><p>选择 (σ)<br>根据某些条件对关系做水平分割, 选择符合条件的元组。<br>$σ_F(R) ≡{t∣t∈R∧F(t)∈true}$,F 是由逻辑运算符和比较运算符连接运算对象构成的表达式。<br>选择运算是在一个关系中, 选取符合某给定条件的全体元组, 生成的新关系。</p></li></ol><h3 id="3-2-3-关系代数的组合操作"><a href="#3-2-3-关系代数的组合操作" class="headerlink" title="3.2.3 关系代数的组合操作"></a>3.2.3 关系代数的组合操作</h3><ol><li><p>交<br>设关系 R 和关系 S 具有相同的元数 n （即两个关系都有 n 个属性），而且相应的属性取自同一个域。关系 R 和 S 的交记为 R∩S ，结果仍为 n 元的关系。由即属于 R 又属于 S 的元组组成。形式定义如下：<br>R∩S≡{t ︱ t ∈ R ∧ t ∈ S}<br>t 是元组变量， R 和 S 的元数相同。<br>关系的交可以由关系的差来表示<br>R∩S≡R-(R-S) 或 R∩S≡S-(S-R)  </p></li><li><p>联接<br>联接操作是笛卡儿积、选择操作的组合。<br>其中 A 是 R 的属性， B 是 S 的属性。θ为比较运算符（&gt;, &lt;, &#x3D;, …)</p><img src="../images/数据库原理.assets/image-20211228213052865.png" alt="image-20211228213052865" style="zoom:33%;" /><p>如果 θ 为等号“ &#x3D;” ，那么这个联结操作称为等值连接。</p></li><li><p>自然联接<br>将关系 R 和 S 中公共属性组满足对应分量相等的元组联接起来， 并且要在结果中把重复的属性去掉。<br>$R⋈S≡Π_{去掉S中公共属性}(σ_{公共属性上值相等}( RΧS ))$</p></li><li><p>除<br>设关系 R 和 S 的元数分别为 :r 、 s （ r&gt;s&gt;0 ），<br>R÷S: 是一个（ r-s ）元的元组的集合，是满足下列条件的最大关系：<br>    其中每个元组 t 与 S 中每个元组 u 组成的<br>    新元组 &lt;t,u&gt; 必在关系 R 中。</p></li></ol><p>例题：</p><p>R：</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>d1</td></tr><tr><td>a1</td><td>b1</td><td>c3</td><td>d3</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c1</td><td>d1</td></tr><tr><td>a4</td><td>b4</td><td>c4</td><td>d4</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>d3</td></tr></tbody></table><p>S：</p><table><thead><tr><th>C</th><th>D</th></tr></thead><tbody><tr><td>c1</td><td>d1</td></tr><tr><td>c3</td><td>d3</td></tr></tbody></table><p>求R÷S</p><p>解法：</p><ol><li>找到R中，S中没有的几列，并对值的不同进行分组</li><li>如果得到的分组中，R、S共有的属性值对应相同，则为最终答案，否则，则舍弃</li></ol><p>则答案为</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>a1</td><td>b1</td></tr><tr><td>a3</td><td>b3</td></tr></tbody></table><h3 id="3-2-4-关系代数表达式及其应用实例"><a href="#3-2-4-关系代数表达式及其应用实例" class="headerlink" title="3.2.4 关系代数表达式及其应用实例"></a>3.2.4 关系代数表达式及其应用实例</h3><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220106134339964.png" alt="image-20220106134339964"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220106134354980.png" alt="image-20220106134354980"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220106134409455.png" alt="image-20220106134409455"></p><h3 id="3-2-5-扩充的关系代数操作"><a href="#3-2-5-扩充的关系代数操作" class="headerlink" title="3.2.5 扩充的关系代数操作"></a>3.2.5 扩充的关系代数操作</h3><h4 id="外联接-（左外联接、右外联接）"><a href="#外联接-（左外联接、右外联接）" class="headerlink" title="外联接  （左外联接、右外联接）"></a>外联接  （左外联接、右外联接）</h4><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220106132818145.png" alt="image-20220106132818145"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220106132920800.png" alt="image-20220106132920800"></p><p>举例：</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220106133002515.png" alt="image-20220106133002515"></p><h4 id="外部并"><a href="#外部并" class="headerlink" title="外部并"></a>外部并</h4><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220106133129390.png" alt="image-20220106133129390"></p><h4 id="半联接"><a href="#半联接" class="headerlink" title="半联接"></a>半联接</h4><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220106133207440.png" alt="image-20220106133207440"></p><p>举例：</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220106133314606.png" alt="image-20220106133314606"></p><h2 id="3-3-关系演算"><a href="#3-3-关系演算" class="headerlink" title="3.3 关系演算"></a>3.3 关系演算</h2><h3 id="3-3-1-元组关系演算"><a href="#3-3-1-元组关系演算" class="headerlink" title="3.3.1 元组关系演算"></a>3.3.1 元组关系演算</h3><p>元组表达形式{t∣P(t)}，t为元组变量，P(t)是由原子公式和运算符组成的。表示满足公式P的所有元组t的集合。</p><p>P(t)的最基本的形式称为原子公式。P(t)也可以是由原子公式和运算符组成的复合公式。</p><h4 id="三类原子公式"><a href="#三类原子公式" class="headerlink" title="三类原子公式"></a>三类原子公式</h4><ol><li><p>R(t)</p><p>R为关系名，意为t是R中的一个元组。{t|R(t)}意为，任取t，只要t是R中的一个元组，t就是结果中的一个元组。{t|R(t)}即表示关系R。</p></li><li><p>t[i] θ u[j]</p><p>t和u都是元组变量,θ是比较比较符。公式表示t的第i个分量和u的第j个分量满足比较关系θ，则t为结果关系中的元组。</p><p>如{t|R(t)∧t[5]&gt;t[3]}，意为：对于R中的任一元组，当且仅当其第5列属性值大于第3列属性值时，它就是结果关系的一员。</p></li><li><p>t[i] θ C或C θ t[i]，C为常数。</p><p>表示t的第i个分量与常数C之间满足θ比较符时，t为结果关系中的元组。 如{t|R(t)∧t[7]&#x3D;‘01’},意为：对R中的元组，当且仅当其第7列属性值为‘01’时，它就是结果关系中的一个元组。</p></li></ol><h4 id="公式的完整定义"><a href="#公式的完整定义" class="headerlink" title="公式的完整定义"></a>公式的完整定义</h4><p>在一个公式中，如果一个元组变量的前面没有存在量词$或全称量词”的符号定义，称之为自由元组变量，否则称为约束元组变量。</p><p>原子公式的完整定义如下：</p><ol><li>单个原子公式是公式。</li><li>若$P_1$和$P_2$是公式,则$P_1∧P_2$、$P_1∨P_2$、$\neg P1$也是公式。</li><li>若$\phi$是公式,则$\exist (t_i) \phi $也是公式。其中, i &#x3D; 1, 2, …, k。</li><li>若$\phi$是公式,则$\forall (t_i)\phi$也是公式。其中, i &#x3D; 1, 2, …, k。</li></ol><h4 id="关系代数到元组表达式的转换"><a href="#关系代数到元组表达式的转换" class="headerlink" title="关系代数到元组表达式的转换"></a>关系代数到元组表达式的转换</h4><p>并$R∪S&#x3D;{t∣R(t)∨S(t)}$</p><p>差$R-S&#x3D;{t∣R(t)∧\neg S(t)}$</p><p>笛卡尔积$RΧS&#x3D;{t∣(\exist u)(\exist v)(R(u) ∧S(v) ∧t[1]&#x3D;u[1] ∧…∧t[n]&#x3D;u[n] ∧t[n+1]&#x3D;v[1] ∧…∧t[n+m]&#x3D;v[m])}$</p><p>投影$\Pi_{i1,…,ik}(R)&#x3D;{t∣(\exist u)(R(u) ∧t[1]&#x3D;u[i1] ∧…∧t[k]&#x3D;u[ik])}$</p><p>选择$\sigma _F(R) &#x3D;{t∣R(t)∧F’}$</p><h3 id="3-3-2-域关系演算"><a href="#3-3-2-域关系演算" class="headerlink" title="3.3.2 域关系演算"></a>3.3.2 域关系演算</h3><h2 id="3-4-查询优化"><a href="#3-4-查询优化" class="headerlink" title="3.4 查询优化"></a>3.4 查询优化</h2><p>优化：是为了提高查询速度所进行的予处理。</p><p>优化方法：基于关系代数表达式的优化方法。</p><h3 id="3-4-1-关系代数表达式的优化问题"><a href="#3-4-1-关系代数表达式的优化问题" class="headerlink" title="3.4.1 关系代数表达式的优化问题"></a>3.4.1 关系代数表达式的优化问题</h3><p>查询学生姓名为CHEN的所选课程的成绩。</p><p>以下二种代数运算表达式是完全等价的。</p><p>T1: $Π_{cno,grade}σ_{s.sno&#x3D;sc.sno ∧ sname&#x3D;’chen’} (S×SC)$</p><p>T3:  $Π_{cno,grade}(σ_{sname&#x3D;’chen’}(S) ⋈ SC)$</p><p>对于T1：计算SΧSC，把S的每个元组和SC的全部连接起来。设S的物理文件需B1块存储器，SC的物理文件需B2块存储器，主存中提供的运算缓冲空间最多能装m块，而B1，B2均大于m。</p><p>执行方法：将S的文件分成若干个m-1块，将第一个m-1块装入内存，并逐步SC文件的一块，使之与S的已装入的m-1块进行乘积运算；当SC文件的每块都装入一遍后，再往内存装入S文件的下一个m-1块，重复执行，直至计算完乘积的全部元组为止。</p><p>其读块数目为：B1+（B1&#x2F;（ m-1））B2</p><p>设B1&#x3D;B2&#x3D;1500，m&#x3D;80，则所需读块总数目为30000，与读块时间相比，选择和投影等运算时间可忽略不计。如一秒种能读20块，完成T1运算需约25分钟。</p><p>对于T3：先对S文件作选择操作，读块数目为B1，再与SC连接、投影运算。其读块数目为B1+B2&#x3D;3000，完成T3运算需约2.5分钟。</p><p>总之,T1到T3,时间缩短了,而关系代数表达式的等价交换是这种优化的基础。</p><h3 id="3-4-2-关系代数表达式的等价变换规则"><a href="#3-4-2-关系代数表达式的等价变换规则" class="headerlink" title="3.4.2 关系代数表达式的等价变换规则"></a>3.4.2 关系代数表达式的等价变换规则</h3><p>如果两个关系代数表达式E1，E2中，相同的关系名用同一个关系取代后，其结果是相同的，则两个关系代数表达式E1，E2等价。</p><h4 id="1、2-联接和笛卡尔积的等价交换律、结合律"><a href="#1、2-联接和笛卡尔积的等价交换律、结合律" class="headerlink" title="1、2. 联接和笛卡尔积的等价交换律、结合律"></a>1、2. 联接和笛卡尔积的等价交换律、结合律</h4><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220106141156529.png" alt="image-20220106141156529"></p><h4 id="3-投影的串接等价规则"><a href="#3-投影的串接等价规则" class="headerlink" title="3. 投影的串接等价规则"></a>3. 投影的串接等价规则</h4><p>设E是一个关系代数表达式,A1,A2,…,An是属性名,并且Bi∈{A1,A2,…,An}（i&#x3D;1,2,…,n）,则</p><p>$∏_{B1,B2,…,Bm}(∏_{A1,A2,…,An}(E))≡∏_{B1,B2,…,Bm}(E)$</p><h4 id="4-选择的串接等价规则"><a href="#4-选择的串接等价规则" class="headerlink" title="4. 选择的串接等价规则"></a>4. 选择的串接等价规则</h4><p>设E是一个关系代数表达式,F1和F2是两个选择条件,则</p><p>$σ_{F1}(σ_{F2}(E))≡σ_{F1∧F2}(E)$</p><p>本规则说明,选择条件可合并成一次处理。</p><h4 id="5-选择和投影的交换等价规则"><a href="#5-选择和投影的交换等价规则" class="headerlink" title="5. 选择和投影的交换等价规则"></a>5. 选择和投影的交换等价规则</h4><p>设E为一个关系代数表达式,选择条件F只涉及属性A1,A2,…,An,</p><p>则$σ_F(∏_{A1,A2,…,An}(E))≡∏_{A1,A2,…,An}(σ_F(E))$</p><p>若上式中F还涉及不属于A1,A2,…,An的属性集B1,B2,…,Bm,则有</p><p>$∏_{A1,A2,…,An}（σ_F（E））≡∏_{A1,A2,…,An}（σ_F∏_{A1,A2,…,An,B1,B2,…,Bm}（E））$</p><h4 id="6-选择与笛卡尔积的交换等价规则"><a href="#6-选择与笛卡尔积的交换等价规则" class="headerlink" title="6. 选择与笛卡尔积的交换等价规则"></a>6. 选择与笛卡尔积的交换等价规则</h4><p>设E1和E2是两个关系代数表达式,若条件F只涉及E1的属性,则有</p><p>$σ_F（E1×E2）≡σ_F（E1）×E2$</p><p>若有F&#x3D;F1∧F2,并且F1只涉及E1中的属性,F2只涉及E2中的属性,则</p><p>$σ_F（E1×E2）≡σ_{F1}（E1）×σ_{F2}（E2）$</p><p>若F1只涉及E1中的属性,F2却涉及了E1和E2两者的属性,则有</p><p>$σ_F（E1×E2）≡σ_{F2}（σ_{F1}（E1）×E2）$</p><p>及早地执行选择操作是重要的操作规则。</p><h4 id="7-选择对并的分配律"><a href="#7-选择对并的分配律" class="headerlink" title="7. 选择对并的分配律"></a>7. 选择对并的分配律</h4><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220110121134533.png" alt="image-20220110121134533"></p><h4 id="8-选择对集合差的分配律"><a href="#8-选择对集合差的分配律" class="headerlink" title="8. 选择对集合差的分配律"></a>8. 选择对集合差的分配律</h4><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220110121203265.png" alt="image-20220110121203265"></p><h4 id="9-选择对自然联接的分配律"><a href="#9-选择对自然联接的分配律" class="headerlink" title="9. 选择对自然联接的分配律"></a>9. 选择对自然联接的分配律</h4><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220110121229298.png" alt="image-20220110121229298"></p><h4 id="10-投影对笛卡儿积的分配律"><a href="#10-投影对笛卡儿积的分配律" class="headerlink" title="10. 投影对笛卡儿积的分配律"></a>10. 投影对笛卡儿积的分配律</h4><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220110121254325.png" alt="image-20220110121254325"></p><h4 id="11-投影对并的分配律"><a href="#11-投影对并的分配律" class="headerlink" title="11. 投影对并的分配律"></a>11. 投影对并的分配律</h4><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220110121320153.png" alt="image-20220110121320153"></p><p>这里要求E1和E2的属性有对应性</p><h4 id="12-选择与联接操作的结合"><a href="#12-选择与联接操作的结合" class="headerlink" title="12. 选择与联接操作的结合"></a>12. 选择与联接操作的结合</h4><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220110121412194.png" alt="image-20220110121412194"></p><h4 id="13-并和交的交换律"><a href="#13-并和交的交换律" class="headerlink" title="13. 并和交的交换律"></a>13. 并和交的交换律</h4><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220110121428259.png" alt="image-20220110121428259"></p><h4 id="14-并和交的结合律"><a href="#14-并和交的结合律" class="headerlink" title="14. 并和交的结合律"></a>14. 并和交的结合律</h4><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220110121446513.png" alt="image-20220110121446513"></p><h3 id="3-4-3-优化的策略"><a href="#3-4-3-优化的策略" class="headerlink" title="3.4.3 优化的策略"></a>3.4.3 优化的策略</h3><p>任何策略都不能保证在所有情况下都能得到最好的方案。 但下面这些原则一般都是有效的。</p><p>(1) 尽可能早地执行选择操作。</p><p>(2) 在一些使用频率较高的属性上,建立索引或分类排序,这可大大提高存取效率。</p><p>(3) 同一关系的投影运算和选择运算同时进行。</p><p>(4) 把选择同选择前面的笛卡尔积结合起来成为一个连接运算。</p><p>(5) 把投影运算同其前后的双目运算结合起来进行,以免重复扫描文件。 </p><p>(6) 找出公共子表达式,并把运算结果存于外存。 需要时,再从外存读入。</p><h3 id="3-4-3-优化算法"><a href="#3-4-3-优化算法" class="headerlink" title="3.4.3 优化算法"></a>3.4.3 优化算法</h3><p>利用等价变换规则,使优化后的表达式能遵循一般原则。 这就是优化算法的工作。</p><p>算法： 关系代数表达式的优化。</p><p>输入：一个关系代数表达式的一棵语法树。</p><p>输出： 计算该表达式的一个优化程序。</p><p><strong>方法：</strong></p><ol><li>利用规则4，把形如$\sigma_{F1∧F2∧…∧Fn}(E)$的内容变换为$\sigma_{F1}(\sigma_{F2}(…\sigma_{Fn}(E)…))$</li><li>对于每一个选择,使用规则4至规则8，尽可能把它移到树的叶端（即尽可能使它早一点执行）。</li><li>对每一个投影，利用规则3、5、9、10，把它尽可能移向树的叶端。使用规则3可能会消去一些投影，使用规则5可能把一个投影分成两个，其中一个有可能被移向树的叶端。</li><li>利用规则3、4、5把选择和投影串接成单个选择、单个投影或一个选择后跟一个投影、使多个选择或投影能同时执行或在一次投影中同时完成。</li><li>将上述得到的语法树的内结点分组,每个二目运算（×、∪、-）结点与其直接祖先被分为一组（这些直接祖先由σ、 ∏表示）。 如果它的子结点一直到叶子都是单目运算（σ、 ∏）,则把它们并入该组。</li></ol><p>例题：</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220425210911183.png" alt="image-20220425210911183"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220425210926941.png" alt="image-20220425210926941"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220425210940611.png" alt="image-20220425210940611"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220425211000985.png" alt="image-20220425211000985"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220425211028453-16508922294751.png" alt="image-20220425211028453"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220425211106087.png" alt="image-20220425211106087"></p><h1 id="第4章-结构化查询语言SQL"><a href="#第4章-结构化查询语言SQL" class="headerlink" title="第4章 结构化查询语言SQL"></a>第4章 结构化查询语言SQL</h1><h2 id="4-1-SQL概述"><a href="#4-1-SQL概述" class="headerlink" title="4.1 SQL概述"></a>4.1 SQL概述</h2><h3 id="4-1-1-SQL发展历程"><a href="#4-1-1-SQL发展历程" class="headerlink" title="4.1.1 SQL发展历程"></a>4.1.1 SQL发展历程</h3><p>SQL(Structured Query Language)语言是1974年提出的在IBM公司的System R上实现。</p><p>是介于关系代数和关系演算之间的语言。</p><p>1986年ANSI批准SQL作为关系数据库语言的美国标准，同年，ISO也同样决定。</p><p>以后相继出现SQL89，SQL2（1992），SQL3（1999）。</p><h3 id="4-1-2-SQL数据库的体系结构"><a href="#4-1-2-SQL数据库的体系结构" class="headerlink" title="4.1.2 SQL数据库的体系结构"></a>4.1.2 SQL数据库的体系结构</h3><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20211202133258784.png" alt="image-20211202133258784"></p><p><strong>SQL</strong>支持数据库的三级模式结构，如上图所示。从图中可以看出，模式与基本表相对应，外模式与视图相对应，内模式对应于存储文件。基本表和视图都是关系。</p><ol><li><p><strong>基本表</strong>（Base Table）</p><p>基本表是模式的基本内容。每个基本表都是一个实际存在的关系。</p></li><li><p><strong>视图</strong>（View)</p><p>视图是外模式的基本单位，用户通过视图使用数据库中基于基本表的数据（基本表也可作为外模式使用）。</p><p>视图是虚表，实际并不存在，只有定义存放在数据字典中。</p></li><li><p><strong>存储文件</strong></p><p>存储文件是内模式的基本单位。每一个存储文件存储一个或多个基本表的内容。一个基本表可有若干索引，索引也存储在存储文件中。存储文件的存储结构对用户是透明的。</p></li></ol><h3 id="4-1-3-SQL的组成"><a href="#4-1-3-SQL的组成" class="headerlink" title="4.1.3 SQL的组成"></a>4.1.3 SQL的组成</h3><p>数据定义DDL：CREATE、DROP、ALTER</p><p>数据操纵DML：</p><p>​数据查询DQL：SELECT</p><p>​数据操纵DML：INSERT、DELETE、UPDATE</p><p>数据控制DCL：GRANT、REVOKE</p><p>嵌入式SQL</p><h2 id="4-2-SQL的数据定义（DDL）"><a href="#4-2-SQL的数据定义（DDL）" class="headerlink" title="4.2 SQL的数据定义（DDL）"></a>4.2 SQL的数据定义（DDL）</h2><p>模式，即<strong>数据库</strong></p><p><strong>注意，模板中的“&lt;&gt;”、“[]”为无用内容，即不需要输入</strong></p><h3 id="4-2-1-SQL模式的创建和撤销"><a href="#4-2-1-SQL模式的创建和撤销" class="headerlink" title="4.2.1 SQL模式的创建和撤销"></a>4.2.1 SQL模式的创建和撤销</h3><p>SQL模式的创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="keyword">AUTHORIZATION</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>SQL模式的撤消</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> SCHEMA　<span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> [CASCADE<span class="operator">|</span>RESTRICT]</span><br></pre></td></tr></table></figure><h3 id="4-2-2-SQL提供的基本数据类型"><a href="#4-2-2-SQL提供的基本数据类型" class="headerlink" title="4.2.2 SQL提供的基本数据类型"></a>4.2.2 SQL提供的基本数据类型</h3><p>各具体DBMS所提供的数据类型是不同的。但下面的数据类型几乎都是支持的：</p><p>INT或INTEGER    全字长二进制整数</p><p>SMALLINT       半字长二进制整数</p><p>DEC(p［,q］)或压缩十进制数，共p位，其中小数点后有q位</p><p>FLOAT              双字长的浮点数</p><p>CHAR(n)或CHARTER(n) 长度为n的定长字符串</p><p>VARCHAR(n)        最大长度为n的变长字符串</p><p>DATE       日期型，格式为YYYY―MM―DD</p><p>TIME        时间型，格式为HH.MM.SS</p><h3 id="4-2-3-基本表的创建、修改和撤销"><a href="#4-2-3-基本表的创建、修改和撤销" class="headerlink" title="4.2.3 基本表的创建、修改和撤销"></a>4.2.3 基本表的创建、修改和撤销</h3><h4 id="基本表的创建——CREATE-TABLE"><a href="#基本表的创建——CREATE-TABLE" class="headerlink" title="基本表的创建——CREATE TABLE"></a>基本表的创建——CREATE TABLE</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">(<span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>类型<span class="operator">&gt;</span> [<span class="operator">&lt;</span>该列的完整性约束<span class="operator">&gt;</span>]，</span><br><span class="line"> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">&lt;</span>类型<span class="operator">&gt;</span> [ <span class="operator">&lt;</span>该列的完整性约束<span class="operator">&gt;</span>]…</span><br><span class="line"><span class="keyword">primary</span> key (<span class="operator">&lt;</span>主键名<span class="operator">&gt;</span>)</span><br><span class="line"> <span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span></span><br><span class="line">) engine <span class="operator">=</span> InnoDB <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>&lt;该列的完整性约束&gt;：该列上数据必须符合的条件。最常见的有：</p><p>​NOT NULL       该列值不能为空</p><p>​NULL           该列值可以为空</p><p>​UNIQUE         该列值不能有相同者</p><p>​DEFAULT        该列上某值未定义时的默认值</p><p>&lt;表级完整性约束&gt;：对整个表的一些约束条件，常见的有定义主码(外码)，各列上数据必须符合的关联条件等。</p><h4 id="基本表结构的修改——ALTER-TABLE"><a href="#基本表结构的修改——ALTER-TABLE" class="headerlink" title="基本表结构的修改——ALTER TABLE"></a>基本表结构的修改——ALTER TABLE</h4><p>基本表的结构是可以随环境的变化而修改的，即根据需要增加、修改或删除其中一列(或完整性约束条件等)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="operator">-</span><span class="keyword">ADD</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [完整性约束]]</span><br><span class="line">[<span class="keyword">DROP</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span>]</span><br><span class="line">[MODIFY <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[完整性约束]]</span><br></pre></td></tr></table></figure><h4 id="基本表的撤消——DROP-TABLE"><a href="#基本表的撤消——DROP-TABLE" class="headerlink" title="基本表的撤消——DROP TABLE"></a>基本表的撤消——DROP TABLE</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [CASCADE<span class="operator">|</span>RESTRICT]</span><br></pre></td></tr></table></figure><p>此语句一执行，指定的表即从数据库中删除（表被删除，表在数据字典中的定义也被删除），此表上建立的索引和视图也被自动删除(有些系统对建立在此表上的视图的定义并不删除，但也无法使用了)。</p><h3 id="4-2-4-索引的创建和撤消"><a href="#4-2-4-索引的创建和撤消" class="headerlink" title="4.2.4 索引的创建和撤消"></a>4.2.4 索引的创建和撤消</h3><h4 id="索引的建立——CREATE-INDEX"><a href="#索引的建立——CREATE-INDEX" class="headerlink" title="索引的建立——CREATE INDEX"></a>索引的建立——CREATE INDEX</h4><p>在一个基本表上，可建立若干索引。有了索引，可以加快查询速度。索引的建立和删除工作由DBA或表的属主(建表人)负责。用户在查询时并不能选择索引，选择索引的工作由DBMS自动进行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>[<span class="keyword">UNIQUE</span>]INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> ( <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>])…</span><br><span class="line">本语句为规定<span class="operator">&lt;</span>表名<span class="operator">&gt;</span>建立一索引，索引名为<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>。</span><br></pre></td></tr></table></figure><h4 id="删除索引——DROP-INDEX"><a href="#删除索引——DROP-INDEX" class="headerlink" title="删除索引——DROP INDEX"></a>删除索引——DROP INDEX</h4><p>索引太多，索引的维护开销也将增大。因此，不必要的索引应及时删除。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span></span><br><span class="line">本语句将删除规定的索引。该索引在数据字典中的描述也将被删除。</span><br></pre></td></tr></table></figure><h2 id="4-3-SQL的数据查询"><a href="#4-3-SQL的数据查询" class="headerlink" title="4.3 SQL的数据查询"></a>4.3 SQL的数据查询</h2><p>SELECT语句</p><h3 id="4-3-1-SELECT语句格式"><a href="#4-3-1-SELECT语句格式" class="headerlink" title="4.3.1 SELECT语句格式"></a>4.3.1 SELECT语句格式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>　［<span class="keyword">DISTINCT</span>] <span class="operator">*</span><span class="operator">|</span><span class="operator">&lt;</span>目标列表达式[别名]清单<span class="operator">&gt;</span>  <span class="keyword">FROM</span> <span class="operator">&lt;</span>关系名[别名]或视图名清单<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>查询条件表达式<span class="operator">&gt;</span>] [<span class="keyword">GROUP</span> <span class="keyword">BY</span> 列名清单 [<span class="keyword">HAVING</span> <span class="operator">&lt;</span>组条件表达式<span class="operator">&gt;</span>]] [<span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名[<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...]</span><br></pre></td></tr></table></figure><p>整个语句的执行过程如下:<br>(1）读取FROM子句中基本表、视图的数据，执行笛卡儿积操作（或读取表引用所返回的查询结果或多表联接的结果)。<br>(2）选取满足WHERE子句中给出的条件表达式的元组。<br>(3）按GROUP子句中指定列的值分组，同时提取满足HAVING子句中组条件表达式的那些组。<br>(4)按SELECT子句中给出的列名或列表达式求值输出。<br>(5）ORDER子句对输出的目标表进行排序，按附加说明ASC升序排列，或按DESC降序排列。</p><p>SELECT语句中，WHERE子句称为“行条件子句”，GROUP子句称为“分组子句“，HAVING子句称为”组条件自居“，ORDER子句称为”排序子句“。</p><p>在 WHERE 子句的行条件表达式中可使用下列<strong>运算符</strong>：</p><ol><li>算术比较运算符：＜，＜＝，＞，＞＝，＝，＜＞或！＝；</li><li>逻辑运算符： AND ， OR ， NOT ；</li><li>集合成员资格运算符： IN ， NOT IN ；</li><li>谓词： EXISTS ， ALL ， SOME ， UNIQUE ；</li><li>聚合函数： AVG ， MIN ， MAX ， SUM ， COUNT ；</li><li>集合运算符： UNION ， INTERSECT ， EXCEPT 。</li></ol><h3 id="4-3-2-单表查询"><a href="#4-3-2-单表查询" class="headerlink" title="4.3.2 单表查询"></a>4.3.2 单表查询</h3><p><strong>别名</strong>：</p><ol><li><p>字段名称 AS 别名</p></li><li><p>字段名称 别名</p></li><li><p>别名 &#x3D;字段名称</p></li></ol><p><strong>确定范围</strong>：列名 [NOT] BETWEEN &lt;下限 &gt; AND &lt;上限&gt;</p><p><strong>查询空值</strong>：is NULL</p><p><strong>字符匹配</strong>：%表示任意多个字符，_ 表示任意一个字符，字符串外需要加单引号</p><p><strong>聚合函数</strong>：</p><ol><li>COUNT([DI STI NCT]*) 统计元组的个数</li><li>COUNT([DI STI NCT]&lt;列名 &gt;) 统计一列中值的个数</li><li>SUM([DI STI NCT]&lt;列名 &gt;) 计算一列值的总和</li><li>AVG([DI STI NCT]&lt;列名 &gt;) 计算一列值的平均值</li><li>MAX([DI STI NCT]&lt;列名 &gt;) 求一列值中的最大值</li><li>MIN([DI STI NCT]&lt;列名 &gt;) 求一列值中的最小值</li></ol><p><strong>排序</strong>时可指定原表的列或获得的表的列号进行排序</p><p>​order by 3 asc,2 desc</p><p>asc：升序，desc：降序</p><h3 id="4-3-3-多表查询"><a href="#4-3-3-多表查询" class="headerlink" title="4.3.3 多表查询"></a>4.3.3 多表查询</h3><h4 id="联结操作"><a href="#联结操作" class="headerlink" title="联结操作"></a>联结操作</h4><p>联接条件可在 WHERE 中指定也可以在 FROM 子句中指定。</p><p>在 FROM 子句中指定联接条件时， SQL2 将联接操作符分成 : 联接类型、联接条件。</p><p>联接类型：决定了如何处理联接条件中不匹配的元组。</p><p>联接条件：决定了两个关系中哪些元组应该匹配。</p><p>联接类型中的 OUTER 字样可不写  </p><table><thead><tr><th>联接类型</th><th>联接类型说明</th></tr></thead><tbody><tr><td>INNER JOIN</td><td>内联接： 结果为两个联接表中的匹配行的联接。</td></tr><tr><td>LEFT OUTER JOIN</td><td>左外联接： 结果包括“左”表（出现在 JOIN 子句的最左边）中的所有行。不包括右表中的 不匹配行。</td></tr><tr><td>RIGHT OUTER JOIN</td><td>右外联接： 结果包括“右”表（出现在 JOIN 子句的最右边）中的所有行。不包括左表中的 不匹配行。</td></tr><tr><td>FULL OUTER JOIN</td><td>完全外联接： 结果包括所有联接表中的所有行 不论它们是否匹配</td></tr><tr><td>CROSS JOIN</td><td>交叉联接： 结果包括两个联接表中所有可能的 行组合。交叉联接返回的是两个表的笛卡儿积</td></tr></tbody></table><h4 id="IN的嵌套查询"><a href="#IN的嵌套查询" class="headerlink" title="IN的嵌套查询"></a>IN的嵌套查询</h4><p>可带有谓词ANY和ALL</p><h4 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h4><h4 id="带有EXISTS的子查询"><a href="#带有EXISTS的子查询" class="headerlink" title="带有EXISTS的子查询"></a>带有EXISTS的子查询</h4><h2 id="4-4-SQL的数据更新"><a href="#4-4-SQL的数据更新" class="headerlink" title="4.4 SQL的数据更新"></a>4.4 SQL的数据更新</h2><h3 id="4-4-1-数据插入"><a href="#4-4-1-数据插入" class="headerlink" title="4.4.1 数据插入"></a>4.4.1 数据插入</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [（<span class="operator">&lt;</span>属性名清单<span class="operator">&gt;</span>）]</span><br><span class="line">    <span class="keyword">VALUES</span> （元组值）；</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> （<span class="operator">&lt;</span>属性名清单<span class="operator">&gt;</span>）</span><br><span class="line">    <span class="keyword">VALUES</span> （元组值）， （元组值），… ；</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [（<span class="operator">&lt;</span>属性名清单<span class="operator">&gt;</span>）]</span><br><span class="line">  （子查询）;</span><br></pre></td></tr></table></figure><p>把子查询的结果插入指定的&lt;表名&gt;中。这样的一条INSERT语句，可以一次插入多条元组。</p><h3 id="4-4-2-数据删除"><a href="#4-4-2-数据删除" class="headerlink" title="4.4.2 数据删除"></a>4.4.2 数据删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span>   <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"> ［<span class="keyword">WHERE</span> <span class="operator">&lt;</span>带有子查询的条件表达式<span class="operator">&gt;</span>］</span><br></pre></td></tr></table></figure><p>本语句将删除使&lt;带有子查询的条件表达式&gt;为真的所有元组。</p><h3 id="4-4-3-数据修改"><a href="#4-4-3-数据修改" class="headerlink" title="4.4.3 数据修改"></a>4.4.3 数据修改</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">SET</span><span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span></span><br><span class="line">    [, <span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span>……]</span><br><span class="line">    [<span class="keyword">WHERE</span> <span class="operator">&lt;</span>带有子查询的条件表达式<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><p>本语句执行时，将修改使&lt;带有子查询的条件表达式&gt;为真的所有元组。</p><h2 id="4-5-视图"><a href="#4-5-视图" class="headerlink" title="4.5 视图"></a>4.5 视图</h2><h3 id="4-5-1-视图的定义"><a href="#4-5-1-视图的定义" class="headerlink" title="4.5.1 视图的定义"></a>4.5.1 视图的定义</h3><p>一个视图是从一个或多个关系（基本表或已有的视图）导出的关系。</p><p>视图是虚表，导出后，数据库中只存有此视图的定义（在数据字典中），但并没有实际生成此关系。</p><p>视图一经定义就可以象基本表一样进行查询和更新。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span>[(<span class="operator">&lt;</span>列名清单<span class="operator">&gt;</span>)]</span><br><span class="line">         <span class="keyword">AS</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">      [(<span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION)]</span><br></pre></td></tr></table></figure><p>若有&lt;列名清单&gt;，则此清单给出了此视图的全部属性的属性名；否则，此视图的所有属性名即为子查询中SELECT语句中的全部目标列。</p><p>有［WITH CHECK OPTION］时，则今后对此视图进行INSERT、UPDATE和DELETE操作时，系统会自动检查视图是否符合原定义视图时子查询中的&lt;条件表达式&gt;。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>此语句将把指定视图的定义从数据字典中删除。</p><p>一个关系（基本表或视图）被删除后，所有由该关系导出的视图并不自动删除，它们仍在数据字典中，但已无法使用。</p><h3 id="4-5-2-视图的查询"><a href="#4-5-2-视图的查询" class="headerlink" title="4.5.2 视图的查询"></a>4.5.2 视图的查询</h3><p>DBMS对某SELECT语句进行处理时，若发现被查询对象是视图，则DBMS将进行下述操作：</p><ol><li>从数据字典中取出视图的定义。</li><li>把视图定义的子查询和本SELECT的查询相结合，生成等价的对基本表的查询（此过程称为视图的消解）。</li><li>执行对基本表的查询，把查询结果（作为本次对视图的查询结果）向用户显示。</li></ol><h3 id="4-5-3-视图的更新"><a href="#4-5-3-视图的更新" class="headerlink" title="4.5.3 视图的更新"></a>4.5.3 视图的更新</h3><p>视图是虚表，是没有数据的。所谓视图的更新，表面上是对视图执行INSERT、 UPDATE和DELETE来更新视图的数据，其实质是由DBMS自动转化成对导出视图的基本表的更新，转化成对基本表的INSERT、UPDATE和DELETE语句（用户在感觉上确实是在对视图更新）。</p><p>不是所有的视图都是可更新的，因为有些视图的更新不能有意义的转化成相应基本表的更新。</p><p>一般的DBMS只允许对单个基本表导出的视图进行更新。并有下列限制：</p><ol><li>若视图的列由表达式或常数组成，则不允许执行INSERT和UPDATE，但可执行DELETE。</li><li>若视图的列由集函数组成，则不允许更新。</li><li>若视图定义中有GROUPBY子句，则不允许更新。</li><li>若视图定义中有DISTINCT选项，则不允许更新。</li><li>若视图定义中有嵌套查询，且内外层FROM子句中的表是同一个表，则不允许更新。</li><li>从不允许更新的视图导出的视图是不允许更新的。</li></ol><h3 id="4-5-4-视图的优点"><a href="#4-5-4-视图的优点" class="headerlink" title="4.5.4 视图的优点"></a>4.5.4 视图的优点</h3><ol><li>视图能方便用户操作</li><li>视图可对数据提供安全保护</li><li>视图能使不同用户都能用自己喜欢的方式看待同一数据同一数据，在不同用户的各个视图中，可以以不同的名称出现，可以以不同的角色出现（平均值，最大值……）。这给数据共享带来了很大的方便。</li></ol><h2 id="4-6-嵌入式SQL"><a href="#4-6-嵌入式SQL" class="headerlink" title="4.6 嵌入式SQL"></a>4.6 嵌入式SQL</h2><h3 id="4-6-1-SQL语言的运行环境"><a href="#4-6-1-SQL语言的运行环境" class="headerlink" title="4.6.1 SQL语言的运行环境"></a>4.6.1 SQL语言的运行环境</h3><p>常用的方式是用某种传统的编程语言（例如：C、PASCAL等）编写程序，但程序中的某些函数或某些语句是SQL语句。这种方式下使用的SQL语言称为嵌入式SQL（EmbeddedSQL），其中传统的编程语言称为宿主语言（或主语言）。</p><p>DBMS有两种方法处理嵌入式SQL语言：预编译和扩充编译程序法。预编译是指由DBMS的预编译器对源程序进行扫描，识别出其中的SQL语句，把它们转换为宿主语言调用语句，使宿主语言编译器能够识别，最后由编译器将整个源程序编译为目标码。目前使用较多的是预编译方法，其处理过程如下图所示。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20211223142019261.png" alt="image-20211223142019261"></p><h3 id="4-6-2-嵌入式SQL的使用规定"><a href="#4-6-2-嵌入式SQL的使用规定" class="headerlink" title="4.6.2 嵌入式SQL的使用规定"></a>4.6.2 嵌入式SQL的使用规定</h3><p>使用嵌入式SQL必须解决以下几个问题：</p><ol><li>预编译器不能识别和接受SQL语句，因此，嵌入式程序中，应有区分SQL语句与宿主语言语句的标记。</li><li>DBMS和宿主语言程序（程序工作单元）如何进行信息传递。</li><li>一条SQL语句原则上可产生或处理一组记录，而宿主语言一次只能处理一个记录，必须协调这两种处理方式。</li></ol><p>使用规定：</p><ol><li>对嵌入的SQL语句加前缀EXEC SQL，而结束标志则随宿主语言的不同而不同。在C语言中嵌入的SQL语句以EXECSQL开始，以分号“；”结尾：EXEC SQL＜SQL语句＞</li><li>在DBMS和宿主语言程序之间的数据传递，是通过宿主语言程序变量，简称主变量（Host variable）来实现的。当SQL语句引用主变量时，变量前应加冒号“：”。</li><li>SQL语言和宿主语言的不同数据处理方式，是通过游标（Cursor）来协调的。游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果。每个游标都有一个名字。</li></ol><p>游标：</p><p>​用户可以用SQL语句逐一从游标中获取记录，并赋给主变量，由宿主语言作进一步的处理。游标的操作包括四个步骤：</p><ol><li>定义游标 ：EXEC SQL DECLARE 游标名 CURSOR FOR＜SELECT语句＞</li><li>打开游标：EXEC SQL OPEN ＜游标名＞</li><li>推进游标：EXEC SQL FETCH＜游标名＞INTO ＜主变量名列表＞</li><li>关闭游标：EXEC SQL CLOSE＜游标名＞</li></ol><h3 id="4-6-3-嵌入式SQL的使用技术"><a href="#4-6-3-嵌入式SQL的使用技术" class="headerlink" title="4.6.3 嵌入式SQL的使用技术"></a>4.6.3 嵌入式SQL的使用技术</h3><h4 id="不涉及游标的嵌入式SQL、DML语句"><a href="#不涉及游标的嵌入式SQL、DML语句" class="headerlink" title="不涉及游标的嵌入式SQL、DML语句"></a>不涉及游标的嵌入式SQL、DML语句</h4><p>在嵌入式SQL中，SQL的数据定义DDL与控制语句DCL都不需要使用游标。</p><h3 id="4-6-4-动态SQL语句"><a href="#4-6-4-动态SQL语句" class="headerlink" title="4.6.4 动态SQL语句"></a>4.6.4 动态SQL语句</h3><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20211228173906602.png" alt="image-20211228173906602"></p><h2 id="4-7-语法整理"><a href="#4-7-语法整理" class="headerlink" title="4.7 语法整理"></a>4.7 语法整理</h2><p>创建新的数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database <span class="operator">&lt;</span>库名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>创建数据表：（详见4.2.3）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>（</span><br><span class="line"><span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [<span class="operator">&lt;</span>约束条件<span class="operator">&gt;</span>],</span><br><span class="line">...</span><br><span class="line"><span class="keyword">primary</span> key (<span class="operator">&lt;</span>主键名<span class="operator">&gt;</span>)</span><br><span class="line">) engine <span class="operator">=</span> InnoDB <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>从txt文件中导入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data infile <span class="string">&#x27;&lt;文件地址，上下级目录用\隔开&gt;&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span>  <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>增加外键约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY (<span class="operator">&lt;</span>键名<span class="operator">&gt;</span>) <span class="keyword">REFERENCES</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>(<span class="operator">&lt;</span>键名<span class="operator">&gt;</span>);</span><br></pre></td></tr></table></figure><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>–主键约束(Primary Key constraint):要求主键列的数据唯一，并且不允许为空。</p><p>–唯一约束(Unique Constraint)：要求该列唯一，允许为空，但只能出现一个空值。</p><p>–检查约束(Check Constraint):某列取值范围限制、格式限制等，如有关年龄的约束。</p><p>–默认约束(Default Constraint):某列的默认值，如我们的男性同学较多，性别默认为男。</p><p>–外键约束(Foreign Key):用于在两表之间建立关系需要制定引用主表的哪一列。</p><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span> <span class="operator">&lt;</span>约束类型具体的约束说明<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p> 示例：</p><p>–添加主键约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span> <span class="keyword">primary</span> key(<span class="operator">&lt;</span>主键名<span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure><p>–添加唯一键约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span> <span class="keyword">unique</span>(<span class="operator">&lt;</span>键名<span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure><p>–添加默认约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span> <span class="keyword">default</span>(<span class="operator">&lt;</span>默认值<span class="operator">&gt;</span>) <span class="keyword">for</span> <span class="operator">&lt;</span>键名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>–添加检查约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span> <span class="keyword">check</span>(<span class="operator">&lt;</span>检查内容<span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure><p>–添加外键约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span> <span class="keyword">foreign</span> key(<span class="operator">&lt;</span>外键名<span class="operator">&gt;</span>) <span class="keyword">references</span> <span class="operator">&lt;</span>外键表<span class="operator">&gt;</span>(<span class="operator">&lt;</span>键名<span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure><p> 删除约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">drop</span> <span class="keyword">constraint</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h3 id="级联删除"><a href="#级联删除" class="headerlink" title="级联删除"></a>级联删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> cascade <span class="keyword">on</span> <span class="keyword">update</span> cascade</span><br></pre></td></tr></table></figure><p>在创建表时添加：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> (</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>外键名<span class="operator">&gt;</span> <span class="keyword">FOREIGN</span> KEY (<span class="operator">&lt;</span>键名<span class="operator">&gt;</span>) <span class="keyword">REFERENCES</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> (<span class="operator">&lt;</span>外键名<span class="operator">&gt;</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE,</span><br><span class="line">  ...</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加外键时增加：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>外键名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (<span class="operator">&lt;</span>键名<span class="operator">&gt;</span>)</span><br><span class="line"><span class="keyword">REFERENCES</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>(<span class="operator">&lt;</span>外键名<span class="operator">&gt;</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE;</span><br></pre></td></tr></table></figure><h1 id="第6章-实体联系模型"><a href="#第6章-实体联系模型" class="headerlink" title="第6章 实体联系模型"></a>第6章 实体联系模型</h1><h2 id="6-1-ER模型的基本元素"><a href="#6-1-ER模型的基本元素" class="headerlink" title="6.1 ER模型的基本元素"></a>6.1 ER模型的基本元素</h2><h3 id="1-实体"><a href="#1-实体" class="headerlink" title="1. 实体"></a>1. 实体</h3><p>实体是客观存在、可以相互区分的事物。</p><p>实体集是具有相同类型及相同性质（属性）的实体集合。</p><h3 id="2-联系"><a href="#2-联系" class="headerlink" title="2. 联系"></a>2. 联系</h3><p>联系集是指同类联系的集合。</p><p>在E―R模型中,用矩形框表示实体集,矩形框中写上实体名,用椭圆表示属性,椭圆中标上属性名,实体的主码用下划线表示。</p><h3 id="3-属性"><a href="#3-属性" class="headerlink" title="3. 属性"></a>3. 属性</h3><p>事物是有特性的。反映在实体上，就是实体的属性。一个实体具有有限个属性，也可以说是这些属性的总和组成了这个实体。</p><h2 id="6-2-属性的分类"><a href="#6-2-属性的分类" class="headerlink" title="6.2 属性的分类"></a>6.2 属性的分类</h2><h3 id="1-基本属性和复合属性"><a href="#1-基本属性和复合属性" class="headerlink" title="1. 基本属性和复合属性"></a>1. 基本属性和复合属性</h3><p>基本属性：不可再分割的属性。例如：性别、年龄等。</p><p>复合属性：可再分解为其他属性的属性。例如：邮政编码等。</p><h3 id="2-单值属性和多值属性"><a href="#2-单值属性和多值属性" class="headerlink" title="2. 单值属性和多值属性"></a>2. 单值属性和多值属性</h3><p>基本属性：不可再分割的属性。例如：性别、年龄等。</p><p>复合属性：可再分解为其他属性的属性。例如：邮政编码等。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220217131322325.png" alt="image-20220217131322325"></p><h3 id="3-导出属性"><a href="#3-导出属性" class="headerlink" title="3. 导出属性"></a>3. 导出属性</h3><p>导出属性：通过具有相互依赖的属性推导而产生的属性。例如，人的出生年份可以从年龄推导出来。</p><h3 id="4-空值"><a href="#4-空值" class="headerlink" title="4. 空值"></a>4. 空值</h3><p>导出属性：通过具有相互依赖的属性推导而产生的属性。例如，人的出生年份可以从年龄推导出来。</p><h2 id="6-3-联系的设计"><a href="#6-3-联系的设计" class="headerlink" title="6.3 联系的设计"></a>6.3 联系的设计</h2><h3 id="1-联系的元数"><a href="#1-联系的元数" class="headerlink" title="1. 联系的元数"></a>1. 联系的元数</h3><p>一个联系涉及到的实体集的个数，称为联系的元数或度数。</p><p>实体间的联系有三种：</p><p>同一实体集中各实体之间的联系(一元联系)。</p><p>两个实体集中各实体之间的联系(两元联系)。</p><p>三个实体集中各实体之间的联系(三元联系)。</p><h3 id="2-联系的连通词"><a href="#2-联系的连通词" class="headerlink" title="2. 联系的连通词"></a>2. 联系的连通词</h3><p>联系涉及到的实体集之间实体对应的方式，称为联系的连通词。</p><p>实体间连通词有三种情况：</p><p>一对一 （1：1）</p><p>一对多 （1：N）</p><p>多对多 （M：N）</p><h3 id="3-联系的基数"><a href="#3-联系的基数" class="headerlink" title="3. 联系的基数"></a>3. 联系的基数</h3><p>有两个实体集E1和E2，E1中每个实体与E2中有联系实体数目的最小值Min和最大值Max，称为E1的基数，用（Min，Max）表示。</p><h2 id="6-4-ER模型的扩充"><a href="#6-4-ER模型的扩充" class="headerlink" title="6.4 ER模型的扩充"></a>6.4 ER模型的扩充</h2><h3 id="1-依赖联系和弱实体"><a href="#1-依赖联系和弱实体" class="headerlink" title="1. 依赖联系和弱实体"></a>1. 依赖联系和弱实体</h3><p>一个实体的存在必须以另外实体的存在为前提。例如：职工和家属。</p><p>一个实体对于另一些实体具有很强的依赖联系，而且该实体主键的部分或全部从其父实体中获得，称该实体为弱实体。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220217132445444.png" alt="image-20220217132445444"></p><h3 id="2-子类和超类"><a href="#2-子类和超类" class="headerlink" title="2. 子类和超类"></a>2. 子类和超类</h3><p>当较低层上的实体类型表达了与之联系的较高层上的实体类型的特殊情况时，就称较高层上的实体类型为超类型，较低层上的实体类型为子类型。</p><p>性质：</p><ol><li><p>子类实体继承超类实体的所有属性。</p></li><li><p>继承性是通过子类和超类相同的实体标识符实现<img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220217133256557.png" alt="image-20220217133256557"></p></li></ol><h2 id="6-5-ER模型的实例"><a href="#6-5-ER模型的实例" class="headerlink" title="6.5 ER模型的实例"></a>6.5 ER模型的实例</h2><h3 id="1-E—R模型实例"><a href="#1-E—R模型实例" class="headerlink" title="1. E—R模型实例"></a>1. E—R模型实例</h3><p>例1 企业职工管理中，需要涉及的功能有：</p><p>① 人事处对职工的档案和部门进行管理,包括职工基本情况，部门的基本情况以及各种职称、 职务的管理；</p><p>② 财务处管理职工的工资情况；</p><p>③ 科研处管理项目、 职工参加项目的情况。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220217134127536.png" alt="image-20220217134127536"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220217134146050.png" alt="image-20220217134146050"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220217134211297.png" alt="image-20220217134211297"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220217134222365.png" alt="image-20220217134222365"></p><h3 id="2-E—R模型向关系模型的转化"><a href="#2-E—R模型向关系模型的转化" class="headerlink" title="2. E—R模型向关系模型的转化"></a>2. E—R模型向关系模型的转化</h3><p>(1) 将每一个实体集转换为一个关系模式，实体集的属性转换成关系的属性,实体集的码即对应关系的码。</p><p>本例中将生成如下三个关系模式：</p><ol><li>职工（职工号,姓名,性别,年龄,工资）</li><li>部门（部门号,名称,电话,负责人）</li><li>职称职务（代号,名称,津贴,住房面积）</li></ol><p>(2) 将每个联系集转换成关系模式。 对于给定的联系R,由它所转换的关系具有以下属性：</p><p>① 联系R单独的属性都转换为该关系的属性；</p><p>② 联系R涉及到的每个实体集的码属性（集）转换为该关系的属性。 转换后关系的码有以下几种情况：</p><ol><li>若联系R为1∶1联系,则每个相关实体的码均可作为关系的候选码；</li><li>若联系R为1∶n联系,则关系1中的码作为n端实体的外码；</li><li>若联系R为m∶n联系,则关系的码为相关实体码的组合。</li></ol><h1 id="第5章-规范化设计"><a href="#第5章-规范化设计" class="headerlink" title="第5章 规范化设计"></a>第5章 规范化设计</h1><h2 id="5-1-关系模式的设计问题"><a href="#5-1-关系模式的设计问题" class="headerlink" title="5.1 关系模式的设计问题"></a>5.1 关系模式的设计问题</h2><h3 id="5-1-1-关系模式的外延和内涵"><a href="#5-1-1-关系模式的外延和内涵" class="headerlink" title="5.1.1 关系模式的外延和内涵"></a>5.1.1 关系模式的外延和内涵</h3><p>一个关系模型包括外延和内涵两个方面的内容</p><p>外延就是关系、表或当前值，就是表里的数据</p><p>内涵就是对数据的定义以及对数据完整性约束的定义</p><h3 id="5-1-2-泛关系模式与数据库模式"><a href="#5-1-2-泛关系模式与数据库模式" class="headerlink" title="5.1.2 泛关系模式与数据库模式"></a>5.1.2 泛关系模式与数据库模式</h3><p>关系模式R(U)，R表示关系模式，U表示属性的全集，关系r是关系模式R(U)的当前值，是元组的集合。这样的关系模式和关系称为泛关系模式和泛关系。</p><p>实际使用时，用一个关系模式的集合$\rho &#x3D;{R_1，……，R_K}$来代替R(U)，其中每个$R_i$是U的子集，$\rho$称为数据库模式。</p><h3 id="5-1-3-关系模式的冗余和异常问题"><a href="#5-1-3-关系模式的冗余和异常问题" class="headerlink" title="5.1.3 关系模式的冗余和异常问题"></a>5.1.3 关系模式的冗余和异常问题</h3><ol><li>数据冗余度大</li><li>插入、修改与删除异常</li></ol><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220308151807031.png" alt="image-20220308151807031"></p><p>解决方法：分解</p><h2 id="5-2-函数依赖"><a href="#5-2-函数依赖" class="headerlink" title="5.2 函数依赖"></a>5.2 函数依赖</h2><h3 id="5-2-1-函数依赖FD的定义"><a href="#5-2-1-函数依赖FD的定义" class="headerlink" title="5.2.1 函数依赖FD的定义"></a>5.2.1 函数依赖FD的定义</h3><p>定义5.1 设有关系模式$R(A_1, A_2, …, A_n)$，X，Y是U的子集，r是R的任一具体关系 ，如果对r的任意两个元组u、v，由u[X] &#x3D; v[X]导致u[Y] &#x3D; v[Y]，则称X函数决定Y，记为X→Y。</p><p>在关系R中，X、Y为R的两个属性或属性组,如果对于R的所有关系r都存在： 对于X的每一个具体值,Y都只有一个具体值与之对应,则称属性Y函数依赖于属性X。</p><p>或者说,属性X函数决定属性Y,记作$X\to Y$。 其中X叫决定因素,Y叫被决定因素。</p><p>此定义可简单表述为：如果属性X的值决定属性Y的值,那么属性Y函数依赖于属性X。 换一种说法是,如果知道X的值,就可以获得Y的值。</p><p>(1) 若Y函数不依赖于X,记作$X\nrightarrow Y$。</p><p>(2) 若$X\to Y$, $Y\to X$,记作$X\leftrightarrow Y$。</p><h3 id="5-2-2-函数依赖的定义"><a href="#5-2-2-函数依赖的定义" class="headerlink" title="5.2.2 函数依赖的定义"></a>5.2.2 函数依赖的定义</h3><p>定义5.2 设F是在关系模式R(U)上成立的函数依赖集，X和Y是属性集U上的子集，如果从F推导出X→Y也在R(U)上成立，那么称F逻辑蕴涵X→Y，记为F ⊨ X→Y。</p><p>定义5.3设F是关系模式$R(A_1, A_2,…, A_n)$上成立的函数依赖集，X和Y是属性集$(A_1, A_2, …, A_n)$的子集，F的所有逻辑蕴涵组成的集合称为函数依赖集F的闭包,记为$F^+$。</p><p>​$F^+&#x3D;{ X\to Y | F\models X\to Y}$</p><p>即：从给定的函数依赖集合F推出的所有函数依赖组成的集合，称为F的闭包。</p><h3 id="5-2-3-函数依赖的推理规则"><a href="#5-2-3-函数依赖的推理规则" class="headerlink" title="5.2.3 函数依赖的推理规则"></a>5.2.3 函数依赖的推理规则</h3><p>Armstrong公理系统：设有关系模式R（A1，A2，…，An）和属性集$U&#x3D; A_1A_2…A_n$，X，Y，Z，W是U的一个子集，F是R的一个函数依赖集，推理规则如下：</p><p>自反律：如果$Y\subseteq X\subseteq U$，则X→Y在R上成立。</p><p>增广律：如果X→Y为F所蕴涵，$Z\subseteq U$，则XZ→YZ在R上成立。</p><p>传递律：如果X→Y和Y→Z在R上成立，则X→Z在R上成立。</p><p>FD的其它三个推理规则：</p><p>合并律：如果X→Y和X→Z成立，则X→YZ也成立。</p><p>伪传递律：如果X→Y和WY→Z成立，则WX→Z也成立。</p><p>分解律：如果X→Y和$Z\subseteq Y$，则X→Z成立。</p><p>定义5.4 对于FD X→Y 如果$Y\subseteq X$，那么称X→Y是一个平凡的FD；否则称为一个非平凡的FD</p><h3 id="5-2-4-FD与关键码的联系"><a href="#5-2-4-FD与关键码的联系" class="headerlink" title="5.2.4 FD与关键码的联系"></a>5.2.4 FD与关键码的联系</h3><p>定义5.5 设有关系模式$R(A_1, A_2, …, A_n)$，F是R的一个函数依赖集，X是${ A_1, A_2, …, A_n }$的一个子集。如果</p><p>①$X\rightarrow A_1A_2…A_n∈F^+$，且</p><p>②不存在X真子集Y，使得$Y\rightarrow A_1A_2…A_n$ 成立，则称X是R的候选键。</p><p>包含在任何一个候选键中的属性称为主属性</p><p>不包含在任何一个候选键中的属性称为非主属性。</p><h4 id="补充：候选码的求解算法（自学）"><a href="#补充：候选码的求解算法（自学）" class="headerlink" title="补充：候选码的求解算法（自学）"></a>补充：候选码的求解算法（自学）</h4><p>设关系模式R&lt;U, F&gt;</p><p>(1) 将R的所有属性分为 L、 R、N和 LR四类，并令X代表L、N两类，Y代表LR类。</p><p>  L类: 仅出现在F的函数依赖左部的属性；</p><p>  R类: …………………………右…………；</p><p>  N类: 在F的函数依赖左右两边都不出现的属性；</p><p>  LR类: …………………………都出现的属性 。 </p><p>(2) 求属性集闭包X+，若 X+包含了R的全部属性则X即为R的唯一候选码, 转(5);</p><p>(3) 否则, 在Y中取一属性A，求属性集闭包(XA)+，若(XA)+包含了R的全部属性，则转(4)；否则，调换一属性反复进行这一过程，直到试完所有Y中的属性。</p><p> (4) 如果已找出了所有的候选码，则转(5)；否则在Y中依次取2个、3个、…属性，求X与它们的属性集闭包，直到其闭包包含R的全部属性。</p><p> (5) 停止，输出结果。</p><p>例如：已知R(ABCDE)，F&#x3D;{A→B，BC→A，A→D}，求R的全部非主属性。</p><p>现将所有属性分类</p><p>L：C</p><p>R：D</p><p>N：E</p><p>LR：A、B</p><p>则X代表L、N两类  Y代表LR类</p><p>则首先X为CE，(CE)+&#x3D;{C,E}依次将X设为(ACE)和(BCE)得到(ACE)+&#x3D;{A,B,C,D,E}</p><p>  (BCE)+&#x3D;{A,B,C,D,E}</p><p>由上得，非主属性为D</p><h3 id="5-2-5-属性集的闭包"><a href="#5-2-5-属性集的闭包" class="headerlink" title="5.2.5 属性集的闭包"></a>5.2.5 属性集的闭包</h3><p>定义5.6 设关系模式R(U,F), U为R的属性集合,F为其函数依赖集,则称所有用Armstrong公理从F推出的函数依赖$X\to A_i$中$A_i$的属性集合,为X的属性闭包,记作$X^+$,读作X关于函数依赖集F的闭包。</p><p>定理 5.3 设关系模式R(U,F) ,U为R的属性集合,F为其函数依赖集,$X, Y \subseteq U$,则从F推出X→Y的充要条件是$Y\subseteq X^+$。</p><p>算法 5.1 求属性集X关于函数依赖F的属性闭包$X^+$。</p><p>输入：关系模式R的全部属性集U,U的子集X,U上的函数依赖集F。</p><p>输出：X关于F的属性闭包$X^+$。</p><p>步骤： 设i&#x3D;0,1,2,…。</p><p>(1) 初始化： i&#x3D;0, X(0) &#x3D; X。</p><p>(2) X(i+1) &#x3D; X(i)∪A</p><p>求属性集A。A是这样的属性： 在F中寻找尚未用过的左边是X(i)子集的函数依赖：Y(j)→Z(j) (j&#x3D;1,…,k),其中$Y(j)\subseteq X(i)$,并且在Z中寻找X(i)中未出现过的属性集合A，若无这样的A，则转(4)</p><p>(3) 判断是否有X(i+1) &#x3D; X(i)，若是则转(4)，否则转(2)。</p><p>(4) 输出X(i),即为$X^+$。</p><h3 id="5-2-6-FD的最小依赖集"><a href="#5-2-6-FD的最小依赖集" class="headerlink" title="5.2.6 FD的最小依赖集"></a>5.2.6 FD的最小依赖集</h3><p>定义 设F和G是关系模式R（U）上的两个函数依赖集,如果$F^+&#x3D;G^+$，则称F和G是等价的,记作F≡G。 也可称为F覆盖G,或G覆盖F,或F、G相互覆盖。</p><p>引理 F≡G的充分必要条件是$F\subseteq G^+$、$G\subseteq F^+$。</p><p>引理 任一函数依赖集总可以为一右边都为单属性的函数依赖集所覆盖。</p><p>定义 5.7 如果函数依赖集F满足下列条件,则称F为一个极小函数依赖集,也称为最小依赖集或最小覆盖。</p><p>(1) F中任一函数依赖的右部都是单属性。</p><p>(2) F中任一函数依赖X→A,都不会使F与F-{X→A}等价。</p><p>(3) F中任一函数依赖X→A,X的任一真子集Z,不会使F-{X→A}∪{Z→A}与F等价。</p><p>条件(2)保证了F中不存在多余的函数依赖</p><p>条件(3)保证了F中每个函数依赖的左边没有多余的属性。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220601232750096.png" alt="image-20220601232750096"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220601232757640.png" alt="image-20220601232757640"></p><h2 id="5-3-关系模式的分解特性"><a href="#5-3-关系模式的分解特性" class="headerlink" title="5.3 关系模式的分解特性"></a>5.3 关系模式的分解特性</h2><h3 id="5-3-1-模式分解问题"><a href="#5-3-1-模式分解问题" class="headerlink" title="5.3.1 模式分解问题"></a>5.3.1 模式分解问题</h3><p>定义5.8 关系模式R(U, F)的一个分解是指$\rho&#x3D;{R_1(U_1,F_1),R_2(U_2,F_2),…,R_n(U_n,F_n)} $</p><p>其中$U&#x3D;\bigcup^n_{i&#x3D;1}u_i$</p><p>并且没有$u_i\subseteq u_j$，$1\leq i$，$j\leq n$，$F_i$是$F$在$u_i$上的投影。</p><p>定义 函数依赖集合${ X→Y|X→Y∈F^+且XY\subseteq u_i}$的一个覆盖$F_i$叫做$F$在属性$u_i$上的投影。</p><h3 id="5-3-2-无损分解"><a href="#5-3-2-无损分解" class="headerlink" title="5.3.2 无损分解"></a>5.3.2 无损分解</h3><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220327205110041.png" alt="image-20220327205110041"></p><h3 id="5-3-3-无损分解的测试方法"><a href="#5-3-3-无损分解的测试方法" class="headerlink" title="5.3.3 无损分解的测试方法"></a>5.3.3 无损分解的测试方法</h3><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220327205146703.png" alt="image-20220327205146703"></p><h3 id="5-3-4-保持函数依赖的分解"><a href="#5-3-4-保持函数依赖的分解" class="headerlink" title="5.3.4 保持函数依赖的分解"></a>5.3.4 保持函数依赖的分解</h3><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220327205227908.png" alt="image-20220327205227908">\</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220327205242527.png" alt="image-20220327205242527"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220327205254705.png" alt="image-20220327205254705"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220327205325977.png" alt="image-20220327205325977"></p><h2 id="5-4-关系模式的范式"><a href="#5-4-关系模式的范式" class="headerlink" title="5.4 关系模式的范式"></a>5.4 关系模式的范式</h2><h3 id="5-4-1-第一范式1NF"><a href="#5-4-1-第一范式1NF" class="headerlink" title="5.4.1 第一范式1NF"></a>5.4.1 第一范式1NF</h3><p>非规范化的关系：当一个关系中的所有分量都是不可分的数据项时,该关系是规范化的。 </p><p>定义5.12 如果关系模式R的所有的属性的值域中每一个值都是不可分解的值，则R满足第一范式,简称1NF（First Normal Form）,记作R∈1NF。</p><p>1NF是对关系的最低要求,不满足1NF的关系是非规范化关系</p><p>非规范化关系转化为1NF的方法很简单,当然也不是唯一的。 </p><h3 id="5-4-2-第二范式2NF"><a href="#5-4-2-第二范式2NF" class="headerlink" title="5.4.2 第二范式2NF"></a>5.4.2 第二范式2NF</h3><p>定义5.13 设X、Y是关系R的两个不同的属性或属性组,且X→Y。如果存在X的某一个真子集X′,使X′→Y成立,则称Y部分函数依赖于X,记作$X\to^PY$。 反之,则称Y完全函数依赖于X,记作$X\to^FY$。</p><p>定义5.15 如果关系模式R为1NF，并且R中的每一个非主属性完全函数依赖于R的某个候选键，则称R是属于2NF。</p><p>推论： 如果关系模式R∈1NF,且它的每一个候选码都是单码,则R∈2NF。</p><h3 id="5-4-3-第三范式3NF"><a href="#5-4-3-第三范式3NF" class="headerlink" title="5.4.3 第三范式3NF"></a>5.4.3 第三范式3NF</h3><p>定义5.16 在关系R中,X、Y、Z是R的三个不同的属性或属性组,如果X→Y,Y→Z，但 $Y\nrightarrow X$ 且Y不是X的子集,则称Z传递依赖于X。<br>定义5.17 如果关系模式R为2NF，并且R中的每一个非主属性都不传递依赖于R的候选键，则称R是属于3NF。</p><p>举例：设有关系模式R（职工编号，日期，日营业额，部门名，部门经理），该模式统计商店里每个职工的日营业额，以及职工所在的部门和经理信息。如果规定：每个职工每天只有一个营业额；每个职工只在一个部门工作；每个部门只有一个经理。<br>    试回答下列问题：<br>  （1）根据上述规定，写出模式R的基本FD和关键码；<br>  （2）说明R不是2NF的理由，并把R分解成2NF模式集；<br>  （3）进而分解成3NF模式集。</p><p> 解: （1）据:     每个职工每天只有一个营业额，每个职工只在一个部门工作,   每个部门只有一个经理。得到基本的函数依赖有三个：<br>（职工编号，日期）→ 日营业额<br>职工编号 → 部门名,       部门名 → 部门经理<br>R的关键码为（职工编号，日期）</p><p>（2） R中有两个这样的FD：<br>（职工编号，日期）→（部门名，部门经理）<br>职工编号 → （部门名，部门经理）<br>由于前一个函数依赖是部分函数依赖，所以R不是2NF模式。<br>R应分解成 R1（ 职工编号，部门名，部门经理 ）<br>R2（ 职工编号，日期，日营业额 ）</p><p>此时，R1和R2都是2NF模式。R1（职工编号，部门名，部门经理）R2（职工编号，日期，日营业额）</p><p>（3）R2已是3NF模式。</p><p>但在R1中存在传递依赖：职工编号 → 部门经理<br>∵   职工编号 → 部门名,      部门名 → 部门经理<br>∴ R1不是3NF模式。<br>将 R1 分解为： R11（ 职工编号，部门名 ）<br>                         R12（ 部门名，部门经理 ）<br>       这样，ρ&#x3D; { R11，R12，R2 }是一个3NF模式集。</p><h3 id="5-4-4-巴克斯范式"><a href="#5-4-4-巴克斯范式" class="headerlink" title="5.4.4 巴克斯范式"></a>5.4.4 巴克斯范式</h3><p>第三范式的修正形式是Boyee―Codd范式（简称BCNF）,是由Boyee与Codd提出的。<br>定义5.18  设关系模式R（U,F）∈1NF,若F的任一函数依赖X→Y（$Y \notin X$）中X都包含了R的一个码,则称R∈BCNF。<br>换言之,在关系模式R中,如果每一个决定因素都包含码,则R∈BCNF。 </p><h3 id="5-4-5-分解成BCNF模式集的方法"><a href="#5-4-5-分解成BCNF模式集的方法" class="headerlink" title="5.4.5 分解成BCNF模式集的方法"></a>5.4.5 分解成BCNF模式集的方法</h3><p>算法5.3 将关系模式分解为BCNF，使它具有无损连接。<br>输入：关系模式R和函数依赖F。<br>输出：具有无损连接性的分解，使得分解中的每一个关系模式对于F在这个模式上的投影都满足BCNF。<br>方法：1、构造ρ，开始ρ&#x3D;{R（U，F）}<br>2、分解ρ，检查ρ中各关系模式是否均属于BCNF，若是，则算法终止。<br>3、如果S是ρ的一个关系模式，而S不是BCNF，又设X → A为S所满足的函数依赖，其中X不包含S的码，A不包含在X中，则在S中除X，A外还有一些属性存在，否则X就是S的码。将X，A组成模式S1，将S中除去A外其他属性组成模式S2。由于$S_1\cap S_2&#x3D;X$，S1-S2&#x3D;A，而且满足X → A，所以S分解为$S_1，S_2$具有无损连接性，分解ρ中将由$S_1$和$S_2$代替，$S_1$为BCNF。<br>$S_1$和$S_2$中包含的属性个数都比S中的属性个数少，经过有限次迭代ρ的每个模式都是BCNF。</p><h3 id="5-4-6-分解成3NF模式集的方法"><a href="#5-4-6-分解成3NF模式集的方法" class="headerlink" title="5.4.6 分解成3NF模式集的方法"></a>5.4.6 分解成3NF模式集的方法</h3><p>算法5.4 将一个关系模式分解为3NF，使它具有保持函数依赖。<br>输入：关系模式R和最小函数依赖集$F_{min}$。<br>输出：R的一个分解$ρ&#x3D;{R_1，R_2，…，R_K}$， $R_i$为3NF， ρ 保持函数依赖。<br>方法：<br>1、如果$F_{min}$只有一个函数依赖X → A，且XA&#x3D;R，则输出ρ&#x3D;{R}<br>2、如果R中某些属性与$F_{min}$中所有函数依赖的左部和右部都无关系，则将他们组成一个关系模式，从R中将它们分出去。<br>3、对于$F_{min}$中的每一个$X_i\to A_i$，都构成一个关系子模式$R_i &#x3D;X_i A_i$<br>4、停止分解，输出R。</p><p>算法5.5 将一个关系模式分解为3NF，使它既具有无损连接又保持函数依赖的分解。<br>方法：<br>1、算法5.4中关系模式R分解为$ρ&#x3D;{R_1，R_2，…，R_K}$，设X是R的码，则$\tau&#x3D; ρ\cup {X}$是R的一个分解。<br>2、若有某个ui，X$\subseteq$ui ，将X 从$\tau$中去掉。<br>3、$\tau$就是所求的分解。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220322162906755.png" alt="image-20220322162906755"></p><h1 id="第7章-数据库设计"><a href="#第7章-数据库设计" class="headerlink" title="第7章 数据库设计"></a>第7章 数据库设计</h1><h2 id="7-1-数据库设计概述"><a href="#7-1-数据库设计概述" class="headerlink" title="7.1 数据库设计概述"></a>7.1 数据库设计概述</h2><h3 id="7-1-1-软件生存期"><a href="#7-1-1-软件生存期" class="headerlink" title="7.1.1 软件生存期"></a>7.1.1 软件生存期</h3><p>按软件工程分六个阶段：<br>    规划阶段<br>    需求分析阶段<br>    设计阶段<br>    程序编程阶段<br>    调试阶段<br>    运行维护阶段</p><h3 id="7-1-2-数据库系统生存期"><a href="#7-1-2-数据库系统生存期" class="headerlink" title="7.1.2 数据库系统生存期"></a>7.1.2 数据库系统生存期</h3><p>分七个阶段：<br>    规划<br>    需求分析<br>    概念结构设计<br>    逻辑结构设计<br>    物理结构设计<br>    数据库的实现<br>    数据库的运行和维护</p><h3 id="7-1-3-数据库设计的步骤"><a href="#7-1-3-数据库设计的步骤" class="headerlink" title="7.1.3 数据库设计的步骤"></a>7.1.3 数据库设计的步骤</h3><p>四个主要阶段：</p><ol><li>用户需求分析</li><li>信息分析和定义（概念设计）：视图模型化、试图分析和汇总</li><li>设计实现（逻辑设计）：<br>模式初始设计；子模式设计；应用程序设计；模式评价；模式求精</li><li>物理设计</li></ol><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220329151445485.png" alt="image-20220329151445485"></p><h2 id="7-2-规划"><a href="#7-2-规划" class="headerlink" title="7.2 规划"></a>7.2 规划</h2><h3 id="7-2-1-规划阶段完成的任务"><a href="#7-2-1-规划阶段完成的任务" class="headerlink" title="7.2.1 规划阶段完成的任务"></a>7.2.1 规划阶段完成的任务</h3><p>确定系统的范围</p><p>确定开发工作所需要的资源</p><p>估计软件开发的成本</p><p>确定项目的进度</p><h3 id="7-2-2-可行性分析报告"><a href="#7-2-2-可行性分析报告" class="headerlink" title="7.2.2 可行性分析报告"></a>7.2.2 可行性分析报告</h3><p>规划工作完成后，写出详尽的可行性分析报告和数据库系统规划纲要，内容包括：信息范围、信息来源、人力资源、设备资源、软件及支持工具资源、开发成本估算、开发进度计划、现行系统向新系统过渡计划等。</p><p>规划送决策部门评审。</p><h2 id="7-3-需求分析"><a href="#7-3-需求分析" class="headerlink" title="7.3 需求分析"></a>7.3 需求分析</h2><h3 id="7-3-1-需求描述与分析"><a href="#7-3-1-需求描述与分析" class="headerlink" title="7.3.1 需求描述与分析"></a>7.3.1 需求描述与分析</h3><p>需求分析阶段所得的结果是下一阶段——系统的概念结构设计的基础。 如果需求分析有误,则以它为基础的整个数据库设计将成为毫无意义的工作。 而需求分析也是数据库设计人员感觉最繁琐和困难的一步。</p><p>数据库需求分析和一般信息系统的系统分析,基本上是一致的。 但是,数据库需求分析所收集的信息,却要详细得多,不仅要收集数据的型（包括数据的名称、 数据类型、 字节长度等）,还要收集与数据库运行效率、 安全性、 完整性有关的信息,包括数据使用频率、 数据间的联系以及对数据操纵时的保密要求等等。</p><h3 id="7-3-2-需求分析阶段的输入与输出"><a href="#7-3-2-需求分析阶段的输入与输出" class="headerlink" title="7.3.2 需求分析阶段的输入与输出"></a>7.3.2 需求分析阶段的输入与输出</h3><p>需求调查是指,为了彻底了解原系统的全部概况,系统分析师和数据库设计人员深入到应用部门,和用户一起调查和收集原系统所涉及的全部数据。 需求调查要明确的问题很多,大到企业的经营方针策略、 组织结构,小到每一张票据的产生、 输入、 输出、 修改、 查询等。 重点是以下几个方面：</p><p>(1) 信息要求。 用户需要对哪些信息进行查询和分析,信息与信息之间的关系如何等。</p><p>(2) 处理要求。 用户需要对信息进行何种处理,每一种处理有哪些输入、 输出要求,处理的方式如何,每一种处理有无特殊要求等。</p><p>(3) 系统要求：<br>    安全性要求： 系统有几种用户使用,每一种用户的使用权限如何。<br>    使用方式要求： 用户的使用环境是什么,平均有多少用户同时使用,最高峰时有多少用户同时使用,有无查询相应的时间要求等。<br>    可扩充性要求： 对未来功能、 性能和应用访问的可扩充性的要求。</p><h3 id="7-3-3-需求分析的步骤"><a href="#7-3-3-需求分析的步骤" class="headerlink" title="7.3.3 需求分析的步骤"></a>7.3.3 需求分析的步骤</h3><p>需求调查所得到的数据可能是零碎的、 局部的,分析师和设计人员必须进一步分析和表达用户的需求。 需求分析的具体任务是：</p><p>(1) 分析需求调查得到的资料,明确计算机应当处理和能够处理的范围,确定新系统应具备的功能。</p><p>(2) 综合各种信息所包含的数据,各种数据之间的关系,数据的类型、 取值范围、 流向。</p><p>(3) 将需求调查文档化,文档既要为用户所理解,又要方便数据库的概念结构设计。 需求分析的结果应及时与用户进行交流,反复修改,直到得到用户的认可。</p><p>在数据库设计中,数据需求分析是对有关信息系统现有数据及数据间联系的收集和处理,当然也要适当考虑系统在将来的可能需求。 一般地,需求分析包括数据流的分析及功能分析。 功能分析是指系统如何得到事务活动所需要的数据,在事务处理中如何使用这些数据进行处理（也叫加工）,以及处理后数据流向的全过程的分析。 换言之,功能分析是对所建数据模型支持的系统事务处理的分析。</p><p>数据流分析是对事务处理所需的原始数据的收集及经处理后所得数据及其流向。 一般用数据流程图（DFD）来表示。 DFD不仅指出了数据的流向,而且还指出了需要进行的事务处理（但并不涉及如何处理,这是应用程序的设计范畴）。</p><p>在需求分析阶段,应当用文档形式整理出整个系统所涉及的数据、 数据间的依赖关系、 事务处理的说明和所需产生的报告,并且尽量借助于数据字典（DD）加以说明。 除了使用数据流程图、 数据字典以外,需求分析还可使用判定表、 判定树等工具。 下面介绍数据流程图和数据字典,其他工具的使用可参见软件工程等方面的参考书。</p><h2 id="7-4-概念结构设计"><a href="#7-4-概念结构设计" class="headerlink" title="7.4 概念结构设计"></a>7.4 概念结构设计</h2><h3 id="7-4-1-概念设计的必要性"><a href="#7-4-1-概念设计的必要性" class="headerlink" title="7.4.1 概念设计的必要性"></a>7.4.1 概念设计的必要性</h3><p>n数据流分析是对事务处理所需的原始数据的收集及经处理后所得数据及其流向。 一般用数据流程图（DFD）来表示。 DFD不仅指出了数据的流向,而且还指出了需要进行的事务处理（但并不涉及如何处理,这是应用程序的设计范畴）。</p><p>在需求分析阶段,应当用文档形式整理出整个系统所涉及的数据、 数据间的依赖关系、 事务处理的说明和所需产生的报告,并且尽量借助于数据字典（DD）加以说明。 除了使用数据流程图、 数据字典以外,需求分析还可使用判定表、 判定树等工具。 下面介绍数据流程图和数据字典,其他工具的使用可参见软件工程等方面的参考书。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220329153344038.png" alt="image-20220329153344038"></p><h3 id="7-4-2-概念模型"><a href="#7-4-2-概念模型" class="headerlink" title="7.4.2 概念模型"></a>7.4.2 概念模型</h3><p>(1) 有丰富的语义表达能力。 能表达用户的各种需求,反映现实世界中各种数据及其复杂的联系,及用户对数据的处理要求等。</p><p>(2) 易于交流和理解。 概念模型是系统分析师、 数据库设计人员和用户之间的主要交流工具。</p><p>(3) 易于修改。 概念模型能灵活地加以改变,以反映用户需求和环境的变化。</p><p>(4) 易于向各种数据模型转换。 设计概念模型的最终目的是向某种DBMS支持的数据模型转换,建立数据库应用系统。</p><h3 id="7-4-3-概念设计的主要步骤"><a href="#7-4-3-概念设计的主要步骤" class="headerlink" title="7.4.3 概念设计的主要步骤"></a>7.4.3 概念设计的主要步骤</h3><p>概念设计的任务分为三步：</p><p>​进行数据抽象，设计局部概念模式</p><p>​将局部概念模式综合成全局概念模式。</p><p>​评审</p><h3 id="7-4-4-数据抽象"><a href="#7-4-4-数据抽象" class="headerlink" title="7.4.4 数据抽象"></a>7.4.4 数据抽象</h3><p>聚集</p><p>概括</p><p>数据抽象层次</p><h3 id="7-4-5-ER模型的操作"><a href="#7-4-5-ER模型的操作" class="headerlink" title="7.4.5 ER模型的操作"></a>7.4.5 ER模型的操作</h3><p>实体类型的分裂：垂直分割、水平分割</p><p>实体类型的合并</p><p>联系类型的分裂</p><p>联系类型的合并</p><h3 id="7-4-6-采用ER方法的数据库概念设计"><a href="#7-4-6-采用ER方法的数据库概念设计" class="headerlink" title="7.4.6 采用ER方法的数据库概念设计"></a>7.4.6 采用ER方法的数据库概念设计</h3><p>设计局部ER模式<br>    确定局部结构范围<br>    实体定义<br>    联系定义<br>    属性分配</p><p>设计全部ER模式<br>    确定公共实体类型<br>    局部ER模式的合并<br>    消除冲突</p><p>全部ER模式的优化<br>    实体类型的合并<br>    冗余属性的消除</p><h2 id="7-5-逻辑结构设计"><a href="#7-5-逻辑结构设计" class="headerlink" title="7.5 逻辑结构设计"></a>7.5 逻辑结构设计</h2><h3 id="7-5-1-逻辑设计的环境"><a href="#7-5-1-逻辑设计的环境" class="headerlink" title="7.5.1 逻辑设计的环境"></a>7.5.1 逻辑设计的环境</h3><p>数据库的逻辑设计就是把概念设计得到的数据库模型,转化为具体的DBMS所能接受的数据库逻辑结构,包括数据库模式和外模式。</p><p>(1) 概念结构设计阶段的输出信息： 所有的局部和全局概念模式。 图中用E―R模型表示。</p><p>(2) 处理需求： 需求分析阶段产生的业务活动分析结果。 包括： 用户需求、 数据的使用频率和数据库的规模。</p><p>(3) DBMS特性： 即特定的DBMS所支持的数据结构。 如RDBMS的数据结构是二维表。</p><h3 id="7-5-2-逻辑设计的步骤"><a href="#7-5-2-逻辑设计的步骤" class="headerlink" title="7.5.2 逻辑设计的步骤"></a>7.5.2 逻辑设计的步骤</h3><p>（1） 将E―R模型转换为等价的关系模式。</p><p>（2） 按需要对关系模式进行规范化。</p><p>（3） 对规范化后的模式进行评价。 调整关系模式,使其满足性能、 存储空间等方面的要求。</p><p>（4）根据局部应用的需要,设计用户外模式。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220329154001086.png" alt="image-20220329154001086"></p><h3 id="7-5-3-ER模型向关系模型的转换"><a href="#7-5-3-ER模型向关系模型的转换" class="headerlink" title="7.5.3 ER模型向关系模型的转换"></a>7.5.3 ER模型向关系模型的转换</h3><p>ER模型向关系模型的转化的一般规则</p><p>超类和子类的转换规则</p><h3 id="7-5-4-关系数据库的逻辑设计"><a href="#7-5-4-关系数据库的逻辑设计" class="headerlink" title="7.5.4 关系数据库的逻辑设计"></a>7.5.4 关系数据库的逻辑设计</h3><p>导出初始关系模式</p><p>规范化处理</p><p>模式评价</p><p>模式修正</p><h2 id="7-6-物理结构设计"><a href="#7-6-物理结构设计" class="headerlink" title="7.6 物理结构设计"></a>7.6 物理结构设计</h2><p>物理设计分五步完成：</p><ol><li>存储记录结构设计</li><li>确定数据存放位置</li><li>存取方法的设计</li><li>完整性和安全性的考虑</li><li>程序设计</li></ol><h2 id="7-7-数据库的实现"><a href="#7-7-数据库的实现" class="headerlink" title="7.7 数据库的实现"></a>7.7 数据库的实现</h2><p>实现阶段主要有三项工作：</p><ol><li>简历实际的数据结构</li><li>装入实际数据对应用程序进行调试</li><li>装入实际数据，进入试运行状态</li></ol><h2 id="7-8-数据库的运行和维护"><a href="#7-8-数据库的运行和维护" class="headerlink" title="7.8 数据库的运行和维护"></a>7.8 数据库的运行和维护</h2><p>运行维护阶段主要有四项工作：</p><ol><li>维护数据库的安全性和完整性</li><li>监测并改善数据库运行性能</li><li>根据用户要求对数据库现有功能进行扩充</li><li>及时改正运行中发现的错误</li></ol><h1 id="第8章-数据库的管理"><a href="#第8章-数据库的管理" class="headerlink" title="第8章 数据库的管理"></a>第8章 数据库的管理</h1><h2 id="8-1-事务的概念"><a href="#8-1-事务的概念" class="headerlink" title="8.1 事务的概念"></a>8.1 事务的概念</h2><h3 id="8-1-1-事务的定义"><a href="#8-1-1-事务的定义" class="headerlink" title="8.1.1 事务的定义"></a>8.1.1 事务的定义</h3><p>事务是由若干数据库操作组成的一个逻辑工作单位，是一个不可分割的工作单位。</p><p>一个应用程序可以包括多个事务。</p><p>事务以BEGIN TRANSACTION语句的成功执行开始，以COMMIT或ROLLBACK语句的成功执行结束。</p><p>COMMIT（提交）语句表示一事务的全部操作都已成功，它对DB的所有更新可真正写到DB中。</p><p>ROLLBACK（回退）语句表示事务没有成功地完成全部操作，系统将撤消该事务对DB已作的更新。</p><h3 id="8-1-2-事务的性质"><a href="#8-1-2-事务的性质" class="headerlink" title="8.1.2 事务的性质"></a>8.1.2 事务的性质</h3><p>事务有四个重要性质：原子性、一致性、隔离性和持久性。通常称为“ACID性质”。</p><p>原子性（atomicity）： 事务对数据库的更新要么全部起作用，要么完全不起作用。DBMS的事务管理子系统</p><p>一致性（consistency）：事务将数据库从一个一致性状态转变为另一个一致性状态。 程序员（正确地编写事务）DBMS的完整性子系统</p><p>隔离性（isolation）：事务相互隔离，在多个事务并发执行时，任一事务的更新操作在该事务成功提交前对其他事务都是不可见的。DBMS的并发控制子系统</p><p>持久性（durability）：事务一旦成功提交，其对数据库的更新就永久有效，不会因系统崩溃等而丢失。DBMS的恢复管理子系统</p><h3 id="8-1-3-事务的状态变迁"><a href="#8-1-3-事务的状态变迁" class="headerlink" title="8.1.3 事务的状态变迁"></a>8.1.3 事务的状态变迁</h3><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220510135222966.png" alt="image-20220510135222966"></p><h2 id="8-2-数据库的恢复"><a href="#8-2-数据库的恢复" class="headerlink" title="8.2 数据库的恢复"></a>8.2 数据库的恢复</h2><h3 id="8-2-1-数据库恢复的定义原则和方法"><a href="#8-2-1-数据库恢复的定义原则和方法" class="headerlink" title="8.2.1 数据库恢复的定义原则和方法"></a>8.2.1 数据库恢复的定义原则和方法</h3><p>数据库恢复的定义：系统能把数据库从被破坏、不正确的状态、恢复到最近一个正确的状态，DBMS的这种能力称为数据库的可恢复性</p><p>数据库恢复的基本策略和实现方法：</p><p>​恢复的基本方略：冗余（数据重复存储）</p><p>​实现方法：</p><p>​备份：定期对数据库复制或转储（静态转储（无用户操作时备份）和动态转储（有用户操作时备份），海量转储（全备份）和增量转储（备份新修改的数据））</p><p>​日志：执行事务时，记录其开始、结束和对DB的每次更新操作</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220510140609384.png" alt="image-20220510140609384"></p><p>$t_a和t_b$做过备份，运行事务时故障发生，方法是：回到最新的存档点$t_b$，然后根据日志重新运行事务</p><h3 id="8-2-2-故障类型"><a href="#8-2-2-故障类型" class="headerlink" title="8.2.2 故障类型"></a>8.2.2 故障类型</h3><p>事务故障<br>    非预期事务故障：运算错误、数据错误、死锁等，故障事务夭折<br>    可预期事务故障：在事务中可预期出错的地方所加的ROLLBACK语句</p><p>系统故障： 硬件、系统软件出错，停电等，事务执行被打断，内存中数据被破坏</p><p>介质故障： 磁头、磁盘控制器或磁盘损坏，盘上数据丢失，病毒破坏等，DB遭破坏</p><h3 id="8-2-3-恢复方法"><a href="#8-2-3-恢复方法" class="headerlink" title="8.2.3 恢复方法"></a>8.2.3 恢复方法</h3><p>当系统运行过程中发生故障，利用数据库后备副本和日志文件将数据库恢复到故障前的某个一致性状态。不同故障其恢复技术不一样：</p><p>1．事务故障的恢复</p><p>​事务故障是指事务在运行至正常终止点前被中止，此时恢复子系统应撤销（UNDO）此事务已对数据库进行的修改。</p><p>事务故障恢复的具体做法如下:</p><p>① 反向扫描日志文件（即从最后向前扫描日志文件），查找该事务的更新操作。</p><p>② 对该事务的更新操作执行逆操作。</p><p>​即将日志记录中“更新前的值”写入数据库：</p><p>​若记录中是插入操作，则相当于做删除操作;</p><p>​若记录中是删除操作,则做插入操作；</p><p>​若是修改操作，则用修改前值代替修改后值。</p><p>③ 继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。</p><p>④ 如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。</p><p><strong>事务故障的恢复是由系统自动完成的,不需要用户干预。</strong></p><p>2．系统故障的恢复</p><p>系统故障造成数据库不一致状态的原因有两个：</p><p>​未完成事务对数据库的更新已写数据库；</p><p>​已提交事务对数据库的更新还留在缓冲区没来得及真正写入数据库。</p><p>恢复操作：撤销故障发生时未完成的事务，重做已完成的事务。</p><p>具体做法如下:</p><p>① 正向扫描日志文件(即从头开始扫描日志文件)，找出在故障发生前:</p><p>​已提交事务(既有&lt;Ti,START&gt;记录，也有&lt;Ti，COMMIT&gt;记录)，将其事务标识记入重做队列。</p><p>​尚未完成的事务(有&lt;Ti,START&gt;记录,无&lt;Ti,COMMIT&gt;记录)，将其事务标识记入撤销队列。</p><p>② 对撤销队列中的各个事务进行撤销（UNDO）处理</p><p>​进行撤销（UNDO）处理的方法是:</p><p>​反向扫描日志文件，</p><p>​对每个UNDO事务的更新操作执行逆操作，即将日志记录中“更新前的值”写入数据库。</p><p>③ 对重做队列中的各个事务进行重做（REDO）处理</p><p>​进行重做REDO处理的方法是：</p><p>​正向扫描日志文件，对每个REDO事务重新执行登记操作。即将日志记录中“更新后的值”写入数据库。</p><p><strong>系统故障的恢复也由系统自动完成的,不需要用户干预。</strong></p><p>3．介质故障的恢复</p><p>在发生介质故障和遭受病毒破坏时，磁盘上的物理数据库遭到毁灭性破坏。此时恢复的过程如下：</p><p>① 装入最新的后备副本到新的磁盘，使数据库恢复到最近一次转储时的一致状态。</p><p>② 装入有关的日志文件副本，重做已提交的所有事务。</p><p>这样就可以将数据库恢复到故障前某一时刻的一致状态。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220510142522808.png" alt="image-20220510142522808"></p><h3 id="8-2-4-检查点机制"><a href="#8-2-4-检查点机制" class="headerlink" title="8.2.4 检查点机制"></a>8.2.4 检查点机制</h3><ol><li>检查点（Checkpoint）方法</li></ol><p>​DBMS定时设置检查点，在检查点时刻才真正做到把对DB的修改写到磁盘，并在日志文件写入一条检查点记录。</p><p>检查点方法的恢复方法（二步）</p><p>​根据日志文件建立重做队列和事务撤消队列。</p><p>​对重做队列中的事务进行REDO处理，对撤消队列中的事务进行UNDO处理。</p><p>DBMS定时设置检查点，在检查点时，做下列事情：</p><p>第一步：将日志缓冲区中的日志记录写入磁盘。</p><p>第二步：将数据库缓冲区中修改过的缓冲块内容写入磁盘。</p><p>第三步：写一个检查点记录到磁盘，内容包括：</p><p>​① 检查点时刻，所有活动事务；</p><p>​② 每个事务最近日志记录地址。</p><p>第四步：把磁盘中日志检测点记录的地址写入“重新启动文件中”。</p><ol start="2"><li>检查点恢复步骤</li></ol><p>① 正向扫描日志文件，建立事务重做队列和事务撤消队列。</p><p>​重做队列：将已完成的事务加入重做队列；</p><p>​撤销队列：未完成的事务加入撤销队列。</p><p>② 对撤销队列做UNDO处理的方法是：</p><p>​反向扫描日志文件，根据撤销队列的记录对每一个撤销</p><p>​事务的更新操作执行逆操作，使其恢复到原状态。</p><p>③ 对重做队列做REDO处理的方法是：</p><p>​正向扫描日志文件，根据重做队列的记录对每一个重做事务实施对数据库的更新操作。</p><p>例：</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220510143712713.png" alt="image-20220510143712713"></p><p>分析：T1：T1在检查点c之前已经做完，所以T1不用恢复；T2、T4：在检查点c未做完，但在故障点之前已经做完了，因此放入重做队列；T3、T5：在检查点c和故障点时都没做完，因此放入撤销队列</p><h3 id="8-2-5-运行记录的优先原则"><a href="#8-2-5-运行记录的优先原则" class="headerlink" title="8.2.5 运行记录的优先原则"></a>8.2.5 运行记录的优先原则</h3><p>运行记录优先原则包括两点：</p><p>​将一个更新结果写到DB中前，必须确保先在日志中成功登记了这个更新。</p><p>​直至对一事务的日志登记全部完成，方能够允许该事务完成COMMIT处理。</p><p>这个原则确保了发生故障后能够根据日志对事务进行REDO或UNDO。</p><h2 id="8-3-数据库的并发控制"><a href="#8-3-数据库的并发控制" class="headerlink" title="8.3 数据库的并发控制"></a>8.3 数据库的并发控制</h2><h3 id="8-3-1-并发操作带来的三个问题"><a href="#8-3-1-并发操作带来的三个问题" class="headerlink" title="8.3.1 并发操作带来的三个问题"></a>8.3.1 并发操作带来的三个问题</h3><p>为了充分利用数据库这个共享资源，DBMS允许多个事务并发地存取数据库。</p><p>如果不对并发操作进行恰当的控制，可能导致如下的数据不一致性问题：</p><ol><li>丢失更新问题：一事务所作q的更新操作因另一事务的操作而丢失。</li><li>读“脏数据”问题：又称为未提交依赖，指一事务取用了别的事务未提交随后又被撤消的数据。</li><li>不一致分析问题：指事务从数据库中读取了处于不一致状态的数据，并因此进行了不一致的分析。</li></ol><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220515181206230.png" alt="image-20220515181206230"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220515181228081.png" alt="image-20220515181228081"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220515181253988.png" alt="image-20220515181253988"></p><h3 id="8-3-2-封锁机制"><a href="#8-3-2-封锁机制" class="headerlink" title="8.3.2 封锁机制"></a>8.3.2 封锁机制</h3><p>封锁是实现并发控制的重要技术。所谓封锁，是指事务向系统发出对某数据对象加锁的请求，以取得对该对象一定的控制权。基本的封锁有两类：</p><ol><li>排它型封锁（写锁，X封锁）：一个事务对数据对象加了X锁后，在它释放X锁之前不允许其他事务再对该数据对象加任何锁。</li><li>共享型锁（读锁，S封锁）：一个事务对数据对象加了S锁后，允许其他事务再对该数据对象加S锁，但在它释放S锁之前不允许其他事务加X锁。</li></ol><p><strong>封锁协议（排它型封锁）：</strong></p><p>​PX协议主要内容是：事务若要更新数据，则必须先提出对此数据对象的X封锁请求；事务如果未获准X封锁，那么进入等待状态，直至获准在此数据对象上的X封锁，才能继续执行。PX协议可以解决因多事务同时更新同一数据对象而引起的更新丢失问题。</p><p>​PXC协议 是在“PX协议”上再加一规定：解除X锁的操作合并到事务的结束（COMMIT或ROLLBACK）操作中。PXC协议可以解决因事务ROLLBACK而引起的更新丢失问题。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220515181919041.png" alt="image-20220515181919041"></p><p><strong>封锁协议（共享型封锁）：</strong></p><p>PS协议 其主要内容是：事务若要存取数据，则必须先提出对此数据对象的S封锁请求；事务如果未获准S封锁，那么进入等待状态，直至获准在此数据对象上S封锁，才能继续执行；事务在更新数据前必须先将它在该数据对象上的S封锁升级（UPGRADE）为X封锁。</p><p>PSC协议 是在“PS协议”上再加一规定：解锁操作合并到事务的结束（COMMIT或ROLLBACK）操作中。PSC协议可以解决丢失更新、读“脏数据”和不一致分析问题。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220515182350815.png" alt="image-20220515182350815"></p><p>封锁相容矩阵：</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220515182522083.png" alt="image-20220515182522083"></p><h3 id="8-3-3-活锁和死锁"><a href="#8-3-3-活锁和死锁" class="headerlink" title="8.3.3 活锁和死锁"></a>8.3.3 活锁和死锁</h3><p>恰当地运用封锁技术，可以保证并发调度的正确性、有效地避免数据不一致，但有可能引起活锁和死锁问题。</p><p>① 活锁：出现某个事务永远处于等待状态得不到执行的现象。</p><p>​避免活锁的一个简便方法是采用“先来先服务”排队的策略。封锁子系统按请求在时间上的先后次序对事务排序,数据对象上原有的锁一释放,即执行队列中第一个事务的封锁请求。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220515182743168.png" alt="image-20220515182743168"></p><p>② 死锁：出现若干事务因循环等待而无法继续执行的现象。</p><p>​例： 两个事务T1和T2已分别封锁了数据D1和D2。T1和T2由于需要各自分别申请封锁D2和D1,但是由于D2和D1已被对方封锁,因而T1和T2只能等待。 而T1和T2由于等待封锁而不能结束,从而使对方的封锁申请也永远不能被选中,这就形成了死锁。</p><p>​合理的解决方案：1. 死锁的诊断 DBMS周期地测试系统中是否出现了死锁。用事务依赖图的形式可以测试系统中是否存在死锁。如果在事务依赖图中，沿着箭头方向存在一个循环，那么表示已出现死锁现象；2. 定时向事务发消息，并让事务应答，检测是否出现思索，如果出现思索，对Rollback代价最小的事务进行Rollback</p><p>​不合理的解决方案：1. 规定所有数据的加锁顺序，比如：A、B、C、D，所有数据必须按此顺序加锁，比如A、C；2. 每个事务必须一次性将所有需要的数据同时加锁，否则，不予执行</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220515182927525.png" alt="image-20220515182927525"></p><p>③ 饿死：有可能存在一个事务队列，其中每个事务都申请对数据项加S锁，且每个事务在授权加锁后一小段时间内释放封锁，此时若另有一个事务欲在该数据项上加X锁，则永远轮不上封锁的机会。</p><p>解决方案：当事务T2申请对数据项Q加S锁时，授权加锁的条件是，1. 不存在在数据项Q上持有X锁的其他事务；2. 不存在等待对数据项Q加锁且先于T2申请加锁的食物</p><h3 id="8-3-4-并发事务的可串行化调度"><a href="#8-3-4-并发事务的可串行化调度" class="headerlink" title="8.3.4 并发事务的可串行化调度"></a>8.3.4 并发事务的可串行化调度</h3><p>事务的调度、串行调度和并发调度</p><p>​事务的执行次序称为“调度”。</p><p>​若多个事务依次执行，则称为事务的串行调度。</p><p>​若设法（例如利用分时的方法）多个事务同时被处理（即交错执行），则称为事务的并发调度。</p><p>​在应用环境中，事务的任一串行调度都是有效的（正确的），但是事务的并发调度不一定是正确的，有可能产生前面提到的不一致性问题。</p><p>例：现在有两个事务，分别包含下列操作：</p><p>​事务T1：读B；A&#x3D;B十1；写回A；</p><p>​事务T2：读A；B&#x3D;A十1；写回B</p><p>​假设A的初值为10，B的初值为2。</p><p>下图给出了对这两个事务的三种不同的调度策略。</p><p>（a）和（b）为两种不同的串行调度策略，虽然执行结果不同，但它们都是正确的调度。</p><p>（c）中两个事务是交错执行的，由于其执行结果与（a）、（b）的结果都不同，所以是错误的调度。</p><p>（d）中两个事务也是交错执行的，由于其执行结果与串行调度1（图（a））的执行结果相同，所以是正确的调度。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220515190012335.png" alt="image-20220515190012335"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220515190105522.png" alt="image-20220515190105522"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220515190122708.png" alt="image-20220515190122708"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220515190132671.png" alt="image-20220515190132671"></p><p>为了保证并行操作的正确性：DBMS的并行控制机制必须提供一定的手段来保证调度是可串行化的。</p><p>​从理论上讲，在某一事务执行时禁止其他事务执行的调度策略一定是可串行化的调度，这也是最简单的调度策略，但这种方法实际上是不可行的，因为它使用户不能充分共享数据库资源。</p><p><strong>可串行化概念</strong></p><p>​如果一个并发调度与某一串行调度具有相同的执行结果，那么称这个并发调度是“可串行化的调度”（即正确的并发调度），否则是不可串行化的调度。</p><p><strong>两段封锁协议</strong></p><p>​事务在对数据对象存取之前必须先获得对此数据对象的封锁，事务在解除了一个锁之后不再获得任何锁。</p><p>​若所有事务都遵守两段封锁协议,则对这些事务的任何并发调度策略都是可串行化的；</p><p>​但若并发事务的一个调度是可串行化的,并不一定所有事务都符合两段封锁协议。</p><p>​两段封锁协议与防止死锁的一次封锁法是不同的。 一次封锁法符合两段封锁协议,但两段封锁协议并不要求一次封锁法。 因此,遵守两段封锁协议的事务也有可能发生死锁。</p><p>封锁的粒度：封锁对象的规模称为封锁粒度（Granularity）。</p><h3 id="8-3-5-SQL中事务的存取模式和隔离级别"><a href="#8-3-5-SQL中事务的存取模式和隔离级别" class="headerlink" title="8.3.5 SQL中事务的存取模式和隔离级别"></a>8.3.5 SQL中事务的存取模式和隔离级别</h3><p>事务的存取模式</p><p>​READ ONLY（只读型）</p><p>​READ WRITE（读写型）</p><p>事务的隔离级别</p><p>​SERIALIZABLE（可串行化）</p><p>​REPEATABLE READ（可重复读）</p><p>​READ COMMITED（读提交数据）</p><p>​READ UNCOMMITED（读未提交数据）</p><h2 id="8-4-数据库的完整性"><a href="#8-4-数据库的完整性" class="headerlink" title="8.4 数据库的完整性"></a>8.4 数据库的完整性</h2><h3 id="8-4-1-完整性子系统和完整性规则"><a href="#8-4-1-完整性子系统和完整性规则" class="headerlink" title="8.4.1 完整性子系统和完整性规则"></a>8.4.1 完整性子系统和完整性规则</h3><p>完整性：是指数据的正确性、有效性和相容性。</p><p>完整性约束条件：为保证数据的完整性而规定的条件。</p><p>完整性检查：检查DB中数据是否满足完整性约束条件。</p><p>完整性子系统：DBMS中执行完整性检查的子系统。其功能：</p><p>​①监督事务的执行，测试其是否违反完整性约束条件；</p><p>​②若有违反，则按进行预定的处理。</p><p>完整性规则的组成：</p><p>​① 每个规则包括三部分：</p><p>​触发条件 规定何时执行本规则进行检查；</p><p>​约束条件 又称谓词，定义应满足的条件；</p><p>​否则子句 规定不满足条件时该作的处理。</p><p>​② 在关系DB中，完整性规则可分为三类：</p><p>​域完整性规则：定义属性取值范围。</p><p>​域联系的规则：定义属性间的联系、影响和约束。</p><p>​关系完整性规则：定义更新操作对值的影响和限制。</p><p>​③ 完整性规则用DDL描述，由系统执行检查。</p><h3 id="8-4-2-SQL中的完整性约束"><a href="#8-4-2-SQL中的完整性约束" class="headerlink" title="8.4.2 SQL中的完整性约束"></a>8.4.2 SQL中的完整性约束</h3><p>完整性约束分为三大类：域约束、基本表约束、断言</p><h4 id="1-域完整性规则"><a href="#1-域完整性规则" class="headerlink" title="1. 域完整性规则"></a>1. 域完整性规则</h4><p>定义属性的取值范围―属性值约束。</p><p>包括：域约束子句、非空值约束、基于属性的检查子句。</p><p>①用“CREATE DOMAIN”语句定义新的域,并可出现CHECK子句。</p><p>例: 定义一个新的域DEPT，可用下列语句实现：</p><p>CREATE DOMAIN DEPT CHAR （20） DEFAULT ‘计算机软件‘</p><p>CONSTRAINT VALID_ DEPT      &#x2F;*域约束名字*&#x2F;</p><p>CHECK（VALUE IN (‘计算机科学与技术’,‘计算机软件’))；</p><p>允许域约束上的CHECK子句中可以有任意复杂的条件表达式。</p><p>②非空值约束（NOT NULL）</p><p>例： SNO char(4) NOT NULL</p><p>③基于属性的检查子句(CHECK):</p><p>例：CHECK (GRADE IS NULL) OR (GRADE BRTWEEN 0 AND 100)</p><h4 id="2-基本表约束"><a href="#2-基本表约束" class="headerlink" title="2. 基本表约束"></a>2. 基本表约束</h4><p>①主键约束</p><p>可用主键约束来描述实体完整性规则。主键约束可用两种形式表示：主键子句和主键短语。</p><p>主码可在定义关系的CREATE TABLE语句中使用PRIMARY KEY关键字加以定义。有两种定义主键的方法，一种是在属性后增加关键字，另一种是在属性表中加入额外的定义主键的子句：</p><p>PRIMARY KEY(主键属性名表)</p><p>使用关键字UNIQUE，说明该属性（或属性组）的值不能重复出现。</p><p>②外键约束</p><p>FOREIGN KEY（〈列名序列1〉）.</p><p>REFERENCES &lt;参照表&gt; [（&lt;列名序列2&gt;）]</p><p>[[ ON DELETE &lt;参照动作&gt; ]</p><p>[[ ON UPDATE &lt;参照动作&gt; ]</p><p>外部码的取值只有两种情况：①要么取空值；②要么取参照关系中的主码值。当用户的删除或修改操作违反了上述规则时，如何保持此种约束呢？SQL中提供了五种可选方案供数据库实现者使用。</p><p>参照动作可以有五种方式：</p><p>​NO ACTION（无影响）</p><p>​CASCADE（级联方式）</p><p>​RESTRICT（受限方式）</p><p>​SET NULL（置空值）</p><p>​SET DEFAULT（置缺省值）</p><p>③ 检查约束</p><p>对单个关系的元组值加以约束。</p><p>对表内元组说明约束时，在CREATE TABLE语句中的属性表、主码、外部码的说明之后加上CHECK子句。每当对元组进行插入或修改操作时，都要对CHECK子句的条件表达式求值，如果条件为假，违背了约束，系统将拒绝该插入或修改操作。</p><p>CHECK子句的一般格式为： CHECK &lt;条件&gt;</p><h4 id="3-断言"><a href="#3-断言" class="headerlink" title="3. 断言"></a>3. 断言</h4><p>如果完整性约束与多个关系有关，或者与聚合操作有关，SQL提供“断言”（Assertions）机制让用户书写完整性约束。</p><p>定义：CREATE ASSERTION 断言名 CHECK（条件）</p><p>撤消：DROP ASSERTION 断言名</p><p>例：设有三个关系模式：</p><p>EMP（ENO，ENAME，AGE，SEX，ECITY）</p><p>COMP（CNO，CNAME，CITY）</p><p>WORK（ENO，CNO，SALARY）</p><p>试用SQL的断言机制定义下列完整性约束：</p><p>①每个职工至多可在3个公司兼职工作:</p><p>​CREATE ASSERTION ASSE1 CHECK（ 3 &gt;&#x3D; ALL (SELECT COUNT(CNO) FROM WORK GROUP BY ENO ））； </p><p>② 每家公司男职工的平均年龄不超过40岁: </p><p>​CREATE ASSERTION ASSE2 CHECK（40 &gt;&#x3D; ALL（SELECT AVG(EMP.AGE FROM EMP,WORK WHERE EMP.ENO&#x3D;WORK.ENO AND SEX&#x3D;’男’ GROUP BY CNO））；</p><p>③ 不允许女职工在建筑公司工作:</p><p>CREATE ASSERTION ASSE3 CHECK（ NOT EXISTS（SELECT * FROM WORK WHERE CNO IN（SELECT CNO FROM COMP WHERE CNAME &#x3D;‘建筑公司’) AND ENO IN（SELECT ENO FROM EMP WHERE SEX&#x3D;‘女’)));</p><p>断言也可以在关系定义中用检查子句形式定义，但是检查子句不一定能保证完整性约束彻底实现，而断言能保证不出差错。</p><h3 id="8-4-3-SQL3的触发器"><a href="#8-4-3-SQL3的触发器" class="headerlink" title="8.4.3 SQL3的触发器"></a>8.4.3 SQL3的触发器</h3><p>触发器结构组成：</p><p>​触发动作实际上是一系列SQL语句，可以有两种方式：</p><p>​(1) 对被事件影响的每一行（FOR EACH ROW）——每一元组执行触发过程，称为行级触发器。</p><p>​(2) 对整个事件只执行一次触发过程（FOR EACH STATEMENT）称为语句级触发器。该方式是触发器的默认方式。所以综合触发时间和触发方式，触发器的基本类型如下表所示。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220518161542494.png" alt="image-20220518161542494"></p><p>SQL3的触发器实例</p><p>【实例1】某单位修改工资原则:如果职工工资修改后仍低于900元，那么，在修改后的工资基础上再增加原工资的5%，但不得超过900元（元组级触发器 ）。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220518162620850.png" alt="image-20220518162620850"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> TRI_UPD_SALARY     <span class="comment">/*触发器命名*/</span></span><br><span class="line"> AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> SALARY <span class="keyword">ON</span> WORK <span class="comment">/*触发时间,触发事件,目标表*/</span></span><br><span class="line"> <span class="keyword">REFERENCING</span>                   <span class="comment">/*设置必要的变量*/</span></span><br><span class="line">     <span class="keyword">OLD</span> <span class="keyword">AS</span> OLDTUPLE          <span class="comment">/*为元组级触发器设置变量*/</span></span><br><span class="line">     <span class="keyword">NEW</span> <span class="keyword">AS</span> NEWTUPLE </span><br><span class="line"> <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span>                  <span class="comment">/*触发器的动作时间间隔*/</span></span><br><span class="line"> <span class="keyword">WHEN</span> ( <span class="number">900</span> <span class="operator">&gt;</span> NEWTUPLE.SALARY )   <span class="comment">/*触发器的动作条件部分*/</span>  </span><br><span class="line">  <span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span>  </span><br><span class="line">   <span class="keyword">UPDATE</span> WORK                   <span class="comment">/*触发器的动作部分1*/</span></span><br><span class="line">    <span class="keyword">SET</span> SALARY<span class="operator">=</span>NEWTUPLE.SALARY<span class="operator">+</span>OLDTUPLE.SALARY<span class="operator">*</span><span class="number">0.05</span></span><br><span class="line">    <span class="keyword">WHERE</span> ENO<span class="operator">=</span>NEWTUPLE.ENO</span><br><span class="line">    <span class="keyword">AND</span> (<span class="number">900</span><span class="operator">&gt;</span>NEWTUPLE.SALARY<span class="operator">+</span>OLDTUPLE.SALARY<span class="operator">*</span><span class="number">0.05</span>); </span><br><span class="line">   <span class="keyword">UPDATE</span> WORK                   <span class="comment">/*触发器的动作部分2*/</span></span><br><span class="line">    <span class="keyword">SET</span> SALARY<span class="operator">=</span><span class="number">900</span></span><br><span class="line">    <span class="keyword">WHERE</span> ENO<span class="operator">=</span>NEWTUPLE.ENO</span><br><span class="line">     <span class="keyword">AND</span> (<span class="number">900</span><span class="operator">&lt;=</span>NEWTUPLE.SALARY<span class="operator">+</span>OLDTUPLE.SALARY<span class="operator">*</span><span class="number">0.05</span>);</span><br><span class="line">  <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>【实例2】在学习关系SC表中修改课程号CNO,即学生的选课登记需作变化。在关系SC中的约束：要求保持每门课程选修人数不超过50。如果更改课程号后，违反这个约束，那么这个更改应该不做。（语句级触发器）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TRIGGER</span>  TRI_UPD_SC               <span class="comment">/*触发器的命名*/</span></span><br><span class="line">  INSTEAD  <span class="keyword">OF</span>  <span class="keyword">UPDATE</span> <span class="keyword">OF</span> CNO  <span class="keyword">ON</span>  SC     <span class="comment">/*时间、事件、目标*/</span></span><br><span class="line">  <span class="keyword">REFERENCING</span>                             <span class="comment">/*设置变量*/</span>   </span><br><span class="line">    OLD_TABLE  <span class="keyword">AS</span>  OLDSTUFF         <span class="comment">/*为语句级触发器设置变量*/</span></span><br><span class="line">    NEW_TABLE  <span class="keyword">AS</span>  NEWSTUFF</span><br><span class="line">  <span class="keyword">WHEN</span> （<span class="number">50</span> <span class="operator">&gt;=</span> <span class="keyword">ALL</span>（<span class="keyword">SELECT</span>  <span class="built_in">COUNT</span>(SNO)    <span class="comment">/*动作时间条件*/</span></span><br><span class="line">    <span class="keyword">FROM</span> ((SC <span class="keyword">EXCEPT</span> OLDSTUFF) <span class="keyword">UNION</span> NEWSTUFF)</span><br><span class="line">    <span class="keyword">GROUP</span>  <span class="keyword">BY</span>  CNO）））</span><br><span class="line">  <span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span>                                 <span class="comment">/*动作体*/</span></span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span>  SC                            <span class="comment">/*触发动作1*/</span></span><br><span class="line">    <span class="keyword">WHERE</span> (SNO,CNO,GRADE) <span class="keyword">IN</span> OLDSTUFF; </span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC                             <span class="comment">/*触发动作2*/</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> NEWSTUFF</span><br><span class="line">  <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>   触发器的动作时间:INSTEAD OF（第2行），任何企图修改关系SC中CNO值都被这个触发器截获，并且触发事件的操作（即修改CNO）不再进行，由触发器的条件真假值来判断是否执行动作部分的操作。</p><p>INSTEAD OF 表示：在触发事件发生时,只要满足WHEN条件，就执行动作部分的操作，而触发事件的操作不再执行。</p><p>  动作部分的操作由两个SQL语句组成，前一个语句是从关系SC中删除修改前的元组，后一个语句是在关系SC中插入修改后的元组。用这样的方式完成触发事件的操作。</p><p>  因为是语句级触发器，所以没有FOR EACH ROW，在这里FOR EACH STATEMENT也省略了。</p><p><strong>SQL Server的数据库完整性及实现方法</strong></p><p>SQL Server具有较健全的数据库完整性控制机制。</p><p>SQL Server使用约束、缺省，规则和触发器4种方法定义和实施数据库完整性功能。</p><p>1、SQL Server的数据完整性的种类</p><p>SQL Server中的数据完整性包括 域完整性、实体完整性和参照完整性3种。</p><p>（1）域完整性为列级和元组级完整性—-为列或列组指定一个有效的数据集，并确定该列是否允许为空。</p><p>（2）实体完整性为表级完整性—要求表中所有的元组都应该有一个唯一的标识符(主码)。</p><p>（3）参照完整性是表级完整性—维护参照表中的外码与被参照表中主码的相容关系。</p><p>2、SQL Server数据完整性的两种方式</p><p>SQL Server 使用声明数据完整性和过程数据完整性两种方式实现 数据完整性控制。</p><p>（1）声明数据完整性：通过在对象定义中定义、系统本身自动强制来实现。声明数据完整性包括各种约束、缺省和规则。</p><p>（2）过程数据完整性：通过使用脚本语言（主语言或 TransactSOL）定义，系统在执行这些语言时强制完整性实现。过程数据完整性包括触发器和存储过程等。</p><p>3、SQL Server 实现数据完整性的具体方法有4种：约束、缺省、规则和触发器。</p><p>（1）SQL约束类型――效率高可在定义、修改表语句中定义。</p><p>约束是通过限制列中的数据、行中的数据和表之间数据来保证数据完整性的方法：</p><p>（2）缺省和规则――――功能较低开支大</p><p>​缺省（DEFAULT）和规则（RULE）都是数据库对象。当它们被创建后，可以绑定到一列或几列上，并可以反复使用。</p><p>（3）触发器——高功能高开支的数据完整性方法</p><p>​①Inserted和deleted表</p><p>​当触发器被执行时，SQL Server创建一个或两个临时表（Inserted或者deleted 表）。当一个记录插入到表中时，相应的插入触发器创建一个inserted表,该表镜像该触发器相连接的表的列结构。</p><p>​②Update()函数</p><p>​Update（）函数只在插入和更新触发器中可用，它确定用户传递给它的列是否已经被引起触发器激活的insert或update语句所作用。</p><p> <strong>过程数据完整性：</strong>通过使用脚本语言（主语言或TransactSOL）定义，系统在执行这些语言时强制完整性实现。过程数据完整性包括触发器和存储过程等。</p><h2 id="8-5-数据库的安全性"><a href="#8-5-数据库的安全性" class="headerlink" title="8.5 数据库的安全性"></a>8.5 数据库的安全性</h2><h3 id="8-5-1-安全性级别"><a href="#8-5-1-安全性级别" class="headerlink" title="8.5.1 安全性级别"></a>8.5.1 安全性级别</h3><p>定义：是指保护DB，防止不合法的使用，以免数据的泄漏、非法更改和破坏。</p><p>安全性级别：设置安全措施所牵涉的层次。分成环境级、职员级、OS级、网络级和DBS级等五个级别。这里只讨论DBS级的安全性问题。</p><h3 id="8-5-2-权限"><a href="#8-5-2-权限" class="headerlink" title="8.5.2 权限"></a>8.5.2 权限</h3><p>权限的授予、转授与回收</p><p>​授权 可根据需要把在某对象上的某些权限授予特定的用户。</p><p>​转授 若拥有转授权，则允许把已获得的权限再转授给其他用户。</p><p>​回收 也可以撤消已授给某用户的某些权限。</p><p>权限的种类：读、插入、修改、删除</p><h3 id="8-5-3-安全性和授权"><a href="#8-5-3-安全性和授权" class="headerlink" title="8.5.3 安全性和授权"></a>8.5.3 安全性和授权</h3><p>安全性由两个机制提供：视图和授权子系统。</p><p>视图：视图是虚表，视图机制使DBS具有三个优点：数据安全性、逻辑独立性、用户操作简便性。</p><p>SQL中的用户权限及操作：</p><p>​六类权限：SELECT，INSERT，DELETE，UPDATE，REFERENCES，USAGE。</p><p>​授权（GRANT）语句：将关系和视图操作权授予特定用户</p><p>​回收（REVOKE）语句：回收已授给某用户的权限。</p><p>一般授权是指授予某用户对某数据对象进行某种操作的权利。 在SQL语言中,DBA及拥有权限的用户可用GRANT语句向用户授权。</p><p>​GRANT语句的格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span><span class="operator">&lt;</span>权限表<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>数据库元素<span class="operator">&gt;</span></span><br><span class="line">          <span class="keyword">TO</span><span class="operator">&lt;</span>用户名表<span class="operator">&gt;</span></span><br><span class="line">         [ <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION］； </span><br></pre></td></tr></table></figure><p>其中,&lt;数据库元素&gt;规定了数据对象,如：TABLE student(基本表student)；</p><p>&lt;权限表&gt;规定了可以对&lt;数据库元素&gt;所执行的操作,如：SELECT,UPDATE &lt;用户名表&gt;规定了得到权力的用户的用户标识符。</p><p>WITH GRANT OPTION的意义：<br>    如果在GRANT语句中选择了WITH GRANT OPTION的子句,则获得规定权限的用户不仅自己可以执行这些操作,还获得了用GRANT语句把这些权限授予其他用户的权限； 如果在GRANT语句中未选择此子句,则获得规定权限的用户仅仅只能自己执行这些操作,不能传播这些权限。</p><p>用一般授权格式GRANT授出的权限者（及DBA）可用对应格式REVOKE语句收回之。 此REVOKE语句的格式为：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="operator">&lt;</span>权限表<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>数据库元素<span class="operator">&gt;</span></span><br><span class="line">         <span class="keyword">FROM</span><span class="operator">&lt;</span>用户名表<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>本语句将把FROM子句指定的所有用户,［对ON子句指定的数据对象］所具有的&lt;权限表&gt;全部收回。</p><p>(1) 只有使用GRANT授出了权限的用户（及DBA）才能使用本语句收回自己授出去的权限。</p><p>(2) 若&lt;用户名表&gt; 中,有些用户还把所授出的权限授予其他用户（因为当授权时，带有WITH GRANT OPTION子句）,则间接收到此权限的用户也自动被收回了这些权限。</p><p>例1: 把对关系S的查询、修改权限授给用户WANG，并且WANG还可以把这些权限转授给其他用户:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span> <span class="keyword">ON</span> S <span class="keyword">TO</span> WANG</span><br><span class="line"></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION</span><br></pre></td></tr></table></figure><p>例2:允许用户BAO建立新关系，并可以引用关系C的主键CNO作为新关系的外键，并有转让权限。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REFERENCES</span> (CNO) <span class="keyword">ON</span> C <span class="keyword">TO</span> BAO</span><br><span class="line"></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION</span><br></pre></td></tr></table></figure><p>例3:从用户WANG连锁回收对关系S的查询、修改权限。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span> <span class="keyword">ON</span> S <span class="keyword">FROM</span> WANG CASCADE </span><br></pre></td></tr></table></figure><h3 id="8-5-4-数据加密"><a href="#8-5-4-数据加密" class="headerlink" title="8.5.4 数据加密"></a>8.5.4 数据加密</h3><p>数据加密 数据存储和传输时采用加密技术。</p><p>数据是存储在介质上的,数据还经常通过通信线路传输。 敌手既可在介质上窃取数据,也可在通信线路上窃听到数据,有时,跟踪审计的日志文件中也找不到敌手的踪影。 对敏感的数据进行加密储存是防止数据泄露的有效手段。 原始的数据（称为明文Plain text）在加密密钥的作用下,通过加密系统加密成密文（Cipher text）。 明文是大家都看得懂的数据,一旦失窃,后果严重。</p><p>但密文是谁也看不懂的数据,只有掌握解密密钥的人，才能在解密密钥的帮助下,由解密系统解密成明文。 因此,单单窃得密文数据是没有用处的。</p><p>数据加、 解密的代价也不小。 因此,实际DBMS往往把加密特性作为一种可选功能,由用户决定是否选用。 如果选用了加密功能,用户必须要保管好自己的加密密钥和解密密钥,不能失去或泄露。</p><p>失去密钥,则自己都无法知道密文的真实内容。 泄露密钥,则还不如不采用加密功能,采用一个不安全的加密系统,还不如采用一个不加密的系统来得安全。</p><p>数据的安全性和完整性是两个不同的概念。 数据的安全性是防止数据库被恶意破坏和非法存取,而数据完整性是为了防止错误信息的输入,保证数据库中的数据符合应用环境的语义要求。 安全性措施的防范对象是非法用户和非法操作,而完整性措施的防范对象是不合语义的数据。</p><h3 id="8-5-5-自然环境的安全性"><a href="#8-5-5-自然环境的安全性" class="headerlink" title="8.5.5 自然环境的安全性"></a>8.5.5 自然环境的安全性</h3><p>DBS的设备、硬件和环境的安全性。</p><h1 id="第10章-对象关系数据库"><a href="#第10章-对象关系数据库" class="headerlink" title="第10章 对象关系数据库"></a>第10章 对象关系数据库</h1><p>新一代DBS的两条途径：ORDBS和OODBS</p><p>本章概念：</p><p>平面关系模型，嵌套关系模型，复合对象模型，引用类型</p><p>对象联系图的成分及表示方法，数据的泛化&#x2F;细化</p><p>ORDB的定义语言：数据类型、继承性、引用类型的定义</p><p>ORDB的查询语言：路径表达式、嵌套与解除嵌套。</p><p><strong>数据库技术发展的三个演变过程：</strong></p><ol><li><p>数据模型的演变过程</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220524164801224.png" alt="image-20220524164801224"></p></li><li><p>查询语言的演变</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220524164816296.png" alt="image-20220524164816296"></p></li><li><p>概念建模的演变</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220524164830083.png" alt="image-20220524164830083"></p></li></ol><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220524164907007.png" alt="image-20220524164907007"></p><h2 id="10-1-对象联系图"><a href="#10-1-对象联系图" class="headerlink" title="10.1 对象联系图"></a>10.1 对象联系图</h2><h3 id="10-1-1-三种模型的表示"><a href="#10-1-1-三种模型的表示" class="headerlink" title="10.1.1 三种模型的表示"></a>10.1.1 三种模型的表示</h3><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220524165400466.png" alt="image-20220524165400466"></p><p>例：在教育系统中,大学(University)与教师 (Faculty) 组成了嵌套关系：</p><p>University ( uno, uname, city, Staff (fno，fname，age ))属性Staff是一个关系类型，表示一所大学中的所有教师。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220524165138685.png" alt="image-20220524165138685"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220524165200804.png" alt="image-20220524165200804"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220524165220106.png" alt="image-20220524165220106"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220524165243315.png" alt="image-20220524165243315"></p><h3 id="10-1-2-引用类型"><a href="#10-1-2-引用类型" class="headerlink" title="10.1.2 引用类型"></a>10.1.2 引用类型</h3><p>嵌套关系和复合对象的明显弱点是：无法表达递归的结构，类型定义不允许递归。</p><p><strong>采用“引用”技术解决类型定义中的递归问题。</strong> </p><p>​在属性的类型中，除了基本数据类型、元组类型、关系类型外，</p><p> 还可以出现“引用类型”。引用类型相当于程序设计中指针的概念，在面向对象技术中称为“对象标识”。</p><h3 id="10-1-3-对象联系图的成分"><a href="#10-1-3-对象联系图的成分" class="headerlink" title="10.1.3 对象联系图的成分"></a>10.1.3 对象联系图的成分</h3><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220524165711126.png" alt="image-20220524165711126"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220524165726420.png" alt="image-20220524165726420"></p><h3 id="10-1-4-数据的细化-x2F-泛化"><a href="#10-1-4-数据的细化-x2F-泛化" class="headerlink" title="10.1.4 数据的细化&#x2F;泛化"></a>10.1.4 数据的细化&#x2F;泛化</h3><p>数据的泛化／细化：对概念之间联系进行抽象的一种方法。</p><p>“泛化”：称较高层上抽象是较低层上抽象的“泛化”。（在较低层上抽象表达与之联系的较高层上的抽象）</p><p> “细化”：称较低层上抽象是较高层上抽象的“细化”。这种细化联系是一种“是”（is a）的联系。</p><p>在有泛化／细化联系的对象类型之间：</p><p>​较高层的对象类型称为“超类型”（supertype），较低层的对象类型称为“子类型”（subtype）。</p><p>​子类具有继承性,继承超类的特征,而子类本身又有其它的特征。</p><p>泛化&#x2F;细化联系用泛化边(双线箭头)表示,泛化边从子类指向超类。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220524170029117.png" alt="image-20220524170029117"></p><h2 id="10-2-面向对象的类型系统"><a href="#10-2-面向对象的类型系统" class="headerlink" title="10.2 面向对象的类型系统"></a>10.2 面向对象的类型系统</h2><p>一、基本数据类型:整型、浮点型、字符型、字符串、布尔型和枚举型；</p><p>二、复合类型：复合类型有下列五种：</p><ol><li>结构（或行）类型：不同类型元素的有序集合称为结构。</li><li>数组类型：同类元素的有序集合，称为数组（array）。</li><li>包(多集)类型：同类元素的无序集合并且允许有重复的元素。</li><li>集合类型：相同类型元素的无序集合，并且所有的元素必须是不同的（set）。</li><li>列表类型：类型相同并且允许有重复的元素的有序集合。</li></ol><p>复合类型中: 数组、列表、包、集合统称为聚集类型。</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531151000616.png" alt="image-20220531151000616"></p><p> 数据类型可以嵌套。</p><p>例： 课程成绩集{(MATHS,80),(PHYSICS,90),(PL,70),(OS,80),(DB,80)}外层是集合类型，里层是结构类型。</p><p> 三、引用类型</p><p>数据类型的定义只能嵌套，若要允许递归，就要前面提到的引用类型</p><h2 id="10-3-ORDB的定义语言"><a href="#10-3-ORDB的定义语言" class="headerlink" title="10.3 ORDB的定义语言"></a>10.3 ORDB的定义语言</h2><p>一、ORDB的定义:</p><p>在传统的关系数据模型基础上，提供元组、数组、集合一类丰富的数据类型以及处理新的数据类型操作的能力，并且有继承性和对象标识等面向对象特点。</p><p>二、ORDB数据类型的定义</p><p>在对象关系模型中，属性可以是基本数据类型或复合类型。</p><p>复合类型有下列四种：</p><ol><li>结构类型：不同类型元素的有序集合称为结构。</li><li>数组类型：同类元素的有序集合，称为数组（array）。</li><li>多集类型：同类元素的无序集合（有的成员可多次出现），称为多集（multiset）。</li><li>集合类型：同类元素的无序集合（每个成员只能出现一次），称为集合（set）。</li></ol><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531153324054.png" alt="image-20220531153324054"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531153334584.png" alt="image-20220531153334584"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531153343205.png" alt="image-20220531153343205"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531153351505.png" alt="image-20220531153351505"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531153401849.png" alt="image-20220531153401849"></p><p>三、继承性的定义</p><p>继承性可以发生在类型一级或表一级。</p><ol><li>类型级的继承性：数据类型之间的子类型与超类型的联系。</li></ol><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531153521405.png" alt="image-20220531153521405"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531153533390.png" alt="image-20220531153533390"></p><ol start="2"><li>表的继承性：在表级实现继承性（子表与超表的联系）</li></ol><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531153634431.png" alt="image-20220531153634431"></p><p> 子表和超表应满足下列两个一致性要求：</p><p>​① 超表中每个元组最多可以与每个子表中的一个元组对应。</p><p>​② 子表中每个元组在超表中恰有一个元组对应，并在继承的属性上有相同的值。</p><p>四、引用类型的定义</p><p>数据类型可以嵌套定义，但要实现递归，就要使用“引用”类型。在嵌套引用时，不是引用对象本身的值，是引用对象标识符（即“指针”的概念）。</p><p>引用类型有两种方式：</p><p>1.“ref” 表示引用的是元组的标识符，不是元组值。</p><p>例如，大学中属性“校长”是对教师对象元组标识符的引用：</p><p>​president ref（faculty）</p><p>2.“setof” 表示属性值是集合类型。</p><p>例如：大学中属性“员工”是教师对象的集合：</p><p>staff setof (ref (faculty) ) &#x2F;*对faculty对象的引用的集合*&#x2F;</p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531154123098.png" alt="image-20220531154123098"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531154139511.png" alt="image-20220531154139511"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531154151130.png" alt="image-20220531154151130"></p><h2 id="10-4-ORDB的查询语言"><a href="#10-4-ORDB的查询语言" class="headerlink" title="10.4 ORDB的查询语言"></a>10.4 ORDB的查询语言</h2><p>一、扩充的SQL语言对SELECT语句的使用规定：</p><ol><li>允许用于计算关系的表达式出现在任何关系名可以出现的地方，比如FROM子句或SELECT子句中。这种可自由使用子表达式的能力使得充分利用嵌套关系结构成为可能。</li></ol><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531154306508.png" alt="image-20220531154306508"></p><ol start="2"><li><p>在ORDB中规定要为每个基本表设置一个元组变量，然后才可引用(不允许出现：表名.属性名)，在FROM子句中要为每个关系定义一个元组变量。</p></li><li><p>当属性值为单值或结构值时，属性的引用方式仍和传统的关系模型一样，在层次之间加园点“.”。</p><p>如：检索某大学的校长姓名时，可写成“U.president.fname”，这里U是为关系university设置的元组变量。</p></li><li><p>当路径中某个属性值为集合时，就不能连着写下去，必须定义元组变量。</p></li></ol><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531154448363.png" alt="image-20220531154448363"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531154456206.png" alt="image-20220531154456206"></p><p><img src="/../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.assets/image-20220531154506127.png" alt="image-20220531154506127"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Substance Designer</title>
      <link href="/posts/92515ac0/"/>
      <url>/posts/92515ac0/</url>
      
        <content type="html"><![CDATA[<h1 id="Substance-Designer"><a href="#Substance-Designer" class="headerlink" title="Substance Designer"></a>Substance Designer</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.yutu.cn/">羽兔</a></p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="材质的两个属性"><a href="#材质的两个属性" class="headerlink" title="材质的两个属性"></a>材质的两个属性</h3><p>base color：基本颜色</p><p>normal：法线通道，在不增加面数的情况下，增加更多细节，法线贴图</p><p>roughness：粗糙度，越白越粗糙，越黑越光滑</p><p>metallic：金属度，越黑越塑料，越白越金属</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析</title>
      <link href="/posts/3274548c/"/>
      <url>/posts/3274548c/</url>
      
        <content type="html"><![CDATA[<h1 id="算法设计与分析考试要点"><a href="#算法设计与分析考试要点" class="headerlink" title="算法设计与分析考试要点"></a>算法设计与分析考试要点</h1><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><p>填空题10-12分</p><p>单项选择题20分</p><p>四道综合题70分</p><p>​无简答题，不考概念</p><p>​涉及到算法设计，复杂度、设计算法、推导</p><p>​程序填空</p><p>​手工操作，动态规划递归方程的执行顺序</p><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>复杂度分析，高阶记号，比较两个函数的大小</p><p>NP问题概念</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p><strong>算法设计</strong></p><p><strong>复杂度推导</strong></p><p><strong>递推公式</strong></p><p>循环赛不考</p><p>最接近点对问题不出大题</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>多边形游戏、图像运算、调度不考</p><p>1、动态规划方程写出来</p><p>2、分情况讨论</p><p>可以做一下算法实现题：流水作业调度、十子合并等</p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>贪心策略的证明</p><p><strong>搞清楚贪心策略是什么</strong></p><p>贪心选择策略的复杂度一般是 $ n*log_2n+O(n) $</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p>剪枝策略</p><p>算法填空</p><p>把解空间的数量标注出来</p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>画解空间的树</p><p>遍历次序</p><h1 id="复习整理"><a href="#复习整理" class="headerlink" title="复习整理"></a>复习整理</h1><h2 id="第一章-算法概述"><a href="#第一章-算法概述" class="headerlink" title="第一章 算法概述"></a>第一章 算法概述</h2><h3 id="1-1-算法与程序"><a href="#1-1-算法与程序" class="headerlink" title="1.1 算法与程序"></a>1.1 算法与程序</h3><p>算法定义：是一个有穷规则的集合。这些规则规定了解决某一问题的一个运算序列。</p><p>算法应该具有五个特性：有限性、确定性、输入、输出、可行性  </p><p>输入： 算法开始执行之前指定初始值（有零个或多个输入）<br>输出：产生与输入相关的量（至少有一个）。<br>确定性：每一条规则都是明确、无二义的。<br>有限性：求解问题的运算序列，必须在有限的计算步后停止。<br>可行性：每一计算步都是基本的、可实现的。</p><p>程序定义：程序是算法用某种程序设计语言的具体体现<br>程序&#x3D;算法 + 数据结构（Nicklaus Wirth）<br>程序可以不满足算法的性质(4)有限性。<br>例如：操作系统，是一个在无限循环中执行的程序，因而不是一个算法  </p><h3 id="1-2-算法复杂性分析"><a href="#1-2-算法复杂性分析" class="headerlink" title="1.2 算法复杂性分析"></a>1.2 算法复杂性分析</h3><ol><li>计算机资源：时间、空间</li><li>复杂性：所需资源多少</li><li>算法复杂性：算法运行时所需资源的量</li><li>算法复杂性分析目的： 分析问题复杂性、算法是否可行，选择最好算法</li><li>时间复杂性：所需时间资源的量T(n)</li><li>空间复杂性：所需空间资源的量S(n)</li></ol><p>​其中n是问题的规模（输入大小）</p><p>​时间复杂性细化–3种典型的复杂性：最坏、最好、平均复杂性</p><p>​记T(I)为输入I时的问题的算法复杂性</p><p>P：多项式时间内可解的判定问题</p><p>NP：非确定性多项式时间可解的判定问题，可在多项式时间复杂度内对猜测进行验证</p><p>NPC：多项式时间内可转化为任意NP问题，可视为代表性NP问题</p><h4 id="时间复杂性"><a href="#时间复杂性" class="headerlink" title="时间复杂性"></a>时间复杂性</h4><p>1） 最坏情况下的时间复杂性</p><p>$T_{max}(n) &#x3D; max{ T(I) | size(I)&#x3D;n }$<br>（2） 最好情况下的时间复杂性</p><p>$T_{min}(n) &#x3D; min{ T(I) | size(I)&#x3D;n }$<br>（3） 平均情况下的时间复杂性</p><p>$T_{avg}(n) &#x3D; \sum_{size(I)&#x3D;n} p(I)T(I)$<br>其中I是问题的规模为n的实例， p(I)是实例I出现的概率。  </p><p>(1) 渐近上界记号O<br>$O(g(n)) &#x3D; { f(n) | 存在正常数c和n_0使得对所有n\ge n_0有：<br>0 \le f(n) \le cg(n) }$<br>(2) 渐近下界记号$\Omega$<br>$\Omega (g(n)) &#x3D; { f(n) | 存在正常数c和n_0使得对所有n\ge n_0有：0\le cg(n)\le f(n) }$  </p><p>(3)  高阶记号o<br>$$<br>o(g(n))&#x3D;{f(n)|对于任何正常数c&gt;0,存在正数和n_0 &gt;0使得对所有n\ge n_0有： 0 \le f(n)&lt;cg(n) }<br>$$<br>(4) 同阶记号θ<br>θ(g(n)) &#x3D; { f(n) | 存在正常数$c_1$,$c_2$和$n_0$使得对所有$n\ge n_0$有： $c_1g(n) \le f(n) \le c_2g(n)$}   </p><p>各记号的记忆性比较<br>• f(n)&#x3D; O(g(n)) ≈ f(n)阶不超过g(n)阶<br>• f(n)&#x3D; Ω(g(n)) ≈ f(n)阶以g(n)阶为下界<br>• f(n)&#x3D; θ(g(n)) ≈ f(n)与g(n)等同<br>• f(n)&#x3D; o(g(n)) ≈ f(n)阶小于g(n)</p><h4 id="渐近分析记号的若干性质"><a href="#渐近分析记号的若干性质" class="headerlink" title="渐近分析记号的若干性质"></a>渐近分析记号的若干性质</h4><p>1）传递性：<br>f(n)&#x3D; θ(g(n))， g(n)&#x3D; θ(h(n)) &#x3D;&gt; f(n)&#x3D; θ(h(n))；<br>f(n)&#x3D; O(g(n))， g(n)&#x3D; O (h(n)) &#x3D;&gt; f(n)&#x3D; O (h(n))；<br>f(n)&#x3D; Ω(g(n))， g(n)&#x3D; Ω (h(n)) &#x3D;&gt; f(n)&#x3D; Ω(h(n))；<br>f(n)&#x3D; o(g(n))， g(n)&#x3D; o(h(n)) &#x3D;&gt; f(n)&#x3D; o(h(n))；  </p><p>2）反身性：<br>f(n)&#x3D; θ(f(n))；<br>f(n)&#x3D; O(f(n))；<br>f(n)&#x3D; Ω(f(n)  </p><p>3）对称性：<br>f(n)&#x3D; θ(g(n)) &lt;&#x3D;&gt; g(n)&#x3D;θ(f(n))</p><p>4）互对称性：<br>f(n)&#x3D; O(g(n)) &lt;&#x3D;&gt; g(n)&#x3D; Ω(f(n))  </p><p>5）算术运算：<br>O(f(n))+O(g(n)) &#x3D; O(max{f(n),g(n)}) ；<br>O(f(n))+O(g(n)) &#x3D; O(f(n)+g(n)) ；<br>O(f(n))*O(g(n)) &#x3D; O(f(n)*g(n)) ；<br>O(cf(n)) &#x3D; O(f(n)) ； C是正常数<br>g(n)&#x3D; O(f(n)) &#x3D;&gt; O(f(n))+O(g(n)) &#x3D; O(f(n))   </p><h2 id="第二章-递归和分治"><a href="#第二章-递归和分治" class="headerlink" title="第二章 递归和分治"></a>第二章 递归和分治</h2><p>$T(N) &#x3D; aT(N&#x2F;b)+N^k$</p><p> <img src="/../images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90.assets/image-20211113192239362.png" alt="image-20211113192239362"></p><h2 id="第三章-动态规划"><a href="#第三章-动态规划" class="headerlink" title="第三章 动态规划"></a>第三章 动态规划</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/posts/e255a10a/"/>
      <url>/posts/e255a10a/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><h2 id="1-1-计算机网络概述"><a href="#1-1-计算机网络概述" class="headerlink" title="1.1 计算机网络概述"></a>1.1 计算机网络概述</h2><p>计算机网络定义：由一些通用的、可编程的硬件互连而成的。</p><p>“可编程的硬件”表明这种硬件一定包含有中央处理器 (CPU)  </p><p>由若干结点(node)和连接这些结点的链路(link)组成</p><p>21世纪重要特征：数字化、网络化、信息化，它是一个以网络为核心的信息时代</p><p>三大类网络：电信网络、有线电视网络、计算机网络</p><p>随着技术发展，网络技术互相融合——三网融合</p><h2 id="1-2-互联网概述"><a href="#1-2-互联网概述" class="headerlink" title="1.2 互联网概述"></a>1.2 互联网概述</h2><p>互联网重要基本特点：连通性和共享</p><p>互联网+：把互联网的创新成果深度融合于经济社会各领域之中</p><p>网络把许多计算机连接在一起</p><p>互联网把许多网络通过路由器连接在一起</p><p>与网络相连的计算机常称为主机</p><h3 id="互联网基础结构发展的三个阶段"><a href="#互联网基础结构发展的三个阶段" class="headerlink" title="互联网基础结构发展的三个阶段"></a>互联网基础结构发展的三个阶段</h3><p>第一阶段：单个网络APRANET向互联网发展的过程</p><p>第二阶段：建成三级结构的互联网</p> <img src="../images/计算机网络.assets/image-20211112135352228.png" alt="image-20211112135352228" style="zoom:50%;" /><p>第三阶段：形成多层次ISP结构的互联网，出现了互联网服务提供者ISP(Internet Service Provider)<br>    根据覆盖面积大小以及所拥有的IP地址数目的不同，ISP分为主干ISP、地区ISP、本地ISP</p><p>　<img src="../images/计算机网络.assets/image-20211112135714388.png" alt="image-20211112135714388" style="zoom:50%;" /></p><h2 id="1-3-互联网的组成"><a href="#1-3-互联网的组成" class="headerlink" title="1.3 互联网的组成"></a>1.3 互联网的组成</h2><p>从工作方式可分为两大块：</p><p>1、边缘部分：由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。  </p><p>2、核心部分：由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。  </p><h3 id="1-3-1-边缘部分"><a href="#1-3-1-边缘部分" class="headerlink" title="1.3.1 边缘部分"></a>1.3.1 边缘部分</h3><p>互联网边缘的部分就是连接在互联网上的所有的主机，这些主机又被称为端系统。</p><p>端系统可以是PC、智能手机、网络摄像头、大型计算机等等</p><p>计算机之间的通信：主机A的某个进程（程序）和主机B上的另一个进程（程序）进行通信</p><h4 id="端系统之间通信方式"><a href="#端系统之间通信方式" class="headerlink" title="端系统之间通信方式"></a>端系统之间通信方式</h4><h5 id="客户-服务器方式（C-x2F-S-方式）"><a href="#客户-服务器方式（C-x2F-S-方式）" class="headerlink" title="客户-服务器方式（C&#x2F;S 方式）"></a>客户-服务器方式（C&#x2F;S 方式）</h5><p>客户 (client) 和 服务器 (server) 都是指通信中所涉及的两个应用进程。  </p><p>客户是服务的请求方，服务器是服务的提供方。服务请求方和服务提供方都要使用网络核心部分所提供的服务。</p><p>客户软件的特点：</p><p>​被用户调用后运行， 在打算通信时主动向远地服务器发起通信（请求服务）。 因此，客户程序必须知道服务器程序的地址。<br>​不需要特殊的硬件和很复杂的操作系统。  </p><p>服务器软件的特点：</p><p>​一种专门用来提供某种服务的程序， 可同时处理多个远地或本地客户的请求。<br>​系统启动后动调即自用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。<br>​一般需要强大的硬件和高级的操作系统支持。</p><p>​客户与服务器的通信关系建立后， 通信可以是双向的， 客户和服务器都可发送和接收数据。  </p><h5 id="对等方式（P2P-方式）"><a href="#对等方式（P2P-方式）" class="headerlink" title="对等方式（P2P 方式）"></a>对等方式（P2P 方式）</h5><p>只要两个主机都运行了对等连接软件 (P2P 软件) ，它们就可以进行平等的、对等连接通信。<br>双方都可以下载对方已经存储在硬盘中的共享文档。</p><p>对等连接方式从本质上看仍然是使用客户服务器方式，只是对等连接中的每一个主机既是客户又是服务器。 </p><h3 id="1-3-2-核心部分"><a href="#1-3-2-核心部分" class="headerlink" title="1.3.2 核心部分"></a>1.3.2 核心部分</h3><p>提供连通性</p><p>路由器在核心部分中起特殊作用</p><p>路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。  </p><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>两部电话机之间需要1对电线直接连接</p><p>N 部电话机两两直接相连，需 N(N – 1)&#x2F;2 对电线。 这种直接连接方法所需要的电线对的数量与电话机数量的平方 成正比。  </p> <img src="../images/计算机网络.assets/image-20211025083428059.png" alt="image-20211025083428059" style="zoom:33%;" /><p>使用交换机：</p> <img src="../images/计算机网络.assets/image-20211025083458097.png" alt="image-20211025083458097" style="zoom:33%;" /><p>每一部电话都直接连接到交换机上，而交换机使用交换的方法，让电话用户彼此之间可以很方便地通信。所采用的交换方式就是电路交换 (circuit switching)。  </p><p>交换：转接，把一条电话线转接到另一条电话线。照某种方式动态分配传输线路的资源</p><p>电路交换必定是面向连接的</p><p>过程：</p><p>​建立连接：建立一条专用的物理通路，保证通话时资源不被占用</p><p>​通话：占用通信资源</p><p>​释放连接：释放占用的所有通信资源</p><p>缺点：突发性、线路利用率低</p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>采用存储转发技术</p><p>步骤：</p><p>1、在发送端，先把较长的报文划分成较短的固定长度的数据段</p><p>2、每一个数据段前面添加上首部（包头）构成分组（包）</p><p>3、以”分组“作为数据传输单元，依次把各分组发送到接收端</p><p>分组首部：含有地址等控制信息</p><p>每个分组独立选择传输路径</p><p>核心部分中的路由器之间一般由高速链路连接</p><p>边缘部分的主机接入到核心部分以相对较低速率的链路连接</p><p>主机的用途：为用户处理信息</p><p>路由器的用途：分组交换</p><p>路由器处理分组的过程：<br>    把收到的分组先放入缓存（暂时存储）；<br>    查找转发表， 找出到某个目的地址应从哪个端口转发；<br>    把分组送到适当的端口转发出去。  </p><table><thead><tr><th align="center">优点</th><th align="center">所采用的手段</th></tr></thead><tbody><tr><td align="center">高效</td><td align="center">在分组传输的过程中动态分配传输带宽，对通信链路逐段占用</td></tr><tr><td align="center">灵活</td><td align="center">为每一个分组独立选择最合适的转发路由</td></tr><tr><td align="center">迅速</td><td align="center">以分组作为传送单位，可以不先建立连接就能向其他主机发送分组</td></tr><tr><td align="center">可靠</td><td align="center">保证可靠性的网络协议</td></tr></tbody></table><p>问题：</p><p>​分组在个结点存储转发时需要排队，造成一定时延</p><p>​分组必须携带首部，造成一定开销</p><img src="../images/计算机网络.assets/image-20211025092409600.png" alt="image-20211025092409600" style="zoom:67%;" /><p>若要连续传送大量的数据，且其传送时间远大于连接建立时间，则电路交换的传输速率较快。<br>报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。<br>由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性  </p><h2 id="1-4-计算机网络的类别"><a href="#1-4-计算机网络的类别" class="headerlink" title="1.4 计算机网络的类别"></a>1.4 计算机网络的类别</h2><h2 id="1-5-计算机网络的类别"><a href="#1-5-计算机网络的类别" class="headerlink" title="1.5 计算机网络的类别"></a>1.5 计算机网络的类别</h2><h3 id="按照网络作用范围分类"><a href="#按照网络作用范围分类" class="headerlink" title="按照网络作用范围分类"></a>按照网络作用范围分类</h3><p>广域网 WAN (Wide Area Network)： 作用范围通常为几十到几千公里（跨越国家），是互联网的核心部分。<br>城域网 MAN (Metropolitan Area Network)： 作用距离约为 5 ~ 50 公里（几个街区甚至整个城市）。<br>局域网 LAN (Local Area Network) ： 局限在较小的范围（如 1 公里左右） ，校园网或企业网。<br>个人区域网 PAN (Personal Area Network) ： 范围很小，大约在 10 米左右，通过无线技术连接。<br>若中央处理机之间的距离非常近（如仅1米的数量级甚至更小些），则一般就称之为多处理机系统， 而不称它为计算机网络。  </p><h3 id="按照网络的使用者分类"><a href="#按照网络的使用者分类" class="headerlink" title="按照网络的使用者分类"></a>按照网络的使用者分类</h3><p>公用网 (public network)<br>    电信公司建造的大型网络。按规定交纳费用的人都可以使用的网络。因此也可称为公众网。<br>专用网 (private network)<br>    某个单位为特殊业务工作的需要而建造的网络，例如军队、铁路、银行、电力等系统。<br>公用网和专用网都可以提供多种服务。如传送的是计算机数据，则分别是公用计算机网络和专用计算机网络。  </p><h3 id="用来把用户接入到互联网的网络"><a href="#用来把用户接入到互联网的网络" class="headerlink" title="用来把用户接入到互联网的网络"></a>用来把用户接入到互联网的网络</h3><p>接入网AN(Access Network)，它又称为本地接入网或居民接入网  </p><p>起到让用户能够与互联网连接的“桥梁”作用  </p><p>接入网技术：电话线拨号、宽带</p><p>不属于互联网的核心和边缘部分</p><p>接入网是从某个用户端系统到互联网中的第一个路由器（也称为边缘路由器）之间的一种网络。</p><p>从覆盖的范围看，很多接入网还是属于局域网。  </p><h2 id="1-6-计算机网络的性能"><a href="#1-6-计算机网络的性能" class="headerlink" title="1.6 计算机网络的性能"></a>1.6 计算机网络的性能</h2><h3 id="1-6-1-计算机网络的性能指标"><a href="#1-6-1-计算机网络的性能指标" class="headerlink" title="1.6.1 计算机网络的性能指标"></a>1.6.1 计算机网络的性能指标</h3><p>主要包括：速率、带宽、吞吐率、时延、时延带宽积、往返时间RTT、利用率</p><h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><p>数据的传送速率，也成为数据率、比特率</p><p>单位：bit&#x2F;s, kbit&#x2F;s, Mbit&#x2F;s, Gbit&#x2F;s</p><p>速率往往是指指定速率或标称速率，非实际运行速率</p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><p>本来指信号具有的频带宽度，单位赫(Hz)</p><p>计算机网络中，带宽表示网络中某通道传送数据的能力，即单位时间内网络中的某信道所能通过的”最高数据率”，单位bit&#x2F;s</p><p>在带宽的上述两种表示中，前者为频域称谓，后者为时域称谓，本质相同。</p><p>一条通信链路的带宽越宽，最高数据率越高。</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>在单位时间内通过某个网络(或信道、接口)的数据量</p><p>吞吐量受网络的带宽或网络的额定速率的限制</p><p>表示单位时间实际传输数据量</p><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p>数据(一个报文或分组，甚至比特)从网络(或链路)的一端传送到另一端所需的时间，单位s</p><p>别称：延迟、迟延</p><p>网络中时延由以下几个不同部分组成：1、发送时延，2、传播时延，3、处理时延，4、排队时延</p><h5 id="发送时延"><a href="#发送时延" class="headerlink" title="发送时延"></a>发送时延</h5><p>别称：传输时延</p><p>发送数据时，数据帧从结点进入到传输媒体所需要的时间</p><p>即从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕的时间</p> <img src="../images/计算机网络.assets/image-20211027082407899.png" alt="image-20211027082407899" style="zoom:50%;" /><h5 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h5><p>电磁波在信道中需要传播一定的距离而花费的时间</p><p>电磁波在自由空间的传播速率是光速</p> <img src="../images/计算机网络.assets/image-20211027082713501.png" alt="image-20211027082713501" style="zoom:50%;" /><h5 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h5><p>主机或路由器在收到分组时，为处理分组所花费的时间</p><h5 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h5><p>分组在路由器输入、输出队列中排队等待处理所经过的时间</p><p>排队时延的长短往往取决于网络中当时的通信量</p><p>队列溢出时，相当于排队时延无限大</p><h5 id="总时延"><a href="#总时延" class="headerlink" title="总时延"></a>总时延</h5><p>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 + 排队时延</p> <img src="../images/计算机网络.assets/image-20211027083752130.png" alt="image-20211027083752130" style="zoom:50%;" /><p>对于告诉网络链路，我们提高的仅仅是发送速率而不是传输速率</p><h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><p>别称：以比特为单位的链路长度</p><p>时延带宽积 &#x3D; 传播时延 * 带宽</p> <img src="../images/计算机网络.assets/image-20211027085754531.png" alt="image-20211027085754531" style="zoom:33%;" /><h4 id="往返时间-RTT-Round-Trip-Time"><a href="#往返时间-RTT-Round-Trip-Time" class="headerlink" title="往返时间 RTT(Round-Trip Time)"></a>往返时间 RTT(Round-Trip Time)</h4><p>从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间</p><p>互联网中，RTT还包括各中间结点的处理时延、排队时延以及转发数据时的发送时延</p><p>使用卫星通信时，RTT相对较长，是很重要的一个性能指标</p><p>　<img src="../images/计算机网络.assets/image-20211027090258944.png" alt="image-20211027090258944" style="zoom:33%;" /></p><h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p>分为信道利用率和网络利用率</p><p>信道利用率：某信道有百分之几的时间是被利用的(有数据通过)，完全空闲的信道的利用率是零。</p><p>网络利用率：全网络的信道利用率的加权平均值</p><p>信道利用率并非越高越好，某信道的利用率增大，该信道引起的时延增加</p><h5 id="时延与网络利用率的关系"><a href="#时延与网络利用率的关系" class="headerlink" title="时延与网络利用率的关系"></a>时延与网络利用率的关系</h5> <img src="../images/计算机网络.assets/image-20211027090652813.png" alt="image-20211027090652813" style="zoom:33%;" /> <img src="../images/计算机网络.assets/image-20211027090718809.png" alt="image-20211027090718809" style="zoom:33%;" /><h3 id="1-6-2-计算机网络的非性能特征"><a href="#1-6-2-计算机网络的非性能特征" class="headerlink" title="1.6.2 计算机网络的非性能特征"></a>1.6.2 计算机网络的非性能特征</h3><p>费用、质量、标准化、可靠性、可扩展性和可升级性、易于管理和维护</p><h2 id="1-7-计算机网络的体系结构"><a href="#1-7-计算机网络的体系结构" class="headerlink" title="1.7 计算机网络的体系结构"></a>1.7 计算机网络的体系结构</h2><h3 id="国际标准"><a href="#国际标准" class="headerlink" title="国际标准"></a>国际标准</h3><p>开放系统互联参考模型 OSI&#x2F;RM  (Open Systems Interconnection Reference Model)</p><p>TCP&#x2F;IP</p><h3 id="协议与划分层次"><a href="#协议与划分层次" class="headerlink" title="协议与划分层次"></a>协议与划分层次</h3><p>计算机网络中的数据交换必须遵守事先约定好的规则。<br>这些规则明确规定了所交换的数据的格式以及有关的同步问题（同步含有时序的意思）。<br>网络协议 (network protocol)，简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。</p><h4 id="网络协议的三个组成要素"><a href="#网络协议的三个组成要素" class="headerlink" title="网络协议的三个组成要素"></a>网络协议的三个组成要素</h4><p>语法：数据与控制信息的结构或格式</p><p>语义：需要发出何种控制信息，完成何种动作以及做出何种响应</p><p>同步：时间实现顺序的详细说明</p><h4 id="协议的两种形式"><a href="#协议的两种形式" class="headerlink" title="协议的两种形式"></a>协议的两种形式</h4><p>for people：文字描述</p><p>for computers：程序代码</p><p>目的：对网络上信息交换过程做出精确的解释</p><h4 id="网络协议各层主要功能"><a href="#网络协议各层主要功能" class="headerlink" title="网络协议各层主要功能"></a>网络协议各层主要功能</h4><p>① 差错控制： 使相应层次对等方的通信更加可靠。<br>② 流量控制： 发送端的发送速率必须使接收端来得及接收，不要太快。<br>③ 分段和重装 ： 发送端将要发送的数据块划分为更小的单位，在接收端将其还原。<br>④ 复用和分用： 发送端几个高层会话复用一条低层的连接，在接收端再进行分用。<br>⑤ 连接建立和释放： 交换数据前先建立一条逻辑连接，数据传送结束后释放连接。  </p><h4 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h4><p>计算机网络的体系结构 (architecture) 是计算机网络的各层及其协议的集合。<br>体系结构就是这个计算机网络及其部件所应完成的功能的精确定义。<br>实现 (implementation) 是遵循这种体系结构的前提下用何种硬件或软件完成这些功能的问题。<br>体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件。  </p><h3 id="1-7-3-具有五层协议的体系结构"><a href="#1-7-3-具有五层协议的体系结构" class="headerlink" title="1.7.3 具有五层协议的体系结构"></a>1.7.3 具有五层协议的体系结构</h3><p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。<br>TCP&#x2F;IP 是四层体系结构：应用层、运输层、网际层和网络接口层。但最下面的网络接口层并没有具体内容。<br>因此往往采取折中的办法，即综合 OSI 和TCP&#x2F;IP 的优点，采用一种只有五层协议的体系结构。  </p> <img src="../images/计算机网络.assets/image-20211027092726945.png" alt="image-20211027092726945" style="zoom:33%;" /><h4 id="五层协议的体系结构"><a href="#五层协议的体系结构" class="headerlink" title="五层协议的体系结构"></a>五层协议的体系结构</h4><p>应用层 (application layer)<br>    通过应用进程间的交互来完成特定网络应用<br>    如 域名系统DNS，万维网HTTP协议，电子邮件SMTP协议<br>运输层 (transport layer)<br>    向两台主机中进程之间的通信提供通用的数据传输服务<br>    传输控制协议TCP、用户数据报协议UDP<br>网络层 (network layer)<br>    为分组交换网上的不同主机提供通信服务；选择合适的路由<br>    网际协议IP和路由选择协议<br>数据链路层 (data link layer)<br>    两个相邻节点之间传送数据<br>物理层 (physical layer)<br>    传输数据单位为比特，要考虑多大的电压代表1或0<br>    不包含物理媒介  </p><h4 id="OSI七层协议的体系结构"><a href="#OSI七层协议的体系结构" class="headerlink" title="OSI七层协议的体系结构"></a>OSI七层协议的体系结构</h4><p>应用层<br>    网络服务与最终用户的一个借口<br>    如域名系统DNS，万维网HTTP，电子邮件SMTP<br>表示层<br>    数据的表示、安全、压缩<br>    把应用层提供的信息变换为能够共同理解的形式，提供字符代码、数据格式、控制信息格式、加密等的统一表示。表示层仅对应用层信息内容的形式进行变换，而不改变其内容本身。<br>会话层<br>    建立、管理、终止会话<br>    对应主机进程，指本地主机与远程主机正在进行的会话<br>    依靠传输层以下的通信功能使数据传送功能在开放系统间有效地进行  </p><h4 id="主机1向主机2发送数据"><a href="#主机1向主机2发送数据" class="headerlink" title="主机1向主机2发送数据"></a>主机1向主机2发送数据</h4><p>主机1：</p><p>应用进程数据先传送到应用层<br>    加上应用层首部，成为 应用层 PDU<br>        PDU (Protocol Data Unit)：协议数据单元。<br>        OSI 参考模型把对等层次之间传送的数据单位称为该层的协议数据单元 PDU。  </p><p>应用层 PDU 再传送到运输层<br>    加上运输层首部，成为运输层报文  </p><p>运输层报文再传送到网络层<br>    加上网络层首部，成为 IP 数据报（或分组）  </p><p>IP 数据报再传送到数据链路层<br>    加上链路层首部和尾部，成为数据链路层帧  </p><p>数据链路层帧再传送到物理层<br>    最下面的物理层把比特流传送到物理媒体  </p><p>电信号（或光信号）在物理媒体中传播<br>    从发送端物理层传送到接收端物理层  </p><p>主机2：</p><p>物理层接收到比特流，上交给数据链路层  </p><p>数据链路层剥去帧首部和帧尾部，取出数据部分，上交给网络层  </p><p>网络层剥去首部，取出数据部分，上交给运输层  </p><p>运输层剥去首部，取出数据部分，上交给应用层  </p><p>应用层剥去首部，取出应用程序数据，上交给应用进程  </p> <img src="../images/计算机网络.assets/image-20211027093552000.png" alt="image-20211027093552000" style="zoom:33%;" /><p>OSI 参考模型把对等层次之间传送的数据单位称为该层的协议数据单元 PDU (Protocol Data Unit)。这个名词现已被许多非 OSI 标准采用。<br>任何两个同样的层次把数据（即数据单元加上控制信息）通过水平虚线直接传递给对方。这就是所谓的“对等层” (peer layers)之间的通信。<br>各层协议实际上就是在各个对等层之间传递数据时的各项规定。</p><h3 id="1-7-4-实体、协议、服务和服务访问点"><a href="#1-7-4-实体、协议、服务和服务访问点" class="headerlink" title="1.7.4 实体、协议、服务和服务访问点"></a>1.7.4 实体、协议、服务和服务访问点</h3><h4 id="实体-entity-表示任何可发送或接受信息的硬件或软件进程"><a href="#实体-entity-表示任何可发送或接受信息的硬件或软件进程" class="headerlink" title="实体(entity)表示任何可发送或接受信息的硬件或软件进程"></a>实体(entity)表示任何可发送或接受信息的硬件或软件进程</h4><h4 id="协议是控制两个对等实体进行通信的规则的集合"><a href="#协议是控制两个对等实体进行通信的规则的集合" class="headerlink" title="协议是控制两个对等实体进行通信的规则的集合"></a>协议是控制两个对等实体进行通信的规则的集合</h4><p>​语法规则定义了信息的格式，语义规则定义了发送者或接收者所要完成的操作<br>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。</p><h4 id="要实现本层协议，还需要使用下层所提供的服务。"><a href="#要实现本层协议，还需要使用下层所提供的服务。" class="headerlink" title="要实现本层协议，还需要使用下层所提供的服务。"></a>要实现本层协议，还需要使用下层所提供的服务。</h4><p>协议的实现保证了能够向上一层提供服务</p><p>本层的服务用户只能看见服务而无法看见下层的协议，下面的协议对上面的服务用户是透明的</p><p>协议：水平的，控制对等实体之间通信的规则</p><p>服务：垂直的，服务是由下层向上层通过层间接口提供</p><p>上层使用下层提供的服务必须通过服务原语</p><h4 id="服务访问点"><a href="#服务访问点" class="headerlink" title="服务访问点"></a>服务访问点</h4><p>同一系统相邻两层的实体进行交互的地方，成为服务访问点SAP(Service Access Point)</p><p>服务访问点SAP是一个抽象的概念，实际是一个逻辑接口</p><p>OSI把层与层之间交换数据的单位称为服务数据单元SDU(Service Data Unit)</p><p>SDU可以与PDU不一样，例如：可以是多个SDU合成为一个PDU，也可以是一个SDU划分成为几个PDU</p> <img src="../images/计算机网络.assets/image-20211101091158907.png" alt="image-20211101091158907" style="zoom:50%;" /><h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h1><h2 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h2><p>物理层考虑的是怎样才能在连接计算机的各种传输媒体上传输数据比特流，而不是指具体的传输媒体</p><p>物理层的作用是要尽可能地屏蔽掉不同传输媒体和通信手段的差异，使数据链路层感觉不到这些差异</p><p>用于物理层的协议也常称为物理层规程(procedure)</p><h2 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h2><h3 id="2-2-1-数据通信的基本概念"><a href="#2-2-1-数据通信的基本概念" class="headerlink" title="2.2.1 数据通信的基本概念"></a>2.2.1 数据通信的基本概念</h3><p>通信的目的就是传递信息。</p><p><strong>信源</strong>：一次通信中产生和发送信息的一端</p><p><strong>信宿</strong>：一次通信中接收信息的一端</p><p>信源和信宿之间要有通信线路才能互相通信</p><p><strong>信道</strong>：信源和信宿之间的通信线路</p><h4 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h4><p>**信道(channel)**——一般用来表示向一个方向传送信息的媒体。</p><p>​一条通信电路往往包含发送信道和接收信道。</p><p>**单向通信(单工通信)**——只能有一个方向的通信而没有反方向的交互。<br>    例：无线电广播</p><p>**双向交替通信(半双工通信)**——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)</p><p>**双向同时通信(全双工通信)**——通信的双方可以同时发送和接收信息</p><h4 id="数据通信系统"><a href="#数据通信系统" class="headerlink" title="数据通信系统"></a>数据通信系统</h4><h5 id="源系统"><a href="#源系统" class="headerlink" title="源系统"></a>源系统</h5><p>**源点(信源)**：源点设备产生要传输的数据，例如计算机键盘输入汉字通过计算机产生输出的数字比特流。</p><p><strong>发送器</strong>：数字比特流要经过发送器编码后才能在传输系统中传输，例如：调制器</p><h5 id="传输系统"><a href="#传输系统" class="headerlink" title="传输系统"></a>传输系统</h5><p>传输系统可以是传输线，也可以是复杂的网络系统</p><h5 id="目的系统"><a href="#目的系统" class="headerlink" title="目的系统"></a>目的系统</h5><p>**终点(信宿)**：终点设备将数字比特流转换成信息输出，例如把汉字显示在屏幕上</p><p><strong>接收器</strong>：接收器把来自传输线路上的模拟信号进行解调，还原出数字比特流。例如：解调器</p><h4 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h4> <img src="../images/计算机网络.assets/image-20211101110329013.png" alt="image-20211101110329013" style="zoom:50%;" /><h4 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h4><p>数据在信道中以电信号的形式传送，电信号分为：模拟信号和数字信号</p><p>​模拟信号(analogous signal)：代表信息的参数的取值是连续的</p><p>​数字信号(digital signal)：代表信息的参数的取值是离散的</p><p>​码元(code)：在使用时间域(或简称为时域)的波形表示数字信号时，代表不同离散数值的基本波形</p><p>​使用二进制编码时，只有两种不同的码元(代表0和1)</p><p>数据(data)：运送信息(话音、文字、图像等)的实体</p><p>信号(signal)：数据的电气的或电磁的表现</p><p>调制：把数字信号转换为模拟信号的过程</p><p>解调：把模拟信号转换为数字信号的过程</p><h4 id="模拟的和数字的数据、信号"><a href="#模拟的和数字的数据、信号" class="headerlink" title="模拟的和数字的数据、信号"></a>模拟的和数字的数据、信号</h4> <img src="../images/计算机网络.assets/image-20211101111321866.png" alt="image-20211101111321866" style="zoom:50%;" /> <img src="../images/计算机网络.assets/image-20211101111752727.png" alt="image-20211101111752727" style="zoom:50%;" /><h4 id="有关信道的几个基本概念"><a href="#有关信道的几个基本概念" class="headerlink" title="有关信道的几个基本概念"></a>有关信道的几个基本概念</h4><p>调制&#x2F;解调技术：在计算机提供的二进制数字信号与电话网提供的模拟信号之间进行转换，这类的技术统称为调制&#x2F;解调技术</p><p>基带信号(即基本频带信号)：来自信源的信号，就是将数字信号1或0直接用两种不同的电压来表示，然后送到线路上去传输基带信号</p><p>包含较多低频成分，无法直接在电话网中传输，因为电话网只能提供300~3400Hz的带宽，在发送端将基带信号转换成适合传输的音频信号为调制，在接收端再将音频信号转换成基带信号为解调</p><p><strong>调制分为几大类：</strong></p><p>基带调制：仅对基带信号的波形进行变换，使它能够与信道特性相适应，变换后的信号仍然是基带信号，把这种过程称为编码(coding)</p><p>带通调制：使用载波(carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转移为模拟信号，这样就能够更好地在模拟信道中传输，经过载波调制后的信号称为带通信号。</p><h3 id="2-2-2-数字信号编码"><a href="#2-2-2-数字信号编码" class="headerlink" title="2.2.2 数字信号编码"></a>2.2.2 数字信号编码</h3><h4 id="常用编码方式"><a href="#常用编码方式" class="headerlink" title="常用编码方式"></a>常用编码方式</h4><h5 id="不归零码"><a href="#不归零码" class="headerlink" title="不归零码"></a>不归零码</h5><p>正电平代表1，负电平代表0</p><p>在一个码元的全部时间内，电压保持恒定</p><p>连续发送多个1码和0码时，码元之间没有间隙，不容易区分</p> <img src="../images/计算机网络.assets/image-20211101130630891.png" alt="image-20211101130630891" style="zoom:50%;" /><h5 id="归零码"><a href="#归零码" class="headerlink" title="归零码"></a>归零码</h5><p>正脉冲代表1，负脉冲代表0</p><p>在一个码元的全部时间内，非零电压的持续时间小于一个码元的时间</p><p>在一个码元的后半部分时间内，电压总是归于零的</p><p>好处：解决了不归零码在连续发送“码”或“0”码不容易区分的问题</p> <img src="../images/计算机网络.assets/image-20211101130815200.png" alt="image-20211101130815200" style="zoom:50%;" /><h5 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a>曼彻斯特编码</h5><p>位周期中心的向上跳变代表0，位周期中心的向下跳变代表1，但也可以反过来定义</p><h5 id="差分曼彻斯特编码"><a href="#差分曼彻斯特编码" class="headerlink" title="差分曼彻斯特编码"></a>差分曼彻斯特编码</h5><p>在每一位的中心处始终都有跳变</p><p>利用每个码元的开始时有无跳变来表示0或1</p><p>位开始边界有跳变代表0，没有跳变代表1</p> <img src="../images/计算机网络.assets/image-20211101131102286.png" alt="image-20211101131102286" style="zoom:50%;" /> <img src="../images/计算机网络.assets/image-20211101131642620.png" alt="image-20211101131642620" style="zoom:50%;" /><p>从信号波形中可以看出，曼彻斯特编码和差分曼彻斯特编码产生的信号频率比不归零制高</p><p>从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率(这叫做没有自同步能力)，而曼彻斯特编码和差分曼彻斯特编码具有自同步能力</p><h3 id="2-2-3-数字调制技术"><a href="#2-2-3-数字调制技术" class="headerlink" title="2.2.3 数字调制技术"></a>2.2.3 数字调制技术</h3><p>选取一个适合于在线路上传输的正弦波作为载波，让载波的某些特性(幅度、频率、相位)随基带信号的变化而变化（即波形变换）。</p><h4 id="基本的三种二元制调制方法："><a href="#基本的三种二元制调制方法：" class="headerlink" title="基本的三种二元制调制方法："></a>基本的三种二元制调制方法：</h4><p>​调幅(AM)：载波的振幅随基带数字信号而变化。<br>​调频(FM)： 载波的频率随基带数字信号而变化。<br>​调相(PM)： 载波的初始相位随基带数字信号而变化。  </p> <img src="../images/计算机网络.assets/image-20211103161753091.png" alt="image-20211103161753091" style="zoom:50%;" /><p>调幅(AM)：实现起来简单, 但抗干扰性能差<br>调频(FM)：抗干扰性能好, 但占用带宽较大<br>调相(PM)：抗干扰性能最好，且相位的变化也可以同步发送器和接收器的时钟  </p><p>上述三种调制方式，一个码元仅包含2个状态，即1个码元携带1bit信息<br>想要让1个码元携带多位信息，必须采用多元制混合调制方法</p><h4 id="正交振幅调制QAM-Quadrature-Amplitude-Modulation"><a href="#正交振幅调制QAM-Quadrature-Amplitude-Modulation" class="headerlink" title="正交振幅调制QAM(Quadrature Amplitude Modulation)"></a>正交振幅调制QAM(Quadrature Amplitude Modulation)</h4> <img src="../images/计算机网络.assets/image-20211103164839814.png" alt="image-20211103164839814" style="zoom:50%;" /><h4 id="脉冲编码调制PCM-Pulse-Code-Modulation"><a href="#脉冲编码调制PCM-Pulse-Code-Modulation" class="headerlink" title="脉冲编码调制PCM(Pulse Code Modulation)"></a>脉冲编码调制PCM(Pulse Code Modulation)</h4><p>话音、图像等模拟信号在时间上和取值上都是连续的，对其进行数字信号编码，是将其转换成一系列在时间和取值上都是离散的二进制数码脉冲，最常用的编码方法就是脉冲编码调制 PCM (Pulse Code Modulation)</p><p>现在的数字传输系统均采用脉码调制 PCM 体制。  </p><p>PCM包括三个步骤：采样、量化、编码</p><h5 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h5><p>采样：实现时间上的离散化<br>    方法：每隔一定时间间隔，取模拟信号的当前值作为样本，该样本代表了模拟信号在某一时刻的瞬时值</p><p>采样的依据：奈奎斯特(Nyquist)采样定理<br>    若对连续变化的模拟信号进行周期性的采样，如果采样速率大于模拟信号最高频率的二倍，则可以用得到的样本空间恢复原来的模拟信号，即：</p><img src="../images/计算机网络.assets/image-20211103165909706.png" alt="image-20211103165909706" style="zoom:50%;" /><p>话音信号带宽在0.3~3.4kHz内，采样频率定位8kHz，即采样周期为125μs</p><h5 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h5><p>量化：使采样值在取值上离散化<br>    方法：将原始信号的取值范围划分为若干个等级，即每个采样值“取整”到离它最近的一个等级上。<br>    量化后的抽样信号会有所失真，表现为噪声<br>    离散值的个数(等级划分)决定了量化的精度<br>    我国电话信号的PCM机制中，量化等级为256，即8位</p><h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><p>编码：将量化后的采样值用一定位数的二进制数码来表示<br>    编码的位数和量化的级数有关，若量化级数为N，则每个采样值就可以编码成$Log_2N$的二进制码<br>    我国的PCM体制的编码位数是8，即每个脉冲信号为8bit信息，由于每秒8000个脉冲，话音的标准编码速率为64Kb&#x2F;s</p><h5 id="脉冲编码调制PCM例子"><a href="#脉冲编码调制PCM例子" class="headerlink" title="脉冲编码调制PCM例子"></a>脉冲编码调制PCM例子</h5> <img src="../images/计算机网络.assets/image-20211103192128540.png" alt="image-20211103192128540" style="zoom:50%;" /> <img src="../images/计算机网络.assets/image-20211103192254649.png" alt="image-20211103192254649" style="zoom:50%;" /><h3 id="2-2-4-信道的极限容量"><a href="#2-2-4-信道的极限容量" class="headerlink" title="2.2.4 信道的极限容量"></a>2.2.4 信道的极限容量</h3><p>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰</p> <img src="../images/计算机网络.assets/image-20211103192538067.png" alt="image-20211103192538067" style="zoom:50%;" /><p>使失真严重的因素：码元的传输速率高、信号传输距离远、噪声干扰大、传输媒体质量差</p><p>限制码元在信道上传输速率的因素：信道能够通过的频率范围、信噪比</p><h4 id="信道能够通过的频率范围"><a href="#信道能够通过的频率范围" class="headerlink" title="信道能够通过的频率范围"></a>信道能够通过的频率范围</h4><p>具体的信道能够通过的频率范围(信道的带宽Hz)是有限的，信号中的许多高频分量往往不能通过信道。</p><p><strong>理想低通信道</strong>：信号的所有低频分量，只要频率不超过某个上限，都能够不失真地通过信道。</p><p><strong>理想带通信道</strong>：信号的频率在某个范围之间的频率分量能够不失真地通过信道，其他分量不能通过。</p><h5 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h5><p>在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值</p><p>理想低通信道的最高码元传输速率 &#x3D; 2W码元&#x2F;秒 (码元&#x2F;秒 &#x3D; 波特率)<br>    其中W是带宽，单位是赫(Hz)<br>即，每赫带宽的理想低通信道的最高码元传输速率是每秒2个码元</p> <img src="../images/计算机网络.assets/image-20211103200350325.png" alt="image-20211103200350325" style="zoom:50%;" /><p>理想带通信道的最高码元传输速率 &#x3D; W码元&#x2F;秒<br>即，每赫带宽的理想低通信道的最高码元传输速率是每秒1个码元</p> <img src="../images/计算机网络.assets/image-20211103200512329.png" alt="image-20211103200512329" style="zoom:50%;" /><h5 id="比特率与波特率"><a href="#比特率与波特率" class="headerlink" title="比特率与波特率"></a>比特率与波特率</h5><p>比特率：数据传输速率，单位”比特&#x2F;秒“<br>波特率：码元传输速率，单位”码元&#x2F;秒“</p><p>若1码元携带1bit信息量，则比特率 &#x3D; 波特率<br>若1码元携带nbit信息量，则比特率 &#x3D; n *波特率</p><p>若码元状态数位N，则n &#x3D; $log_2N$<br>    N &#x3D; 2，一种状态表示1，一种状态表示0<br>    N &#x3D; 4，可表示00，01，11，10</p><h5 id="码间串扰"><a href="#码间串扰" class="headerlink" title="码间串扰"></a>码间串扰</h5><p>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决(即识别)成为不可能</p><p>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰</p><h4 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h4><p>噪声存在于所有的电子设备和通信信道中</p><p>噪声是随机产生的，它的瞬时值有时会很大。因此噪声会使接收端对码元的判决产生错误。</p><p>但噪声的影响是相对的。如果信号相对较强，那么噪声的影响就相对较小</p><p>信噪比就是信号的平均功率和噪声的平均功率之比。常记为S&#x2F;N，并用分贝(dB)作为度量单位，即：<br>$$<br>信噪比(dB) &#x3D; 10 log_{10}(S&#x2F;N)(dB)<br>$$<br>信道的极限信息传输速率C可表示为(香农公式)：<br>$$<br>C &#x3D; Wlog_2(1+S&#x2F;N) (bit&#x2F;s)<br>$$<br>其中，W为信道的带宽(Hz)，S为信道内所传信号的平均功率，N为信道内部的高斯噪声功率</p><p>香农公式表明：</p><p>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。<br>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。<br>若信道带宽 W 或信噪比 S&#x2F;N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。<br>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。</p><h4 id="请注意"><a href="#请注意" class="headerlink" title="请注意"></a>请注意</h4><p>对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。<br>这就是： 用编码的方法让每一个码元携带更多比特的信息量。<br>通信领域的专家致力于寻找新的信号编码和调制方法</p><h2 id="2-3-物理层下面的传输媒体"><a href="#2-3-物理层下面的传输媒体" class="headerlink" title="2.3 物理层下面的传输媒体"></a>2.3 物理层下面的传输媒体</h2><p>传输媒体也称为传输介质或传输媒介， 它就是数据传输系统中在发送器和接收器之间的物理通路。<br>传输媒体可分为两大类，即导引型传输媒体和非导引型传输媒体。<br>在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播。<br>非导引型传输媒体就是指自由空间。 在非导引型传输媒体中， 电磁波的传输常称为无线传输。</p><h3 id="2-3-1-导引型传输媒体"><a href="#2-3-1-导引型传输媒体" class="headerlink" title="2.3.1 导引型传输媒体"></a>2.3.1 导引型传输媒体</h3><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4><p>古老但最常用的传输媒体。<br>电话系统使用的就是双绞线。<br>绞合可减少对相邻双绞线的电磁干扰。<br>模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。<br>带宽依赖于线的<strong>粗细</strong>和<strong>传输距离</strong><br>屏蔽双绞线 STP (Shielded Twisted Pair)（带金属屏蔽层）<br>无屏蔽双绞线 UTP (Unshielded Twisted Pair)  </p><img src="../images/计算机网络.assets/image-20211107232131083.png" alt="image-20211107232131083" style="zoom:67%;" /><p>1991年，美国电子工业协会 EIA 和电信行业协会联合发布了一个用于室内传送数据的无屏蔽双绞线和屏蔽双绞线的标准 EIA&#x2F;TIA-568。<br>1995年将布线标准更新为 EIA&#x2F;TIA-568-A。<br>此标准规定了 5 个种类的 UTP 标准（从 1 类线到 5 类线）。<br>对传送数据来说，现在最常用的 UTP 是5类线（Category 5 或 CAT5） 。  </p> <img src="../images/计算机网络.assets/image-20211107232643321.png" alt="image-20211107232643321" style="zoom:50%;" /><h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><p>同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。<br>同轴电缆的带宽取决于电缆的质量。  </p> <img src="../images/计算机网络.assets/image-20211107232734687.png" alt="image-20211107232734687" style="zoom:50%;" /><p>基带同轴电缆<br>    50Ω用于数字传输<br>    以10Mb&#x2F;s可将基带数字信号，粗缆传送500米，细缆传送180米<br>    局域网发展初期常用<br>宽带同轴电缆<br>    75Ω用于模拟传输<br>    高质量同轴电缆带宽接近1GHz<br>    有线电视常用  </p><h4 id="光缆"><a href="#光缆" class="headerlink" title="光缆"></a>光缆</h4> <img src="../images/计算机网络.assets/image-20211108122542880.png" alt="image-20211108122542880" style="zoom:50%;" /><h5 id="多模光纤"><a href="#多模光纤" class="headerlink" title="多模光纤"></a>多模光纤</h5><p>可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为多模光纤。</p><p>传输中光脉冲会逐渐展宽，造成失真，适合短距离传输 </p><h5 id="单模光纤"><a href="#单模光纤" class="headerlink" title="单模光纤"></a>单模光纤</h5><p>若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为单模光纤  </p><p>使用昂贵的半导体激光源，光脉冲的衰耗小，适合长距离传输  </p><h5 id="光纤优点"><a href="#光纤优点" class="headerlink" title="光纤优点"></a>光纤优点</h5><p>(1) 通信容量非常大。<br>(2) 传输损耗小，中继距离长。<br>(3) 抗雷电和电磁干扰性能好。<br>(4) 无串音干扰，保密性好。<br>(5) 体积小，重量轻。  </p><h3 id="2-3-2-非导引型传输媒体"><a href="#2-3-2-非导引型传输媒体" class="headerlink" title="2.3.2 非导引型传输媒体"></a>2.3.2 非导引型传输媒体</h3><p>将自由空间称为“非导引型传输媒体”。  </p><p>短波通信（即高频通信） 主要是靠电离层的反射，但短波信道的通信质量较差，传输速率低。  (波长100米<del>10米之间，频率范围3兆赫</del>30兆赫)</p><p>微波通信由于地球表面的弯曲，信号的直线传输有限，需要建微波中继站。<br>    波长为1m至0.1mm， 频率范围是300 MHz~300 GHz<br>    传统微波通信有两种方式：地面微波接力通信、卫星通信</p><h4 id="2-3-2-电信领域使用的电磁波的频谱"><a href="#2-3-2-电信领域使用的电磁波的频谱" class="headerlink" title="2.3.2 电信领域使用的电磁波的频谱"></a>2.3.2 电信领域使用的电磁波的频谱</h4> <img src="../images/计算机网络.assets/image-20211108124127421.png" alt="image-20211108124127421" style="zoom:50%;" /><h2 id="2-4-信道复用技术"><a href="#2-4-信道复用技术" class="headerlink" title="2.4 信道复用技术"></a>2.4 信道复用技术</h2><p>复用(multiplexing)是将多路信号组合在一条物理信道上进行传输，在接收端再将各路信号分离开来，提高通信线路的利用率</p><h3 id="2-4-1-频分复用FDM-Frequency-Division-Multiplexing"><a href="#2-4-1-频分复用FDM-Frequency-Division-Multiplexing" class="headerlink" title="2.4.1 频分复用FDM(Frequency Division Multiplexing)"></a>2.4.1 频分复用FDM(Frequency Division Multiplexing)</h3><p>频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。   <img src="../images/计算机网络.assets/image-20211108124602877.png" alt="image-20211108124602877" style="zoom:50%;" /></p><h3 id="2-4-2-时分复用TDM-Time-Division-Multiplexing"><a href="#2-4-2-时分复用TDM-Time-Division-Multiplexing" class="headerlink" title="2.4.2 时分复用TDM(Time Division Multiplexing)"></a>2.4.2 时分复用TDM(Time Division Multiplexing)</h3><p>时分复用则是将时间划分为一段段 等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM帧中占用固定序号的时隙。<br>每一个用户所占用的时隙是周期性地出现（其周期就是 TDM 帧的长度）。<br>TDM 信号也称为等时(isochronous)信号。<br>时分复用的所有用户是在不同的时间占用同样的频带宽度。  </p> <img src="../images/计算机网络.assets/image-20211108124845056.png" alt="image-20211108124845056" style="zoom:50%;" /><p>时分复用可能会造成线路资源的浪费</p> <img src="../images/计算机网络.assets/image-20211108124931747.png" alt="image-20211108124931747" style="zoom:50%;" /><h5 id="统计时分复用STDM-Statistic-TDM"><a href="#统计时分复用STDM-Statistic-TDM" class="headerlink" title="统计时分复用STDM(Statistic TDM)"></a>统计时分复用STDM(Statistic TDM)</h5> <img src="../images/计算机网络.assets/image-20211108125107251.png" alt="image-20211108125107251" style="zoom:50%;" /><h3 id="2-4-3-波分复用WDM-Wavelength-Division-Multiplexing"><a href="#2-4-3-波分复用WDM-Wavelength-Division-Multiplexing" class="headerlink" title="2.4.3 波分复用WDM(Wavelength Division Multiplexing)"></a>2.4.3 波分复用WDM(Wavelength Division Multiplexing)</h3> <img src="../images/计算机网络.assets/image-20211108125419584.png" alt="image-20211108125419584" style="zoom:50%;" /><h3 id="2-4-4-码分复用CDM-Code-Division-Multiplexing"><a href="#2-4-4-码分复用CDM-Code-Division-Multiplexing" class="headerlink" title="2.4.4 码分复用CDM(Code Division Multiplexing)"></a>2.4.4 码分复用CDM(Code Division Multiplexing)</h3><p>常用的名词时码分多址CDMA(Code Division Multiple Access)</p><p>每个用户在同样的时间使用同样的频带进行通信。<br>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。<br>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。<br>特别在无线局域网中，采用CDMA可提高话音质量、数据传输可靠性、增大通信系统容量（是GSM的4～5倍），降低手机的平均发射功率。  </p><h4 id="码片序列-chip-sequence"><a href="#码片序列-chip-sequence" class="headerlink" title="码片序列(chip sequence)"></a>码片序列(chip sequence)</h4><p>每一个比特时间划分为 m 个短的间隔，称为码片 (chip)。设m&#x3D;8<br>每个站被指派一个唯一的m bit 码片序列。<br>    如发送比特 1，则发送自己的m bit 码片序列。<br>    如发送比特 0，则发送该码片序列的二进制反码。<br>例如， S 站的 8 bit 码片序列是 00011011。<br>    发送比特 1 时，就发送序列 00011011，<br>    发送比特 0 时，就发送序列 11100100。<br>按惯例，0写成-1，1写成+1，S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1)  </p> <img src="../images/计算机网络.assets/image-20211108130522147.png" alt="image-20211108130522147" style="zoom:50%;" /><h4 id="CDMA的重要特性"><a href="#CDMA的重要特性" class="headerlink" title="CDMA的重要特性"></a>CDMA的重要特性</h4><p>每个站分配的码片序列不仅<strong>必须各不相同</strong>， 并且还<strong>必须互相正交</strong> (orthogonal)。<br>在实用的系统中是使用<strong>伪随机码序列</strong>。<br>令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量。<br>两个不同站的码片序列正交，就是向量 S 和T的<strong>规格化内积</strong> (inner product) 等于 0：  <img src="../images/计算机网络.assets/image-20211108131008264.png" alt="image-20211108131008264" style="zoom:50%;" /></p><p>任何一个码片向量和该码片向量自己的规格化内积都是1。<br>一个码片向量和该码片反码的向量的规格化内积值是–1。  </p> <img src="../images/计算机网络.assets/image-20211108131133767.png" alt="image-20211108131133767" style="zoom:50%;" /><h4 id="CDMA工作原理"><a href="#CDMA工作原理" class="headerlink" title="CDMA工作原理"></a>CDMA工作原理</h4><p>每个站各自发送扩频信号，在接收端形成叠加的信号。<br>当接收站打算接收S站的信号时，就用S站的码片序列与收到的叠加信号求规格化内积：<br>    若S站有信号发送，则内积结果为1(发送数据1)或-1（发送数据0）。<br>    若S站没有信号发送，则内积结果为0。  </p> <img src="../images/计算机网络.assets/image-20211108132010426.png" alt="image-20211108132010426"  /><h2 id="2-5-数字传输系统"><a href="#2-5-数字传输系统" class="headerlink" title="2.5 数字传输系统"></a>2.5 数字传输系统</h2><p>与模拟通信相比，数字通信无论是在传输质量上还是经济上都有明显的优势。  </p><p>因此， 目前长途干线大都采用时分复用 PCM 的数字传输方式。 模拟线路只剩下用户电话机到市话交换机之间几公里长的用户线上。<br>光纤成为长途干线最主要的传输媒体。</p> <img src="../images/计算机网络.assets/image-20211108132226743.png" alt="image-20211108132226743" style="zoom:50%;" /><h3 id="旧的数字传输系统存在许多缺点"><a href="#旧的数字传输系统存在许多缺点" class="headerlink" title="旧的数字传输系统存在许多缺点"></a>旧的数字传输系统存在许多缺点</h3><p>1、速率标准不统一<br>    如果不对数字传输速率进行标准化，国际范围的基于光纤高速数据传输就很难实现。<br>2、不是同步传输<br>    同步通信要求接收端时钟频率和发送端时钟频率一致。发送端发送连续的比特流。<br>    异步通信时不要求接收端时钟和发送端时钟同步。发送端发送完一个字节后，可经过任意长时间间隔再发送下一个字节。<br>    为了节约经费，各国的数字网主要是采用<strong>准同步</strong>方式，给时分复用和分用带来许多麻烦。<br>当数据传输的速率很高时， 收发双方的时钟同步就成为很大的问题。  </p><h3 id="同步光纤网SONET"><a href="#同步光纤网SONET" class="headerlink" title="同步光纤网SONET"></a>同步光纤网SONET</h3><p>SONET 为光纤传输系统定义了<strong>同步传输的线路速率</strong>等级结构，其传输基本速率为51.84Mb&#x2F;s<br>    对电信号，第 1 级<strong>同步传送信号</strong> STS-1 (Synchronous Transport Signal)的传输速率是 51.84 Mbit&#x2F;s。<br>    对光信号称为第 1 级<strong>光载波</strong> OC-1 (OC 表示Optical Carrier)。  </p><h3 id="同步数字系列SDH"><a href="#同步数字系列SDH" class="headerlink" title="同步数字系列SDH"></a>同步数字系列SDH</h3><p>一般可认为 SDH 与 SONET 是同义词。<br><strong>其主要不同点是</strong>： SDH 的基本速率为 155.52Mbit&#x2F;s，称为第 1 级同步传递模块(Synchronous Transfer Module)，即 STM-1，相当于 SONET 体系中的 OC-3 速率。  </p> <img src="../images/计算机网络.assets/image-20211108132732899.png" alt="image-20211108132732899" style="zoom:50%;" /><h3 id="SONET与SDH的关系"><a href="#SONET与SDH的关系" class="headerlink" title="SONET与SDH的关系"></a>SONET与SDH的关系</h3><p>SDH与SONET之间差别很小。<br>SONET的基本速率为51.84Mb&#x2F;s，而 SDH的基本速率为155.52Mb&#x2F;s。<br>SONET&#x2F;SDH，采用TDM技术，是同步系统， 由<strong>主时钟控制</strong>，时钟精度$10^9$。<br>SONET和PCM的采样速率一样，为每秒8000帧；<br>对于SONET的第1级同步传送信号STS-1每帧的长度为810字节，810*8bit。<br>一个STS-n帧的长度是STS-1帧长的n倍。  </p><h3 id="SONET-x2F-SDH标准的意义"><a href="#SONET-x2F-SDH标准的意义" class="headerlink" title="SONET&#x2F;SDH标准的意义"></a>SONET&#x2F;SDH标准的意义</h3><p>使不同的数字传输体制在 STM-1 等级上获得了统一。并将此基础上的更高的数字传输速率作为国际标准。<br>第一次真正实现了数字传输体制上的世界性标准。<br>已成为公认的新一代理想的传输网体制。<br>SDH 标准也适合于微波和卫星传输的技术体制。  </p><h2 id="2-6-物理层协议举例"><a href="#2-6-物理层协议举例" class="headerlink" title="2.6 物理层协议举例"></a>2.6 物理层协议举例</h2><h3 id="物理层的主要任务"><a href="#物理层的主要任务" class="headerlink" title="物理层的主要任务"></a>物理层的主要任务</h3><p>主要任务：确定与传输媒体的接口的一些特性。  </p><p>机械特性 ： 指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。<br>电气特性： 指明在接口电缆的各条线上出现的电压的范围。<br>功能特性： 指明某条线上出现的某一电平的电压表示何种意义。<br>过程特性 ： 指明对于不同功能的各种可能事件的出现顺序。</p><h3 id="EIA-232-E接口标准"><a href="#EIA-232-E接口标准" class="headerlink" title="EIA-232-E接口标准"></a>EIA-232-E接口标准</h3> <img src="../images/计算机网络.assets/image-20211108133218374.png" alt="image-20211108133218374" style="zoom:50%;" /> <img src="../images/计算机网络.assets/image-20211108133245531.png" alt="image-20211108133245531" style="zoom:50%;" /> <img src="../images/计算机网络.assets/image-20211108133355624.png" alt="image-20211108133355624" style="zoom:50%;" /><h3 id="RS-449接口标准"><a href="#RS-449接口标准" class="headerlink" title="RS-449接口标准"></a>RS-449接口标准</h3> <img src="../images/计算机网络.assets/image-20211108133500236.png" alt="image-20211108133500236" style="zoom:50%;" /><h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><h2 id="数据链路层基本概念"><a href="#数据链路层基本概念" class="headerlink" title="数据链路层基本概念"></a>数据链路层基本概念</h2><p><strong>链路</strong>：(link)是一条无源的结点到相邻结点的物理线路（有线或无线），中间没有任何其他的交换结点。<br>    一条链路只是一条通路的一个组成部分。</p><p><strong>数据链路</strong> (data link)：除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。<br>    现在最常用的方法是使用网络适配器（即网卡） 来实现这些协议的硬件和软件。<br>    一般的适配器都包括了数据链路层和物理层这两层的功能。  </p><p><strong>物理链路</strong>就是上面所说的链路。</p><p><strong>逻辑链路</strong>就是上面的数据链路，是物理链路加上必要的通信协议。</p><p>早期的数据通信协议曾叫做<strong>通信规程</strong>(procedure)。因此在数据链路层，规程和协议是同义语  </p><p><strong>帧</strong>：常常在两个对等的数据链路层之间画出一个数字管道，而在这条数字管道上传输的数据单位是帧。<br>帧是数据链路层的协议数据单元</p>  <img src="../images/计算机网络.assets/image-20211108134139083.png" alt="image-20211108134139083" style="zoom:50%;" /> <img src="../images/计算机网络.assets/image-20211108134302505.png" alt="image-20211108134302505" style="zoom:50%;" /><h2 id="数据链路层使用的信道"><a href="#数据链路层使用的信道" class="headerlink" title="数据链路层使用的信道"></a>数据链路层使用的信道</h2><p><strong>点对点信道</strong>： 这种信道使用一对一的点对点通信方式。（PPP协议）<br><strong>广播信道</strong>： 这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。 （CSMA&#x2F;CD协议）  </p><h2 id="3-1-使用点对点信道的数据链路层"><a href="#3-1-使用点对点信道的数据链路层" class="headerlink" title="3.1 使用点对点信道的数据链路层"></a>3.1 使用点对点信道的数据链路层</h2><p>数据链路层协议有许多种，但有三个基本问题则是共同的。这三个基本问题是：  </p><ol><li><p>封装成帧：数据的传送以帧为单位(<strong>帧定界</strong>)</p></li><li><p>透明传输：若所传的数据的比特片段与某一个控制信息相同，要有可靠机制，保证收方能正确识别</p></li><li><p>差错控制：</p></li></ol><p>   ​纠错：通过编码技术，接收方自动将差错改正过来<br>   ​检错：检测出帧有错误，要么忽略或重传  </p><h3 id="3-1-1-封装成帧"><a href="#3-1-1-封装成帧" class="headerlink" title="3.1.1 封装成帧"></a>3.1.1 封装成帧</h3><p><strong>封装成帧</strong> (framing) 就是在一段数据的前后分别添加首、部和尾部， 然后就构成了一个帧。 使接收方能确定帧的界限。<br>首部和尾部的一个重要作用就是进行帧定界。  </p> <img src="../images/计算机网络.assets/image-20211108135613207.png" alt="image-20211108135613207" style="zoom:50%;" /><p>帧定界(帧同步)的方法<br>    1、字节计数法<br>    2、使用字符填充的首位定界法<br>    3、使用比特填充的首位定界法<br>    4、违法编码法</p><h4 id="字节计数法"><a href="#字节计数法" class="headerlink" title="字节计数法"></a>字节计数法</h4><p>思想：<br>    在帧头设置一个长度域，放置该帧的字节数，当收方收到帧后，通过帧的长度，确定帧的开始。</p><p>问题：<br>    当帧的长度域出错，帧同步完全丢失；<br>    该方法很少单独使用。  </p><h4 id="字符填充法"><a href="#字符填充法" class="headerlink" title="字符填充法"></a>字符填充法</h4><p>当数据是由可打印的ASCII码组成的文本文件时， 帧定界可以使用特殊的ASCII码（不可打印的控制字符） 作为帧定界符。<br>控制字符 SOH (Start Of Header) 放在一帧的最前面， 表示帧的首部 开始 。另一个控制字符EOT (End Of Transmission) 表示帧的结束。  </p> <img src="../images/计算机网络.assets/image-20211108141656907.png" alt="image-20211108141656907" style="zoom:50%;" /><h5 id="透明传输问题"><a href="#透明传输问题" class="headerlink" title="透明传输问题"></a>透明传输问题</h5><p>如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界” 。 </p><p>解决方法：<br>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC” (其十六进制编码是 1B)。<br>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。<br>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。  </p><h4 id="比特填充法"><a href="#比特填充法" class="headerlink" title="比特填充法"></a>比特填充法</h4><p>使用一个特殊的比特模式01111110作为帧的起始和结束标志。<br><strong>发送方</strong>边发送边检查数据，每连续发送5个“1”后在后面自动插入一个“0”。这样数据中只会连续出现5个“1”，而不会出现定界符。</p><p><strong>接收方</strong>在收到5个连续的“1”后将后面的“0”删掉而恢复出原始数据。<br>好处：数据传输的基本单位是比特而不是字符，可用来传输任意长度的二进制比特串，通用性强。  </p><h4 id="违法编码法"><a href="#违法编码法" class="headerlink" title="违法编码法"></a>违法编码法</h4><p>前提：物理介质上使用的信号编码有冗余码字时，使用这些冗余的码字来作为帧的定界。</p><p>举例：<br>    如曼彻斯特编码或差分曼彻斯特编码中，有效电平是“低－高”或“高－低”，而“低－低”和“高－高”电平没有定义，这种违法编码可以作为帧的边界。  </p><h3 id="3-1-2-差错检测"><a href="#3-1-2-差错检测" class="headerlink" title="3.1.2 差错检测"></a>3.1.2 差错检测</h3><p>在传输过程中可能会产生<strong>比特差错</strong>：1可能会变成0而0也可能变成1。  </p><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率</strong> BER (Bit Error Rate)。</p><p>误码率与信噪比有很大的关系。</p><p>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。  </p><p><strong>差错控制</strong></p><p>​差错编码技术：如何发现差错<br>​检错码(奇偶校验码、CRC)：能检测出错误，但不能纠正错误<br>​纠错码(海明码)：能知道错误，且知道错误的位置</p><p>​差错控制技术：发现差错如何处理<br>​前向纠错：由接收方来检查并纠正错误<br>​自动重发请求：不能纠正，接收方反馈。若有错误则重发，否则给肯定应答</p><h4 id="前向纠错-FEC-Forward-Error-Correct"><a href="#前向纠错-FEC-Forward-Error-Correct" class="headerlink" title="前向纠错(FEC, Forward Error Correct)"></a>前向纠错(FEC, Forward Error Correct)</h4><p>发送方发送能使接收方<strong>检错并纠错</strong>的冗余位，纠错任务由接收方完成，常采用<strong>海明码</strong></p><p>主要应用于没有反向信道或反向传输时间很长的场合</p><p>缺点：为纠错附加的冗余码较多，传输效率低；<br>优点：实时性好。  </p><h4 id="自动重发请求-ARQ-Automatic-Repeat-reQuest"><a href="#自动重发请求-ARQ-Automatic-Repeat-reQuest" class="headerlink" title="自动重发请求(ARQ, Automatic Repeat reQuest)"></a>自动重发请求(ARQ, Automatic Repeat reQuest)</h4><p>即发送方发送能使接收方<strong>检错</strong>的冗余位，若无差错，则接收方回送一个**肯定应答(ACK)<strong>；若有差错，则接收方回送一个</strong>否定应答(NAK)**，要求发送方重发。  </p><p>缺点：信息传递连贯性差<br>优点：接收端设备简单，只要请求重发，无需纠正错误。  </p><h4 id="检错码"><a href="#检错码" class="headerlink" title="检错码"></a>检错码</h4><p><strong>检错码</strong>(码字、传输帧) ＝ 信息位＋冗余校验位<br><strong>码字长</strong>n &#x3D; K(信息位位数)＋r(校验位位数)<br><strong>编码效率</strong>R ＝ 有效数据位K／ 码字长n  </p><p><strong>信息字段</strong>和<strong>校验字段</strong>之间的对应关系<br>校验字段越长，编码的检错能力越强，编码&#x2F;解码越复杂；附加的冗余信息在整个编码中所占的比例越大，传输的有效成分越低，传输的效率下降。<br>检错码一旦形成， 整个检错码将作为一个整体被发往线路，通常的发送顺序是信息字段在前，校验字段在后。  </p><h4 id="奇-x2F-偶校验码"><a href="#奇-x2F-偶校验码" class="headerlink" title="奇&#x2F;偶校验码"></a>奇&#x2F;偶校验码</h4><p>奇校验：使码字中“1”的总个数为奇数。<br>偶校验：使码字中“1”的总个数为偶数。<br>奇&#x2F;偶校验码：最常用的一种检验码，包括：<br>    水平奇&#x2F;偶校验码<br>    垂直奇&#x2F;偶校验码<br>    水平垂直奇&#x2F;偶校验码  </p><h5 id="水平奇-x2F-偶校验"><a href="#水平奇-x2F-偶校验" class="headerlink" title="水平奇&#x2F;偶校验"></a>水平奇&#x2F;偶校验</h5><p>其信息字段以字符为单位，校验字段仅含一个比特称为校验比特或校验位。</p><p>编码效率： Q&#x2F;(Q+1) (信息字段占Q个比特)  </p> <img src="../images/计算机网络.assets/image-20211108193430293.png" alt="image-20211108193430293" style="zoom: 50%;" /><h5 id="垂直奇-x2F-偶校验"><a href="#垂直奇-x2F-偶校验" class="headerlink" title="垂直奇&#x2F;偶校验"></a>垂直奇&#x2F;偶校验</h5><p>被传输的信息进行分组，并排列为若干行和若干列。组中每行的相同列进行奇&#x2F;偶校验，最终产生由校验位形成的校验字符（校验行），并附加在信息分组之后传输</p><p>编码效率：PQ&#x2F;P(Q+1)      （假设信息分组占Q行P列）</p> <img src="../images/计算机网络.assets/image-20211108193707197.png" alt="image-20211108193707197" style="zoom:50%;" /><h5 id="水平垂直奇-x2F-偶校验"><a href="#水平垂直奇-x2F-偶校验" class="headerlink" title="水平垂直奇&#x2F;偶校验"></a>水平垂直奇&#x2F;偶校验</h5><p>编码效率：PQ&#x2F;(P+1)(Q+1) （假设被传信息分组占Q行P列）  </p><h4 id="循环冗余码-CRC-Cyclic-Redundancy-Check"><a href="#循环冗余码-CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余码(CRC, Cyclic Redundancy Check)"></a>循环冗余码(CRC, Cyclic Redundancy Check)</h4><h5 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h5><p>在发送端，先把数据划分为组，假定每组 k 个比特<br>假设待传送的一组数据 M &#x3D; 101001（现在 k &#x3D; 6）。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。  </p><p><strong>计算方法</strong>：</p><p>1、用二进制的模2运算进行 $2^n$ 乘 M 的运算，这相当于在M 后面添加 n 个 0。<br>2、得到的 (k + n) bit 的数除以事先选定好的长度为 (n + 1) bit 的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少 1 位，即 R 是 n 位。<br>3、将余数 R 作为冗余码（帧检验序列FCS (Frame Check Sequence)） 拼接在数据 M 后面发送出去。</p><p>注意：用模2运算进行加法时不进位。减法和加法一样，按加法规则进行运算。<br>    举例: 1111＋1010＝？答案为0101    </p><p><strong>计算举例</strong></p> <img src="../images/计算机网络.assets/image-20211108195130316.png" alt="image-20211108195130316" style="zoom:50%;" /><p>**帧检验序列FCS(Frame Check Sequence)**：在数据后面添加上的冗余码称为帧检验序列FCS<br>CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。<br>FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。  </p><h5 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h5><p>把收到的每一个帧都除以相同的除数P（模2运算） ， 然后检查得到的余数R<br>    (1) 若得出的余数 R &#x3D; 0， 则判定这个帧没有差错， 就接受 (accept)<br>    (2) 若余数 R ≠ 0， 则判定这个帧有差错， 就丢弃</p><p>缺点：无法定位差错的位置</p><p>漏检：CRC不能保证检测出所有的传输错误，但只要选择位数足够的P，可以使得差错的概率足够小</p><h5 id="生成多项式P"><a href="#生成多项式P" class="headerlink" title="生成多项式P"></a>生成多项式P</h5><p>多项式表示：将k比特的数据用k项多项式表示<br>    例如：代码1010111对应的多项式为x6+x4+x2+x+1  </p><p>除数 P 可表示成生成多项式 P(X)<br>例如： P＝110101，即P(X)&#x3D;X5+X4+X2+1(X0)（P为5阶多项式）；<br>生成多项式的最高位和最低位都必须为1；<br>若 P 为 r 阶（ r+1 bit），将产生 r 位冗余位；  </p><p>发送端帧检验序列FCS的生成和接收端CRC检验都是用硬件完成的，处理速度很快，不会延误数据的传输  </p><p>M(X) ——– 信息多项式<br>R(X) ——– 冗余多项式<br>T(X) ——– 传输帧多项式  </p><p>P为生成多项式，已有的国际标准</p> <img src="../images/计算机网络.assets/image-20211108200940773.png" alt="image-20211108200940773" style="zoom:50%;" /><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>仅用循环冗余检验 CRC 差错检测技术只能做到<strong>无差错接受</strong> (accept)。<br>“无差错接受” 是指： “凡是接受的帧（即不包括丢弃的帧） ， 我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错” 。<br>也就是说： “凡是接收端数据链路层接受的帧都无差错” （有差错的帧就丢弃而不接受） 。<br>区分“<strong>无比特差错</strong>” 与“<strong>无传输差错</strong>” (在运输层实现)<br>要做到“可靠传输” （即发送什么就收到什么） 就必须再加上<strong>确认和重传机制</strong>。  </p><p>传输差错 [#1]-[#2]-[#3]<br>    帧丢失 [#1]-[#3]<br>    帧重复 [#1]-[#2]-[#2]-[#3]<br>    帧失序 [#1]-[#3]-[#2]  </p><p>可靠传输<br>    帧编号<br>    确认：收到正确帧要发送确认<br>    重传机制：一定期限内，发送端未收到确认，则重传</p><p>本章介绍的数据链路层协议都<strong>不是可靠传输</strong>的协议</p><p>对于通信质量较差的无线传输链路， 数据链路层协议使用确认和重传机制可以提高通信效率  </p><h4 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h4><p>基本思想：在 k 比特信息上附加 r 比特冗余信息（校验比特），构成 n&#x3D;k+r 比特的码字，其中每个校验比特和某几个特定的信息比特构成<strong>偶校验</strong>关系。</p><p>接收端对这 r 个偶校验关系进行校验，即将每个校验比特和与它关联的信息比特进行相加（异或），相加的结果为校正因子<br>    如果没有错，则 r 个校正因子都为0；<br>    若校正因子不全为0，根据校正因子的取值，确定错误发生的位置  </p><p><strong>码距</strong>（海明距离Hamming Distance）</p><p>​一个编码系统中任意两个合法编码（码字）之间不同的二进位（bit）数叫这两个码字的码距。<br>​而整个编码系统中任意两个码字的的最小距离就是该编码系统的码距  </p><p>如果要<strong>检测</strong>出d个比特的错，则编码集的海明距离至少为d+1。<br>如果要<strong>纠正</strong> d个比特的错，则编码集的海明距离至少应为2d+1。  </p> <img src="../images/计算机网络.assets/image-20211108203539720.png" alt="image-20211108203539720" style="zoom:50%;" /><h5 id="发送方冗余位计算"><a href="#发送方冗余位计算" class="headerlink" title="发送方冗余位计算"></a>发送方冗余位计算</h5><p>1、根据信息位长度(如每帧K位)，计算出所需冗余位位数r：<br>    求海明码时的一项基本考虑是确定所需<strong>最少校验位数 r</strong>，若需纠正1bit错，需满足： <strong>$2^r ≥ K+r+1$</strong><br>    考虑长度为 K 位的信息，若附加了 r 个校验位，则所发送信息的总长度为 K+r<br>    在接收端中要进行 r 个奇偶检查，每个检查结果或是真或是伪。这个奇偶检查的结果确定最多 $2^r$ 种不同状态<br>    这些状态中必有一个是判定信息正确的条件<br>    剩下的（$2^r - 1$）种状态，可以用来判定误码的位置<br>    则导出关系： $2^r-1 ≥ K+r$<br>    例如：如果K＝4，则r&#x3D;3，则n&#x3D;K+r&#x3D;7  </p><p>​公式附加解释：主要判断的是错误的位置</p><p>2、确定校验比特和信息比特的位置</p><p>​理论上校验比特可在任何位置，但习惯都是将校验比特放在1、 2、 4、 8、 16…位置上。<br>​通常是将$2^k$位置上，放校验位，其余位置放信息位。<br>​例： 7 bit 的二进制数  </p> <img src="../images/计算机网络.assets/image-20211108205754522.png" alt="image-20211108205754522" style="zoom:50%;" /><p>将每个信息比特的位置写成2的次幂之和的形式有：<br>$I_4： 7＝2^2＋2^1 ＋2^0$（说明$I_4$参与$R_2$、$R_1$和$R_0$的生成）<br>$I_3 ： 6＝2^2＋2^1$（说明$I_3$参与$R_2$、$R_1$的生成）</p><p>$I_2 ： 5＝2^2＋2^0$（说明$I_2$参与$R_2$、$R_0$的生成）<br>$I_1 ： 3＝2^1 ＋2^0$（说明$I_1$参与$R_1$、$R_0$的生成）  </p><p>​目的：计算每一个信息为与哪些校验位有关联</p> <img src="../images/计算机网络.assets/image-20211108211219654.png" alt="image-20211108211219654" style="zoom:50%;" /> <img src="../images/计算机网络.assets/image-20211108211237552.png" alt="image-20211108211237552" style="zoom:50%;" /><h5 id="接收方验证"><a href="#接收方验证" class="headerlink" title="接收方验证"></a>接收方验证</h5><p>接收端利用相应的偶关系进行验证：<br>    $S_1＝R_1 ⊕ I_1 ⊕ I_3 ⊕ I_4 ⊕ I_6 ⊕ I_7$<br>    同理可得$S_0、S_2、S_3$<br>这里$S_1$为校正因子，若校正因子为0，则无错；<br>校正因子不为0，有错， 错误位置为$S＝S_3S_2S_1S_0$处。<br>校正方式：将S位置的比特取反<br>    例如：若S＝0101＝5，则将位置5的比特取反<br>最后去掉校验比特即可得到正确的信息。  </p><h2 id="3-2-点对点协议PPP-Point-to-Point-Protocol"><a href="#3-2-点对点协议PPP-Point-to-Point-Protocol" class="headerlink" title="3.2 点对点协议PPP(Point-to-Point Protocol)"></a>3.2 点对点协议PPP(Point-to-Point Protocol)</h2><h3 id="3-2-1-PPP协议的特点"><a href="#3-2-1-PPP协议的特点" class="headerlink" title="3.2.1 PPP协议的特点"></a>3.2.1 PPP协议的特点</h3><p>因特网服务提供者(ISP)</p><p>用户使用拨号电话线接入互联网时， 用户计算机 和 ISP 进行通信时所使用的数据链路层协议就是 PPP 协议  </p> <img src="../images/计算机网络.assets/image-20211108212437180.png" alt="image-20211108212437180" style="zoom:50%;" /><p><strong>PPP协议的特点</strong></p><p>封装成帧<br>    必须规定特殊的字符作为帧定界符。<br>透明性<br>    保证数据传输的透明性。<br>支持多种网络层协议<br>    能够在同一条物理链路上同时支持多种网络层协议。<br>差错检测<br>    能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。<br><strong>允许身份验证</strong><br><strong>允许网络层地址协商</strong><br>    提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址  </p><p><strong>PPP协议的组成</strong>：</p><ol><li>一个将IP数据报封装到串行链路的方法</li><li><strong>链路控制协议 LCP (Link Control Protocol)</strong> ： 建立、配置和测试数据链路的协议。</li><li><strong>网络控制协议 NCP (Network Control Protocol)</strong> ： 如</li></ol><h3 id="3-2-2-PPP协议的帧格式"><a href="#3-2-2-PPP协议的帧格式" class="headerlink" title="3.2.2 PPP协议的帧格式"></a>3.2.2 PPP协议的帧格式</h3><p>PPP 帧的首部和尾部分别为 4 个字段和 2 个字段。<br><strong>标志字段</strong> F &#x3D; 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是01111110）。<br><strong>地址字段</strong> A 只置为 0xFF。地址字段实际上并不起作用<br><strong>控制字段</strong> C 通常置为 0x03。<br><strong>帧检验序列</strong>FCS采用CRC。<br><strong>PPP帧 是面向字节的，所有的 PPP 帧的长度都是整数字节</strong></p> <img src="../images/计算机网络.assets/image-20211108213135046.png" alt="image-20211108213135046" style="zoom:50%;" /><h4 id="透明传输问题-1"><a href="#透明传输问题-1" class="headerlink" title="透明传输问题"></a>透明传输问题</h4><p>异步传输时： <strong>字符填充</strong> （按帧封装）<br>    将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D, 0x5E)。<br>    若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列 (0x7D, 0x5D)。<br>    若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个0x7D 字节，同时将该字符的编码加以改变<br>同步传输时： <strong>比特填充</strong> （只传输信息比特位）<br>    在5个连续 1 的后面插入0  </p><h4 id="PPP协议不提供序号和确认的可靠传输"><a href="#PPP协议不提供序号和确认的可靠传输" class="headerlink" title="PPP协议不提供序号和确认的可靠传输"></a>PPP协议不提供序号和确认的可靠传输</h4><p>PPP 协议之所以不使用序号和确认机制是出于以下的考虑：<br>① 在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。<br>② 在因特网环境下， PPP 的信息字段放入的数据是 IP 数据报。 数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。<br>③ 帧检验序列 FCS 字段可保证无差错接受。  </p><h3 id="3-2-3-PPP协议的工作状态"><a href="#3-2-3-PPP协议的工作状态" class="headerlink" title="3.2.3 PPP协议的工作状态"></a>3.2.3 PPP协议的工作状态</h3><p>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。<br>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。<br>这些分组及其响应选择一些 PPP 参数<br>接着进行网络层配置， NCP 给新接入的 PC 机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。<br>通信完毕时， NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着， LCP 释放数据链路层连接。最后，释放的是物理层的连接。<br>可见， <strong>PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</strong>  </p> <img src="../images/计算机网络.assets/image-20211108215142192.png" alt="image-20211108215142192" style="zoom:50%;" /><h3 id="3-2-4-PPP协议的特点"><a href="#3-2-4-PPP协议的特点" class="headerlink" title="3.2.4 PPP协议的特点"></a>3.2.4 PPP协议的特点</h3><p>PPP帧中增加了校验字段， PPP在链路层具有差错检测功能<br>PPP的LCP协议提供通信双方进行参数协商的手段<br>协商参数有：数据帧的最大帧长、身份认证、 NCP 协议、数据压缩方式等。<br>PPP帧中增加了协议字段，使得PPP可以支持多种网络层协议，有IP、 IPX、 OSI、 CLNP等。<br>支持IP的NCP可以在建立连接时动态分配IP地址，解决了家庭用户拨号上网的问题。  </p><h2 id="3-3-使用广播信道的数据链路层"><a href="#3-3-使用广播信道的数据链路层" class="headerlink" title="3.3 使用广播信道的数据链路层"></a>3.3 使用广播信道的数据链路层</h2><h3 id="3-3-1-局域网的数据链路层"><a href="#3-3-1-局域网的数据链路层" class="headerlink" title="3.3.1 局域网的数据链路层"></a>3.3.1 局域网的数据链路层</h3><p>局域网的<strong>概念</strong></p><p>​局域网(Local Area Network, 简称LAN)是在一个较小范围(一个办公室、一幢楼、一家工厂等)，利用通信线路将众多计算机(一般为微机)及外围设备连接起来，以达到数据通信和资源共享的目的</p><p>局域网的主要<strong>特点</strong></p><p>​网络为一个单位所拥有；地理范围和站点数目有限。<br>​具有较高的数据量、较低的时延和较小的误码率</p><p>局域网的主要<strong>优点</strong></p><p>​具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。<br>​便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。<br>​提高了系统的可靠性、可用性和生存性。  </p> <img src="../images/计算机网络.assets/image-20211109160201882.png" alt="image-20211109160201882" style="zoom:50%;" /><h4 id="局域网信道分配策略"><a href="#局域网信道分配策略" class="headerlink" title="局域网信道分配策略"></a>局域网信道分配策略</h4><p>广播网中所有站点共享同一个信道，任一站点发送的信息能被所有其他站点接收到。  </p><p>问题：<br>    若有两个或两个以上的站点同时发送数据，则信号在信道中发生碰撞，数据发送失败，为冲突。<br>    广播网中，如何将单一的信道分配各各个不同的用户，是个重要的问题。  </p><p>用户使用的信道称为媒体（介质） ，决定由谁来使用信道的协议为“<strong>媒体（介质）访问控制协议</strong>”。  </p><h4 id="媒体-介质-共享技术"><a href="#媒体-介质-共享技术" class="headerlink" title="媒体(介质)共享技术"></a>媒体(介质)共享技术</h4><h5 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h5><p><strong>静态划分信道</strong></p><p>​频分复用<br>​时分复用<br>​波分复用<br>​码分复用</p><p><strong>静态分配的特点</strong></p><p>​站点数目少且固定，且每个站点有大量数据发送，控制协议简单且传输的效率高。<br>​对于大部分计算机网络，站点数目多且不固定，数据传输有突发性，信道的利用率低。<br>​代价较高，不适合于局域网使用  </p><h5 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h5><p>动态媒体接入控制</p><p>​信道不是在用户通信时固定分配给用户。</p><p>​例如：异步时分多路复用STDM，各站点仅当有数据发送时，才占用信道发送数据。  </p><p>动态接入控制类型</p><p>​随机接入</p><p>​用户发送前不需要取得发送权，有数据就发送，发生冲突（碰撞） 后采取措施解决冲突</p><h5 id="代表性媒体访问控制方法"><a href="#代表性媒体访问控制方法" class="headerlink" title="代表性媒体访问控制方法"></a>代表性媒体访问控制方法</h5><p><strong>争用协议</strong></p><p>​ALOHA协议<br>​CSMA&#x2F;CD协议<br>​<strong>随机访问</strong>：意味着对任何站都无法预计其发送的时刻<br>​<strong>竞争发送</strong>：指所有发送的站自由竞争信道的使用权</p><h4 id="ALOHA系统"><a href="#ALOHA系统" class="headerlink" title="ALOHA系统"></a>ALOHA系统</h4><p>思想：</p><p>​任何用户有数据发送就可以发送(会带来冲突)<br>​每个用户通过<strong>监听信道</strong>来获知数据传输是否成功<br>​发现数据传输失败后，各自<strong>等待一段随机时间</strong>，再重新发送</p><p>竞争系统中，一方面不断有新的数据帧发送，另一方面冲突帧需要重发，系统的<strong>吞吐量</strong>是一个重要的指标。<br><strong>吞吐量</strong>：单位时间内系统能够成功发送的新的数据帧的平均数量。<br>结论：<br>    ALOHA系统最大的信道利用率为18.4%；<br>    对ALOHA系统改进的时分ALOHA系统的最大信道利用率为36.8%<br>    ALOHA系统的信道利用率是非常低的。原因主要是各个站自由发送数据，碰撞概率增大。  </p><h4 id="CSMA-x2F-CD协议"><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h4><p>CSMA&#x2F;CD含义：<strong>载波监听 多点接入&#x2F;碰撞检测</strong></p><p>“多点接入”指总线型网络，表示许多计算机以多点接入的方式连接在一根总线上。<br>“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。  “碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。  </p><p>载波监听：先听后发；碰撞检测：边发边听</p><h5 id="检测到碰撞之后"><a href="#检测到碰撞之后" class="headerlink" title="检测到碰撞之后"></a>检测到碰撞之后</h5><p>立即停止发送数据，避免继续浪费资源，等待一段随机时间后再次发送</p><p>发生碰撞的根本原因：电磁波在总线上的传播速度有限</p><h5 id="CSMA-x2F-CD重要特性"><a href="#CSMA-x2F-CD重要特性" class="headerlink" title="CSMA&#x2F;CD重要特性"></a>CSMA&#x2F;CD重要特性</h5><p>使用CSMA&#x2F;CD协议的以太网不能全双工通信，只能双向交替通信(<strong>半双工通信</strong>)</p><p><strong>发送的不确定性</strong>：每个站在发送数据后的一小段时间内，存在着遭遇碰撞的可能性。这种不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</p><h5 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h5><p>最先发送数据帧的站，在发送数据帧后至多经过时间 <strong>2τ （两倍的端到端往返时延）</strong> 就可知道发送的数据帧是否遭受了碰撞。  </p><p>以太网的端到端往返时延 2τ 称为<strong>争用期</strong>， 或<strong>碰撞窗口</strong>。  </p><h5 id="二进制指数类型退避算法"><a href="#二进制指数类型退避算法" class="headerlink" title="二进制指数类型退避算法"></a>二进制指数类型退避算法</h5><p>发生碰撞的站在停止发送数据后，要推迟（退避）一个<strong>随机时间</strong>才能再发送数据。<br>    基本退避时间取为争用期 2τ。<br>    从整数集合 [0, 1, 2， 3， 4， … , (2k -1)] 中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间。<br>    参数 k 按下面的公式计算：k &#x3D; Min[重传次数, 10]<br>    当 k ≤ 10 时，参数 k 等于重传次数。<br>    当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告  </p><h5 id="争用期的长度"><a href="#争用期的长度" class="headerlink" title="争用期的长度"></a>争用期的长度</h5><p>10 Mbit&#x2F;s 以太网取 <strong>51.2 µs</strong> 为争用期的长度。<br>对于 10 Mbit&#x2F;s 以太网，在争用期内可发送 512 bit，即 <strong>64 字节（最短有效帧长）</strong> 。<br>如果发生冲突，就一定是在发送的前 64 字节之内。<br>由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节。<br>以太网规定了最短有效帧长为 64 字节，凡长度小于64 字节的帧都是由于冲突而异常中止的<strong>无效帧</strong>。</p><h5 id="强化碰撞"><a href="#强化碰撞" class="headerlink" title="强化碰撞"></a>强化碰撞</h5><p>当发送数据的站一旦发现发生了碰撞时：<br> (1) 立即停止发送数据；<br> (2) 再继续发送若干比特的<strong>人为干扰信号</strong>(jamming signal)，以便让所有用户都知道现在已经发生了碰撞。  </p><h5 id="CSMA-x2F-CD工作流程图"><a href="#CSMA-x2F-CD工作流程图" class="headerlink" title="CSMA&#x2F;CD工作流程图"></a>CSMA&#x2F;CD工作流程图</h5> <img src="../images/计算机网络.assets/image-20211110082454941.png" alt="image-20211110082454941" style="zoom:50%;" /><h5 id="CSMA-x2F-CD协议要点"><a href="#CSMA-x2F-CD协议要点" class="headerlink" title="CSMA&#x2F;CD协议要点"></a>CSMA&#x2F;CD协议要点</h5><p>(1) 准备发送。 但在发送之前，必须先检测信道。<br>(2) 检测信道。 若检测到信道忙，则应不停地检测，一直等待信道转为空闲。<br>        若检测到信道空闲，并在 96 比特时间内信道保持空闲（保证了帧间最小间隔 9.6 µs ），就发送这个帧。<br>(3) 检查碰撞。 在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。这里只有两种可能性：<br>    ①发送成功： 在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到 (1)。<br>    ②发送失败： 在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待 r 倍 512 比特时间后，返回到步骤 (2)，继续检测信道。但若重传达 16 次仍不能成功，则停止重传而向上报错。  </p><h5 id="帧间最小间隔"><a href="#帧间最小间隔" class="headerlink" title="帧间最小间隔"></a>帧间最小间隔</h5><p>帧间最小间隔为 9.6 µs，相当于 96 bit 的发送时间。<br>一个站在检测到总线开始空闲后，还要等待 9.6µs 才能再次发送数据。<br>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。  </p><h3 id="3-3-3-信道利用率"><a href="#3-3-3-信道利用率" class="headerlink" title="3.3.3 信道利用率"></a>3.3.3 信道利用率</h3><p>多个站在以太网上同时工作就可能会发生碰撞。<br>当发生碰撞时，信道资源实际上是被浪费了。<br>    因此，当扣除碰撞所造成的信道损失后， **以太网总的信道利用率并不能达到 100%**。<br>假设 τ 是以太网单程端到端传播时延。则争用期长度为 2τ，即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。<br>设帧长为 L (bit)， 数据发送速率为 C (bit&#x2F;s)，则帧的发送时间为 $T_0 &#x3D; L&#x2F;C (s)$。  </p> <img src="../images/计算机网络.assets/image-20211110083417682.png" alt="image-20211110083417682" style="zoom:50%;" /><p>成功发送一个帧需要占用信道的时间是$T_0 + τ$</p><p>这是因为当一个站发送完最后一个比特时，这个比特还要在以太网上传播  </p><p>$T_0$ 指从一个站在无碰撞的情况下发出第一个帧开始到发出最后一个帧的时间，不包括数据到达终点的时间</p><h4 id="参数α-与利用率"><a href="#参数α-与利用率" class="headerlink" title="参数α 与利用率"></a>参数α 与利用率</h4><p>$a &#x3D; τ&#x2F;T_0$ </p><p> α →0，表示一发生碰撞就立即可以检测出来， 并立即停止发送，因而<strong>信道利用率很高</strong>。<br> α 越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得<strong>信道利用率明显降低</strong>。</p><h4 id="信道利用率的最大值-S-max"><a href="#信道利用率的最大值-S-max" class="headerlink" title="信道利用率的最大值$S_{max}$"></a>信道利用率的最大值$S_{max}$</h4><p>在<strong>理想化</strong>的情况下， 以太网上的各站发送数据都不会产生碰撞（这显然已经不是 CSMA&#x2F;CD， 而是需要使用一种特殊的调度方法） ， 即总线一旦空闲就有某一个站立即发送数据。<br>发送一帧占用线路的时间是 $T_0 + τ$， 而帧本身的发送时间是 $T_0$。 于是我们可计算出<strong>理想情况下的极限信道利用率 $S_{max}$ 为</strong>：<br>$$<br>S_{max} &#x3D; \dfrac{T_0}{T_0+τ} &#x3D; \dfrac{1}{1+a}<br>$$<br>只有当参数 a 远小于 1 才能得到尽可能高的极限信道利用率。<br>据统计，当以太网的利用率达到 30%时就已经处于重载的情况。很多的网络容量被网上的碰撞消耗掉了。</p><h2 id="3-4-以太网"><a href="#3-4-以太网" class="headerlink" title="3.4 以太网"></a>3.4 以太网</h2><h3 id="3-4-1-传统以太网"><a href="#3-4-1-传统以太网" class="headerlink" title="3.4.1 传统以太网"></a>3.4.1 传统以太网</h3><p>**以太网(Ethernet)**指的是由美国施乐(Xerox)公司创建并由Xerox、 Intel和DEC公司联合开发的基带局域网规范，是当今现有局域网采用的最通用的通信协议标准。<br><strong>传统以太网（10Mbits&#x2F;s速率）</strong> 最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</p><p>以太网有四种不同的物理层：  </p> <img src="../images/计算机网络.assets/image-20211110090223247.png" alt="image-20211110090223247" style="zoom:50%;" /><h4 id="星形以太网-10BASE-T"><a href="#星形以太网-10BASE-T" class="headerlink" title="星形以太网 10BASE-T"></a>星形以太网 10BASE-T</h4><p>1990 年， IEEE 制定出星形以太网 10BASE-T的标准 802.3i</p><p>特点：采用双绞线和星型拓扑。中心增加了<strong>集线器(hub)</strong></p><p>10BASE-T 的通信距离稍短，每个站到集线器的距离不超过 100 m  </p> <img src="../images/计算机网络.assets/image-20211110132602840.png" alt="image-20211110132602840" style="zoom:50%;" /><h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><p>使用电子器件模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行</p><p><strong>特点</strong>：</p><p>​使用集线器的以太网在<strong>逻辑上仍是一个总线网</strong>，各工作站使用的还是 CSMA&#x2F;CD 协议，并<strong>共享逻辑上的总线</strong>。</p><p>​集线器很像一个多接口的转发器，<strong>工作在物理层，不进行碰撞检测</strong></p><h4 id="以太网-Ethernet-的两个标准"><a href="#以太网-Ethernet-的两个标准" class="headerlink" title="以太网(Ethernet)的两个标准"></a>以太网(Ethernet)的两个标准</h4><p><strong>DIX Ethernet V2</strong>——世界上第一个局域网产品(以太网)的规约——10M&#x2F;s的以太网规约</p><p>I<strong>EEE802.3</strong>是抵押给IEEE802委员会指定的局域网标准</p><h4 id="IEEE802标准"><a href="#IEEE802标准" class="headerlink" title="IEEE802标准"></a>IEEE802标准</h4><p>IEEE于1980年2月成立一个局域网标准委员会，形成一系列的标准为<strong>IEEE 802 标准</strong>。  </p> <img src="../images/计算机网络.assets/image-20211110133144853.png" alt="image-20211110133144853" style="zoom:50%;" /><h3 id="3-4-2-以太网的层次结构"><a href="#3-4-2-以太网的层次结构" class="headerlink" title="3.4.2 以太网的层次结构"></a>3.4.2 以太网的层次结构</h3><p>IEEE 802委员会提出的局域网参考模型主要定义了物理层和数据链路层的规范</p><p><strong>物理层</strong>：物理层负责与传输介质的连接，并在传输介质上传输比特流，因此，它描述和规定了与传输介质接口的特性。  </p><p><strong>数据链路层</strong>： OSI模型中数据链路层的功能在IEEE802模型中分成了**两个子层(MAC和LLC)**。</p><h4 id="MAC和LLC"><a href="#MAC和LLC" class="headerlink" title="MAC和LLC"></a>MAC和LLC</h4><p><strong>逻辑链路控制 LLC (Logical Link Control)子层</strong>：屏蔽对各种不同物理网络的访问方法的差异，向上提供数据传输服务的统一的逻辑接口</p><p><strong>媒体接入控制 MAC (Medium Access Control)子层</strong>：控制对传输介质的访问，并在物理层的基础上实现无差错通信。该子层随不同的物理网络差异较大</p><p>好处：</p><p>​与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。<br>​<strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong>  </p> <img src="../images/计算机网络.assets/image-20211110133749001.png" alt="image-20211110133749001" style="zoom:50%;" /><p>TCP&#x2F;IP一般不考虑LLC子层：该体系经常使用的局域网是DIX Ethernet V2</p><h3 id="3-4-3-以太网的MAC层"><a href="#3-4-3-以太网的MAC层" class="headerlink" title="3.4.3 以太网的MAC层"></a>3.4.3 以太网的MAC层</h3><p>计算机要连接到局域网需要依靠网络接口板。<br>网络接口板又称为<strong>适配器</strong> (adapter) 或<strong>网络接口卡</strong> NIC (Network Interface Card)，或“<strong>网卡</strong>”</p><p>适配器的重要功能：<br>    进行串行&#x2F;并行转换。<br>    对数据进行缓存。<br>    在计算机的操作系统安装设备驱动程序。<br>    实现以太网协议。  </p> <img src="../images/计算机网络.assets/image-20211110134315032.png" alt="image-20211110134315032" style="zoom:50%;" /><h4 id="1-MAC层的硬件地址"><a href="#1-MAC层的硬件地址" class="headerlink" title="1. MAC层的硬件地址"></a>1. MAC层的硬件地址</h4><p>局域网中，硬件地址又称<strong>物理地址</strong>，或<strong>MAC地址</strong></p><p>地址严格来说是每一个站的”名字“或标识符，采用6字节(48位)，固化在网卡ROM中的</p><p>前三个字节(高位24位)：组织唯一标识符OUI</p><p>后三个字节(低位24位)：扩展唯一标识符EUI，<strong>必须保证生产出的适配器没有重复地址</strong></p> <img src="../images/计算机网络.assets/image-20211110135646122.png" alt="image-20211110135646122" style="zoom:50%;" /><p><strong>I&#x2F;G 位</strong>(Individual&#x2F;Group)：字段的第一字节的最低位<br>    I&#x2F;G 位 &#x3D; 0时，地址字段表示一个<strong>单位地址</strong><br>    I&#x2F;G 位 &#x3D; 1时，地址字段表示一个<strong>组地址</strong>，用来进行多播，此时，IEEE只分配地址字段前3个字节中的23位<br>    当 I&#x2F;G 位分别为 0 和 1 时，一个地址块可分别生成 223个单个站地址和 223 个组地址。<br>    所有 48 位都为 1 时，为广播地址。只能作为目的地址使用  </p><p><strong>G&#x2F;L 位</strong>(Global&#x2F;Local)：第一字节的最低第2位<br>    G&#x2F;L 位 &#x3D; 0时，是<strong>全球管理</strong>(保证在全球没有相同的地址)<br>    G&#x2F;L 位 &#x3D; 1时，是<strong>本地管理</strong></p><p>适配器检查MAC地址：<br>    如果是<strong>发往本站的帧</strong>则收下，然后再进行其他的处理<br>    否则就将此帧丢掉</p><p>发往本站的帧：<br>    <strong>单播</strong>(unicast)帧(一对一)<br>    <strong>广播</strong>(broadcast)帧(一对全体)<br>    <strong>多播</strong>(multicast)帧(一对多)</p><p>所有的适配器都至少能够识别前两种帧，即<strong>能够识别单播地址和广播地址</strong>。<br>有的适配器可用编程方法识别多播地址。<br>只有目的地址才能使用广播地址和多播地址。<br>以<strong>混杂方式</strong> (promiscuous mode) 工作的以太网适配器只要“听到”有帧在以太网上传输就都接收下来。  </p><h4 id="2-MAC帧的格式"><a href="#2-MAC帧的格式" class="headerlink" title="2.MAC帧的格式"></a>2.MAC帧的格式</h4><p>以太网MAC帧格式标准：**DIX Ethernet V2标准(常用)**、IEEE的802.3标准</p><h5 id="DIX-Ethernet-V2标准"><a href="#DIX-Ethernet-V2标准" class="headerlink" title="DIX Ethernet V2标准"></a>DIX Ethernet V2标准</h5> <img src="../images/计算机网络.assets/image-20211112150936823.png" alt="image-20211112150936823" style="zoom:50%;" /><p>类型字段：用来标识上一层使用的是什么协议，以便把收到的MAC帧交给上一层的协议。</p><p>同步码：实际传送的比MAC帧多8个字节；因为当一个站开始接收MAC帧时，没有与到达的比特流同步，因此MAC帧的开始若干比特无法接收，这样使得整个帧无效。这样需要插入同步码。  </p><p>数据字段：全称是<strong>MAC客户数据字段</strong>：46~1500字节</p><p>​当数据字段的长度小于46字节时，应在数据字段的后面加入整数字节的<strong>填充字段</strong>，以保证以太网的 MAC 帧长不小于 64 字节。  </p><p>无效的MAC帧：<br>    帧的长度不是整数个字节<br>    FCS检查有差错<br>    数据字段不在46~1500字节之间</p><p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。  </p><h5 id="IEEE802-3MAC标准"><a href="#IEEE802-3MAC标准" class="headerlink" title="IEEE802.3MAC标准"></a>IEEE802.3MAC标准</h5><p>与以太网V2 MAC 帧格式相似， 区别在于：<br>(1) IEEE 802.3 规定的 MAC 帧的第三个字段是“<strong>长度 &#x2F; 类型</strong>”。<br>    当这个字段值大于 0x0600 时（相当于十进制的 1536），就表示“类型”。这样的帧和以太网 V2 MAC 帧完全一样。<br>    当这个字段值小于 0x0600 时才表示“长度” 。</p><p>(2) 当“长度&#x2F;类型”字段值小于 0x0600 时，数据字段必须装入上面的逻辑链路控制 LLC 子层的 LLC 帧。</p><p>现在市场上流行的都是以太网V2 的 MAC 帧，但大家也常常把它称为 IEEE 802.3 标准的 MAC 帧。  </p><h3 id="3-4-4-扩展以太网"><a href="#3-4-4-扩展以太网" class="headerlink" title="3.4.4 扩展以太网"></a>3.4.4 扩展以太网</h3><p>局域网互联的原因：<br>(1) 局域网覆盖的距离有限<br>    单个局域网覆盖的距离往往不能满足应用的需要。<br>(2) 局域网能支持的连网计算机数目有限<br>    单个局域网所能连接的计算机数目往往不能满足应用的需要<br>(3) 局域网上能传输的通信量有限<br>    单个局域网所容许的通信量往往不能满足应用的需要。  </p><p>互联的本质：由于网络是分层次实现的，而局域网又各有不同的标准，因此网络互联的本质就是在不同的协议层次上实现协议的彼此转换。  </p><p>互联设备：<br>    在物理层上扩展：转发器(Repeater，重发器，中继器)、集线器(Hub)<br>    在数据链路层上扩展：网桥(Bridge)、交换机(Switch)</p><h4 id="转发器"><a href="#转发器" class="headerlink" title="转发器"></a>转发器</h4><p>别称：重发器、中继器</p><p>工作在物理层上，扩展以太网的物理覆盖范围</p><p>功能：<br>    连接两个同轴电缆以太网，将信号放大整形后，延申网络的传输距离<br>    不具有信号通路的选择功能<br>    随着双绞线成为以太网主流，已很少使用转发器</p><h4 id="集线器-1"><a href="#集线器-1" class="headerlink" title="集线器"></a>集线器</h4><p>使用多个集线器可连成更大的、 多级星形结构的以太网。  </p> <img src="../images/计算机网络.assets/image-20211112154628015.png" alt="image-20211112154628015" style="zoom:50%;" /><p>(1) 集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。</p><p>(2) 使用集线器的以太网在<strong>逻辑上仍是一个总线网</strong>，各工作站使用的还是 CSMA&#x2F;CD 协议，并<strong>共享逻辑上的总线</strong>。</p><p>(3) 集线器很像一个多接口的转发器， <strong>工作在物理层</strong>。</p><p>(4) 集线器采用了专门的芯片，进行自适应串音回波抵消，减少了近端串音。  </p><p>优点：<br>    使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。<br>    扩大了以太网覆盖的地理范围。  </p><p>缺点<br>    碰撞域增大了，但总的吞吐量并未提高。<br>    如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来<br>    集线器是个多接口的转发器，  不能把帧进行缓存</p><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p>网桥工作在数据链路层。</p><p>根据 MAC 帧的目的地址对收到的帧进行<strong>转发</strong>和<strong>过滤</strong></p><p>网桥的工作原理<br>    网桥从端口接收网段上传送的各种帧；<br>    <strong>每当收到一个帧时，先暂存在缓存中。</strong><br>    若此帧未出错，且欲发送的目的站的MAC地址属于另外一个网段，则通过<strong>查找“转发表”</strong> ，将收到的帧送往对应的端口转发。<br>    若此帧出错，则丢弃该帧。<br>    同一个网段内的帧，不会被网桥转发，不会增加网络负担  </p> <img src="../images/计算机网络.assets/image-20211112155943205.png" alt="image-20211112155943205" style="zoom:50%;" /><p>网桥使各网段成为隔离开的碰撞域</p><p>优点<br>    过滤通信量、扩大了物理范围、提高了可靠性。<br>    可互连不同物理层、不同 MAC 子层和不同速率（如10 Mb&#x2F;s 和 100 Mb&#x2F;s 以太网）的局域网。<br>缺点<br>    存储转发增加了时延。<br>    在 MAC 子层并没有流量控制功能。<br>    具有不同 MAC 子层的网段桥接在一起时时延更大。<br>    网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。  </p><p><strong>广播风暴</strong>：</p><p>​广播风暴（broadcast storm） 简单的讲是指当广播数据充斥网络无法处理， 并占用大量网络带宽，导致正常业务不能运行，甚至彻底瘫痪，这就发生了“广播风暴”。<br>​一个数据帧或包被传输到本地网段 （由广播域定义）上的每个节点就是广播；由于网络拓扑的设计和连接问题，或其他原因导致广播在网段内大量复制，传播数据帧，导致网络性能下降，甚至网络瘫痪，这就是广播风暴。  </p><h5 id="网桥和集线器的区别"><a href="#网桥和集线器的区别" class="headerlink" title="网桥和集线器的区别"></a>网桥和集线器的区别</h5><p>集线器在转发帧时，不对传输媒体进行检测。</p><p>网桥在转发帧之前必须执行 CSMA&#x2F;CD 算法。<br>    若在发送过程中出现碰撞，就必须停止发送和进行退避。<br>    在这一点上网桥的接口很像一个网卡。但网桥却没有网卡。</p><p>由于网桥没有网卡，因此网桥并不改变它转发的帧的源地址。  </p><h4 id="多端口网桥——以太网交换机"><a href="#多端口网桥——以太网交换机" class="headerlink" title="多端口网桥——以太网交换机"></a>多端口网桥——以太网交换机</h4><p>以太网交换机的实质是：交换式集线器，是一个多接口的网桥</p><p>工作在数据链路层</p><h5 id="以太网交换机的特点"><a href="#以太网交换机的特点" class="headerlink" title="以太网交换机的特点"></a>以太网交换机的特点</h5><ol><li><p>每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都<strong>工作在全双工方式</strong>。</p></li><li><p>以太网交换机具有<strong>并行性</strong>。<br>能同时连通多对接口， 使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据。</p></li><li><p>相互通信的主机都是独占传输媒体，无碰撞地传输数据。  </p></li><li><p>以太网交换机的<strong>接口有存储器</strong>， 能在输出端口繁忙时把到来的帧进行缓存。</p></li><li><p>以太网交换机是一种即插即用设备，其内部的帧交换表（又称为地址表）是通过<strong>自学习算法</strong>自动地逐渐建立起来</p></li><li><p>以太网<strong>交换机</strong>使用了<strong>专用的交换结构芯片</strong>，<strong>用硬件转发</strong>，其转发速率要比<strong>使用软件转发的网桥</strong>快很多。</p></li></ol><h5 id="以太网交换机的优点"><a href="#以太网交换机的优点" class="headerlink" title="以太网交换机的优点"></a>以太网交换机的优点</h5><p><strong>用户独享带宽，增加了总容量。</strong></p><p>对于普通 10 Mbit&#x2F;s 的共享式以太网，若共有 N 个用户，则每个用户占有的平均带宽只有总带宽 (10 Mbit&#x2F;s)的 N 分之一。<br>使用以太网交换机（交换式以太网）时，虽然在每个接口到主机的带宽还是 10 Mbit&#x2F;s，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此对于拥有 N 个接口的交换机的总容量为 N×10Mbit&#x2F;s</p> <img src="../images/计算机网络.assets/image-20211112162437485.png" alt="image-20211112162437485" style="zoom:50%;" /><h5 id="以太网交换机的交换方式"><a href="#以太网交换机的交换方式" class="headerlink" title="以太网交换机的交换方式"></a>以太网交换机的交换方式</h5><p><strong>存储转发方式</strong><br>    把整个数据帧先缓存后再进行处理。<br>直通 (cut-through) 方式<br>    接收数据帧的同时就立即按数据帧的目的 MAC 地址决定该帧的转发接口，因而提高了帧的转发速度。<br>    <strong>缺点</strong>是它<strong>不检查差错</strong>就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</p><p>在某些情况下，仍需要采用<strong>基于软件的</strong>存储转发方式进行交换，例如，当需要进行线路速率匹配、协议转换或差错检测时。</p><h5 id="以太网交换机的自学习功能"><a href="#以太网交换机的自学习功能" class="headerlink" title="以太网交换机的自学习功能"></a>以太网交换机的自学习功能</h5><p>以太网交换机运行自学习算法自动维护交换表。</p><p>开始时，以太网交换机里面的交换表是空的。</p> <img src="../images/计算机网络.assets/image-20211112162900829.png" alt="image-20211112162900829" style="zoom:50%;" /><p><strong>自学习算法</strong>：</p><p>A 先向 B 发送一帧，从接口 1 进入到交换机。步骤如下：</p><ol><li>交换机收到帧后，<strong>先查找交换表</strong>，没有查到应从哪个接口转发这个帧。</li><li>交换机把这个帧的<strong>源地址 A</strong> 和<strong>接口 1 写入交换表</strong>中，并向除接口1以外的所有的接口<strong>广播这个帧</strong>。</li><li>C 和 D 将丢弃这个帧，因为目的地址不对。只 B 才收下这个目的地址正确的帧。这也称为<strong>过滤</strong>。</li><li>从新写入交换表的项目 (A, 1) 可以看出，以后不管从哪一个接口收到帧，只要其目的地址是A，就应当把收到的帧从接口1转发出去。</li></ol><p>B 通过接口 3 向 A 发送一帧。步骤如下：</p><ol><li>交换机查找交换表， 发现交换表中的 MAC 地址有 A。表明要发送给A的帧（即目的地址为 A 的帧）应从接口1转发。 于是就把这个帧传送到接口 1 转发给 A。 显然，现在已经没有必要再广播收到的帧。</li><li>交换表这时新增加的项目 (B, 3)，表明今后如有发送给 B 的帧，就应当从接口 3 转发出去。</li><li>经过一段时间后， 只要主机 C 和 D 也向其他主机发送帧， 以太网交换机中的交换表就会把转发到 C 或 D 应当经过的接口号（2 或 4）写入到交换表中。</li></ol><p><strong>有效时间</strong>：考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更新交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间（计时器）。过期的项目就自动被删除。</p><p>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</p><h5 id="交换机自学习和转发帧的步骤归纳"><a href="#交换机自学习和转发帧的步骤归纳" class="headerlink" title="交换机自学习和转发帧的步骤归纳"></a>交换机自学习和转发帧的步骤归纳</h5><p>交换机收到一帧后先查找交换表中与收到帧的源地址有无相匹配的项目。<br>    如没有，就在交换表中增加一个项目（源地址、进入的接口和有效时间）。<br>    如有，则把原有的项目进行更新（进入的接口或有效时间）。</p><p>转发帧。 查找交换表中与收到帧的目的地址有无相匹配的项目。<br>    如没有，则向所有其他接口（进入的接口除外）转发(Flooding)。<br>    如有，则按交换表中给出的接口进行转发。<br>    若交换表中给出的接口就是该帧进入交换机的接口，则应丢弃这个帧（因为这时不需要经过交换机进行转发）。  </p><h4 id="交换机使用了生成树协议"><a href="#交换机使用了生成树协议" class="headerlink" title="交换机使用了生成树协议"></a>交换机使用了生成树协议</h4><p>为了增加网络的可靠性，会增加<strong>冗余链路</strong>。 自学习的过程就可能导致以太网帧在网络的某个环路中无限制地兜圈子。  </p><p>如图， 假定开始时， 交换机 #1 和 #2 的交换表都是空的， 主机 A 通过接口交换机 #1 向主机 B 发送一帧。  </p> <img src="../images/计算机网络.assets/image-20211112164037058.png" alt="image-20211112164037058" style="zoom:50%;" /><p>按交换机自学习和转发方法，该帧的某个走向如下：离开交换机 #1 的接口 3 → 交换机 #2 的接口 1 → 接口 2 → 交换机 #1 的接口 4 → 接口 3 → 交换机 #2 的接口 1 →……。这样就无限制地循环兜圈子下去，白白消耗了网络资源  </p><p>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong> (Spanning Tree Protocol)。<br>    其要点是： 不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</p><p>基本原理：选择一个交换机作为生成树的根，然后以最短路径为依据，找到树上的每一个结点，使整个连通的网络中不存在回路  </p> <img src="../images/计算机网络.assets/image-20211112164701562.png" alt="image-20211112164701562" style="zoom:50%;" /><h5 id="总线以太网和星形以太网比较"><a href="#总线以太网和星形以太网比较" class="headerlink" title="总线以太网和星形以太网比较"></a>总线以太网和星形以太网比较</h5><p>早期， 以太网采用无源的总线结构。</p><p>现在， 采用以太网交换机的星形结构成为以太网的首选拓扑。</p><p>总线以太网使用 CSMA&#x2F;CD 协议，以半双工方式工作。</p><p>以太网交换机不使用共享总线，没有碰撞问题，因此不使用 CSMA&#x2F;CD 协议，而是以全双工方式工作。 但<strong>仍然采用以太网的帧结构</strong>。  </p><h3 id="3-4-5-虚拟局域网"><a href="#3-4-5-虚拟局域网" class="headerlink" title="3.4.5 虚拟局域网"></a>3.4.5 虚拟局域网</h3><p>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</p><p><strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的与物理位置无关的逻辑组， 这些网段具有某些共同的需求。</p><p>每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</p><p><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong>  </p> <img src="../images/计算机网络.assets/image-20211112165411719.png" alt="image-20211112165411719" style="zoom:50%;" /><p>10台计算机划分为三个虚拟局域网：$VLAN_1, VLAN_2, VLAN_3$</p><p>当$B_1$向$VLAN_2$工作组内成员发送数据时，工作站$B_2$和$B_3$将会收到广播的信息。</p><p>$B_1$发送数据时，工作站$A_1$，$A_2$和$C_1$都不会收到$B_1$发出的广播信息。  </p><p>虚拟局域网限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息(即<strong>广播风暴</strong>)而引起性能恶化。  </p><h4 id="虚拟局域网使用的以太网帧格式"><a href="#虚拟局域网使用的以太网帧格式" class="headerlink" title="虚拟局域网使用的以太网帧格式"></a>虚拟局域网使用的以太网帧格式</h4><p>IEEE 批准了 802.3ac 标准， 该标准定义了以太网的帧格式的扩展， 以支持虚拟局域网。<br>虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为 **VLAN 标记 (tag)**，用来指明发送该帧的计算机属于哪一个虚拟局域网。<br>插入 VLAN 标记得出的帧称为 802.1Q 帧或带标记的以太网帧。  </p> <img src="../images/计算机网络.assets/image-20211112165836744.png" alt="image-20211112165836744" style="zoom:50%;" /><h4 id="冲突域-x2F-碰撞域与广播域"><a href="#冲突域-x2F-碰撞域与广播域" class="headerlink" title="冲突域&#x2F;碰撞域与广播域"></a>冲突域&#x2F;碰撞域与广播域</h4><p>连接在同一个网桥或交换机端口的计算机构成一个冲突域，即处于同一个端口的计算机在某一个时刻只能有一台计算机发送数据，其他处于监听状态，如果出现两台或两台以上的计算机同时发送数据，便会冲突。</p><p>网桥或交换机的本质是通过将网络分割成多个冲突域来增强网络服务。</p><p>因为网桥会向所有端口转发未知目的端口的数据帧，所以网桥&#x2F;交换网络会产生广播风暴。  </p><h4 id="虚拟局域网的优点"><a href="#虚拟局域网的优点" class="headerlink" title="虚拟局域网的优点"></a>虚拟局域网的优点</h4><ol><li><p>安全性好</p><p>没有路由的情况下，不同虚拟局域网间不能相互通信</p></li><li><p>网络分段</p><p>可将物理网络按逻辑分段，而不是按物理分段。</p><p>可将不同地点、不同部门的计算机划分在一个虚拟局域网上</p></li><li><p>提供较好的灵活性</p><p>方便地将一个站点加入或从一个VLAN中删除。</p></li></ol><h3 id="3-4-6-高速以太网"><a href="#3-4-6-高速以太网" class="headerlink" title="3.4.6 高速以太网"></a>3.4.6 高速以太网</h3><h4 id="100BASE-T以太网"><a href="#100BASE-T以太网" class="headerlink" title="100BASE-T以太网"></a>100BASE-T以太网</h4><p>速率达到或超过 100 Mbit&#x2F;s 的以太网称为<strong>高速以太网</strong>  </p><p>100BASE-T 在双绞线上传送 100 Mbit&#x2F;s 基带信号的星形拓扑以太网，仍使用 IEEE 802.3 的CSMA&#x2F;CD 协议，工作方式为<strong>半双工</strong>。</p><p>100BASE-T 以太网又称为<strong>快速以太网</strong> (Fast Ethernet)。</p><p>用户使用100Mbit的适配器或100Mbit&#x2F;s的集线器或交换机，可以升级到100Mbit&#x2F;s</p><p>1995 年IEEE已把 100BASE-T 的快速以太网定为正式标准，其代号为 <strong>IEEE 802.3u</strong>。  </p><h5 id="100BASE-T-以太网的特点"><a href="#100BASE-T-以太网的特点" class="headerlink" title="100BASE-T 以太网的特点"></a>100BASE-T 以太网的特点</h5><p>可在全双工方式下工作而无冲突发生。 <strong>在全双工方式下工作时，不使用 CSMA&#x2F;CD 协议。</strong></p><p><strong>MAC 帧格式仍然是 802.3 标准规定的。</strong></p><p>保持最短帧长不变，仍为64字节</p><p>一个网段的最大电缆长度为 100 m</p><p>争用期使5.12 µs</p><p>帧间时间间隔从原来的 9.6 µs 改为现在的 0.96µs。  </p><h5 id="100-Mbit-x2F-s-以太网的三种不同的物理层标准"><a href="#100-Mbit-x2F-s-以太网的三种不同的物理层标准" class="headerlink" title="100 Mbit&#x2F;s 以太网的三种不同的物理层标准"></a>100 Mbit&#x2F;s 以太网的三种不同的物理层标准</h5> <img src="../images/计算机网络.assets/image-20211112171216816.png" alt="image-20211112171216816" style="zoom:50%;" /><h4 id="吉比特以太网"><a href="#吉比特以太网" class="headerlink" title="吉比特以太网"></a>吉比特以太网</h4><p>允许在 1 Gbit&#x2F;s 下以全双工和半双工两种方式工作。</p><p>使用 IEEE 802.3 协议规定的帧格式。</p><p><strong>在半双工方式下使用 CSMA&#x2F;CD 协议，全双工方式不使用 CSMA&#x2F;CD 协议。</strong></p><p>与 10BASE-T 和 100BASE-T 技术向后兼容。</p><p>吉比特以太网可用作现有网络的主干网，也可在高带宽（高速率）的应用场合中。  </p><h5 id="吉比特以太网的物理层"><a href="#吉比特以太网的物理层" class="headerlink" title="吉比特以太网的物理层"></a>吉比特以太网的物理层</h5><p>使用两种成熟的技术： 一种来自现有的以太网，另一种则是美国国家标准协会 ANSI 制定的光纤通道 FC (Fiber Channel)  </p> <img src="../images/计算机网络.assets/image-20211112171441345.png" alt="image-20211112171441345" style="zoom:50%;" /><h5 id="半双工方式工作的吉比特以太网"><a href="#半双工方式工作的吉比特以太网" class="headerlink" title="半双工方式工作的吉比特以太网"></a>半双工方式工作的吉比特以太网</h5><p>吉比特以太网工作在半双工方式时，就必须进行碰撞检测。</p><p>由于数据率提高了，因此只有减小最大电缆长度或增大帧的最小长度。<br>为保持 64 字节最小帧长度，以及 100 米的网段的最大长度，吉比特以太网增加了两个功能：<br>    <strong>载波延伸</strong> (carrier extension)<br>    <strong>分组突发</strong> (packet bursting)<br>当吉比特以太网工作在全双工方式时， <strong>不使用</strong>载波延伸和分组突发  </p><h5 id="载波延伸"><a href="#载波延伸" class="headerlink" title="载波延伸"></a>载波延伸</h5><p>使最短帧长仍为 64 字节（这样可以保持兼容性），同时<strong>将争用时间增大为 512 字节</strong>。<br>凡发送的 MAC 帧长不足 512 字节时，就用一些特殊字符填充在帧的后面，使MAC 帧的发送长度增大到 512 字节。接收端在收到以太网的 MAC 帧后，要将所填充的特殊字符删除后才向高层交付。  </p> <img src="../images/计算机网络.assets/image-20211112171845591.png" alt="image-20211112171845591" style="zoom:50%;" /><h5 id="分组突发"><a href="#分组突发" class="headerlink" title="分组突发"></a>分组突发</h5><p>当很多短帧要发送时，第一个短帧要采用载波延伸方法进行填充，随后的一些短帧则可一个接一个地发送，只需留有必要的帧间最小间隔即可。这样就形成可一串分组的突发，直到达到1500 字节或稍多一些为止。  </p> <img src="../images/计算机网络.assets/image-20211112171922961.png" alt="image-20211112171922961" style="zoom:50%;" /><h5 id="吉比特以太网配置举例"><a href="#吉比特以太网配置举例" class="headerlink" title="吉比特以太网配置举例"></a>吉比特以太网配置举例</h5> <img src="../images/计算机网络.assets/image-20211112172006666.png" alt="image-20211112172006666" style="zoom:50%;" /><h4 id="10吉比特以太网和更快的以太网"><a href="#10吉比特以太网和更快的以太网" class="headerlink" title="10吉比特以太网和更快的以太网"></a>10吉比特以太网和更快的以太网</h4><p>10 吉比特以太网（10GE） 并非把吉比特以太网的速率简单地提高到 10 倍，其主要特点有：<br>    与 10 Mbit&#x2F;s、 100 Mbit&#x2F;s 和 1 Gbit&#x2F;s 以太网的帧格式完全相同。<br>    保留了 802.3 标准规定的以太网最小和最大帧长，便于升级。<br>    <strong>只工作在全双工方式</strong>， 因此没有争用问题，也不使用 CSMA&#x2F;CD 协议。  </p> <img src="../images/计算机网络.assets/image-20211112172053589.png" alt="image-20211112172053589" style="zoom:50%;" /><h5 id="更快的以太网"><a href="#更快的以太网" class="headerlink" title="更快的以太网"></a>更快的以太网</h5><p>以太网的技术发展得很快。</p><p>在 10GE 之后又制订了 40GE&#x2F;100GE（即 40 吉比特以太网和 100 吉比特以太网）的标准 IEEE 802.3ba-2010 和802.3bm-2015。</p><p>40GE&#x2F;100GE 只工作在全双工的传输方式（因而不使用CSMA&#x2F;CD 协议），并仍保持了以太网的帧格式以及 802.3标准规定的以太网最小和最大帧长。</p><p>100GE 在使用单模光纤传输时，仍然可以达到 40 km 的传输距离，但这是需要波分复用（使用 4 个波长复用一根光纤，每一个波长的有效传输速率是 25 Gbit&#x2F;s）。</p> <img src="../images/计算机网络.assets/image-20211112172157244.png" alt="image-20211112172157244" style="zoom:50%;" /><h5 id="端到端的以太网传输"><a href="#端到端的以太网传输" class="headerlink" title="端到端的以太网传输"></a>端到端的以太网传输</h5><p>以太网的工作范围已经从局域网（校园网、企业网）扩大到城域网和广域网，从而实现了<strong>端到端的以太网传输</strong>。</p><p>这种工作方式的好处有：<br>    技术成熟；<br>    互操作性很好， 不同厂商生产的以太网都能可靠地进行互操作；<br>    在广域网中使用以太网时价格便宜；<br>    采用统一的以太网帧格式，简化了操作和管理， 不需要在进行帧的格式转换。  </p><h5 id="以太网从-10-Mbit-x2F-s-到100-Gbit-x2F-s-的演进"><a href="#以太网从-10-Mbit-x2F-s-到100-Gbit-x2F-s-的演进" class="headerlink" title="以太网从 10 Mbit&#x2F;s 到100 Gbit&#x2F;s 的演进"></a>以太网从 10 Mbit&#x2F;s 到100 Gbit&#x2F;s 的演进</h5><p>以太网从 10 Mbit&#x2F;s 到 100 Gbit&#x2F;s 的演进证明了以太网是：<br>    可扩展的（从 10 Mbit&#x2F;s 到 100 Gbit&#x2F;s）；<br>    灵活的（多种传输媒体、全&#x2F;半双工、共享&#x2F;交换）；<br>    易于安装；<br>    稳健性好。  </p><h4 id="使用以太网进行宽带接入"><a href="#使用以太网进行宽带接入" class="headerlink" title="使用以太网进行宽带接入"></a>使用以太网进行宽带接入</h4><p>IEEE 在 2001 年初成立了 802.3 EFM 工作组，专门研究高速以太网的宽带接入技术问题。</p><p>以太网宽带接入具有以下特点：<br>    可以提供<strong>双向</strong>的宽带通信。<br>    可以根据用户对带宽的需求灵活地进行带宽<strong>升级</strong>。<br>    可以实现端到端的以太网传输，<strong>中间不需要再进行帧格式的转换</strong>。 这就提高了数据的传输效率且降低了传输的成本。<br>    <strong>但是不支持用户身份鉴别。</strong></p><h5 id="PPPoE"><a href="#PPPoE" class="headerlink" title="PPPoE"></a>PPPoE</h5><p>PPPoE (PPP over Ethernet) 的意思是“在以太网上运行 PPP” ，它把 PPP 协议与以太网协议结合起来 —— 将 PPP 帧再封装到以太网中来传输。</p><p>现在的光纤宽带接入 FTTx 都要使用 PPPoE 的方式进行接入，不需要使用调制解调器，只有一个RJ-45插口。</p><p>在 PPPoE 弹出的窗口中键入在网络运营商购买的用户名和密码，就可以进行宽带上网了。</p><p>利用 ADSL 进行宽带上网时，从用户个人电脑到家中的 ADSL调制解调器之间，也是使用 RJ-45 和 5 类线（即以太网使用的网线）进行连接的，并且也是使用 PPPoE 弹出的窗口进行拨号连接的。 ADSL调制解调器将以太网帧转换成PPP帧。  </p><h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h1><h2 id="4-1-网络层提供的两种服务"><a href="#4-1-网络层提供的两种服务" class="headerlink" title="4.1 网络层提供的两种服务"></a>4.1 网络层提供的两种服务</h2><h3 id="面向连接的服务"><a href="#面向连接的服务" class="headerlink" title="面向连接的服务"></a>面向连接的服务</h3><p>可靠交付由<strong>网络</strong>负责</p><p>通信之前先建立<strong>虚电路</strong> (Virtual Circuit)，以保证双方通信所需的一切网络资源。  </p><p>再使用<strong>可靠传输</strong>的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复  </p><p>可靠传输采用应答来实现，即可靠&#x2F;不可靠可用有&#x2F;无应答来区分  </p><p>面向连接</p><p>​本质是保证数据的<strong>顺序传送</strong>；<br>​特征是数据传送必须经过建立连接、传送数据和拆除连接三个阶段。  </p><p><strong>可靠性与是否连接没有关系</strong></p><p>虚电路服务：主机1给主机2发送的所有分组都沿着同一条虚电路传送<br>    虚电路表示这只是一条<strong>逻辑上的连接</strong>，分组都沿着这条逻辑连接<strong>按照存储转发方式传送</strong>， 而并不是真正建立了一条物理连接。  </p><p>数据链路：相邻两节点间的数据传输通道。<br>逻辑信道：相邻两点间的一条数据链路可支持多条逻辑信道，为多对通信服务<br>                    大白话就是两节点之间的其中一条数据链路</p><h3 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h3><p>网络提供数据报服务</p><p>即网络层向上只提供简单灵活的、 **无连接的、尽最大努力交付(不可靠)**的数据报服务，对源主机没有任何承诺。  </p><p>网络在发送分组时不需要先建立连接。每一个分组（即 IP数据报）携带完整的地址信息， <strong>独立传输，独立寻址</strong>，彼此之间不需要保持任何的顺序关系（不进行编号）。  </p><p><strong>网络层不提供服务质量的承诺。</strong>  所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。  </p><p>好处：网络的造价大大降低，运行方式灵活，能够适应多种应用  </p><h3 id="虚电路服务与数据报服务的优缺点"><a href="#虚电路服务与数据报服务的优缺点" class="headerlink" title="虚电路服务与数据报服务的优缺点"></a>虚电路服务与数据报服务的优缺点</h3><h4 id="传送代价方面"><a href="#传送代价方面" class="headerlink" title="传送代价方面"></a>传送代价方面</h4><p>网络上传送的报文长度，在很多情况下都很短。</p><p>用数据报既迅速又经济。</p><p>若用虚电路，为了传送一个分组而建立虚电路和释放虚电路就显得太浪费网络资源了。  </p><h4 id="交换节点存储转发方面"><a href="#交换节点存储转发方面" class="headerlink" title="交换节点存储转发方面"></a>交换节点存储转发方面</h4><p>在使用数据报时，每个分组必须携带完整的地址信息。</p><p>在使用虚电路的情况下，每个分组不需要携带完整的目的地址，而仅需要有个很简单的虚电路号码的标志。</p><p>这就使分组的控制信息部分的比特数减少，因而减少了额外开销。  </p><h4 id="差错和流量控制方面"><a href="#差错和流量控制方面" class="headerlink" title="差错和流量控制方面"></a>差错和流量控制方面</h4><p>在使用数据报时，主机承担端到端的差错控制和流量控制。</p><p>在使用虚电路时，分组按顺序交付，网络可以负责差错控制和流量控制。  </p><h4 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h4><p>数据报服务对军事通信有其特殊的意义。当某个结点发生故障时，后续的分组就可另选路由，因而提高了可靠性。</p><p>但在使用虚电路时，结点发生故障就必须重新建立另一条虚电路。</p><p>数据报服务还很适合于将一个分组发送到多个地址(即广播或多播)。  </p><table><thead><tr><th>对比的方面</th><th>虚电路服务</th><th>数据报服务</th></tr></thead><tbody><tr><td>思路</td><td>可靠通信应当由网络来保证</td><td>可靠通信应当由用户主机来保证</td></tr><tr><td>连接的建立</td><td>必须有</td><td>不需要</td></tr><tr><td>终点地址</td><td>仅在连接建立阶段使用，每个分组使用短的虚电路号</td><td>每个分组都有终点的完整地址</td></tr><tr><td>分组的转发</td><td>属于同一条虚电路的分组均按照同一路由进行转发</td><td>每个分组独立选择路由进行转发</td></tr><tr><td>当结点出故障时</td><td>所有通过出故障的结点的虚 电路均不能工作</td><td>出故障的结点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td>分组的顺序</td><td>总是按发送顺序到达终点</td><td>到达终点时不一定按发送顺序</td></tr><tr><td>端到端的差错处 理和流量控制</td><td>可以由网络负责，也可以由 用户主机负责</td><td>由用户主机负责</td></tr></tbody></table><h2 id="4-2-网际协议IP-Internet-Protocol"><a href="#4-2-网际协议IP-Internet-Protocol" class="headerlink" title="4.2 网际协议IP(Internet Protocol)"></a>4.2 网际协议IP(Internet Protocol)</h2><p>与 IP 协议配套使用的还有三个协议：<br>    地址解析协议 ARP(Address Resolution Protocol)<br>    网际控制报文协议 ICMP(Internet Control Message Protocol)<br>    网际组管理协议 IGMP(Internet Group Management Protocol)  </p> <img src="../images/计算机网络.assets/image-20211113133725077.png" alt="image-20211113133725077" style="zoom:50%;" /><h3 id="4-2-1-虚拟互连网络"><a href="#4-2-1-虚拟互连网络" class="headerlink" title="4.2.1 虚拟互连网络"></a>4.2.1 虚拟互连网络</h3><p>将网络互相连接起来要使用一些中间设备，中间设备又称为<strong>中间系统</strong>或<strong>中继 (relay)系统</strong>。有以下五种不同的中间设备：<br>    物理层中继系统： <strong>转发器</strong> (repeater)。<br>    数据链路层中继系统： <strong>网桥</strong> 或 <strong>交换机</strong>。<br>    网络层中继系统： <strong>路由器</strong> (router)。<br>    网络层以上的中继系统： <strong>网关</strong> (gateway)。  </p><p>转发器或网桥知识把一个网络扩大，仍然是一个网络</p><p>网络互连都是指用<strong>路由器</strong>进行网络互连和路由选择。   </p><p><strong>虚拟互连网络</strong>也就是逻辑互连网络，它的意思就是互连起来的各种<strong>物理网络的异构性</strong>本来是客观存在的，但是我们利用 <strong>IP 协议</strong>就可以使这些性能各异的网<br>络在网络层上看起来好像是一个<strong>统一的网络</strong>。  </p><p>使用 IP 协议的虚拟互连网络可简称为 <strong>IP 网</strong>。</p><p><strong>如果在这种覆盖全球的 IP 网的上层使用 TCP 协议，那么就是现在的互联网 (Internet)。</strong>  </p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p><strong>路由器</strong>在网际互连中的作用：主机 A 向主机 B 发送数据报  ，先要检查目的主机 B 是否与源主机 A 连接在同一个网络上，是则将数据报<strong>直接交付</strong>给目的主机B，否则通过路由器转发则是间接交付</p><p>路由器是一种<strong>网络层设备</strong></p><p>主要作用：<strong>连通不同的网络</strong>、<strong>选择信息传送的线路</strong>。</p><h4 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h4><p>路由器是一种具有多个输入端口和多个输出端口的<strong>专用计算机</strong>，其任务是<strong>转发分组</strong>。</p><p><strong>路由器的转发分组正是网络层的主要工作。</strong>  </p><h5 id="典型的路由器结构"><a href="#典型的路由器结构" class="headerlink" title="典型的路由器结构"></a>典型的路由器结构</h5><p>整个的路由器结构可划分为两大部分：路由选择部分、分组转发部分</p><p><strong>路由选择部分</strong><br>    也叫做控制部分，其核心构件是路由选择处理机。<br>    路由选择处理机的任务是根据所选定的路由选择协议构造出<strong>路由表</strong>，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。  </p><p><strong>分组转发部分</strong>由三部分组成：<br>    <strong>交换结构</strong> (switching fabric)：又称为交换组织，其作用是根据转发表  (forwarding table) 对分组进行处理。<br>    <strong>一组输入端口</strong><br>    <strong>一组输出端口</strong><br>（请注意：这里的端口就是硬件接口）  </p><p>“<strong>转发</strong>”(forwarding) 就是路由器根据转发表将用户的 IP 数据报从合适的端口转发出去。<br>“<strong>路由选择</strong>”(routing) 则是按照分布式算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由。<br>路由表是根据路由选择算法得出的。而转发表是从路由表得出的。</p><p>输入端口中的<strong>查找和转发功能</strong>：</p> <img src="../images/计算机网络.assets/image-20211113141844717.png" alt="image-20211113141844717" style="zoom:50%;" /><p>输出端口：</p> <img src="../images/计算机网络.assets/image-20211113142007591.png" alt="image-20211113142007591" style="zoom:50%;" /><h5 id="分组丢弃"><a href="#分组丢弃" class="headerlink" title="分组丢弃"></a>分组丢弃</h5><p>​若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。</p><p>​<strong>路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因。</strong></p><h4 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h4><p><strong>交换结构把分组从一个输入端口转移到某个合适的输出端口。</strong></p><p>实现交换有多种方法。常用交换方法有三种：通过存储器、通过总线、通过纵横交换结构</p><h5 id="通过存储器"><a href="#通过存储器" class="headerlink" title="通过存储器"></a>通过存储器</h5><p>最早使用的路由器就是利用普通的计算机，用计算机的CPU作为路由器的路由选择处理机，路由器的输入和输出端口和操作系统中的I&#x2F;O设备一样。  </p><p>输入端口收到分组时，用中断方式通知路由选择处理机</p> <img src="../images/计算机网络.assets/image-20211113142940712.png" alt="image-20211113142940712" style="zoom:50%;" /><h5 id="通过总线"><a href="#通过总线" class="headerlink" title="通过总线"></a>通过总线</h5><p>数据报从输入端口通过<strong>共享的总线</strong>直接传送到合适的输出端口，而<strong>不需要路由选择处理机的干预。</strong></p><p>现代技术将总线的带宽提高到<strong>每秒吉比特</strong>的速度</p> <img src="../images/计算机网络.assets/image-20211113143052686.png" alt="image-20211113143052686" style="zoom:50%;" /><h5 id="通过纵横交换结构"><a href="#通过纵横交换结构" class="headerlink" title="通过纵横交换结构"></a>通过纵横交换结构</h5><p>这种交换结构常称为<strong>互连网络</strong></p> <img src="../images/计算机网络.assets/image-20211113143120198.png" alt="image-20211113143120198" style="zoom:50%;" /><h3 id="4-2-2-分类的IP地址"><a href="#4-2-2-分类的IP地址" class="headerlink" title="4.2.2 分类的IP地址"></a>4.2.2 分类的IP地址</h3><h4 id="IP地址及其表示方法"><a href="#IP地址及其表示方法" class="headerlink" title="IP地址及其表示方法"></a>IP地址及其表示方法</h4><p>IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是<strong>唯一的 32 位的标识符</strong>。  </p><p>IP地址的编址方法：分类的IP地址、子网的划分、构成超网</p><h5 id="分类IP地址"><a href="#分类IP地址" class="headerlink" title="分类IP地址"></a>分类IP地址</h5><p>将IP地址划分为若干个固定类（A - E类）。</p><p>每一类地址都由两个固定长度的<strong>字段</strong>组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号 host-id</strong>，它标志该主机（或路由器）。</p><p><strong>主机号在它前面的网络号所指明的网络范围内必须是唯一的。</strong></p><p>由此可见， <strong>一个 IP 地址在整个互联网范围内是唯一的</strong>。  </p> <img src="../images/计算机网络.assets/image-20211113145223287.png" alt="image-20211113145223287" style="zoom:50%;" /><p>这种两级的IP地址可以记为：IP地址 ::&#x3D;{&lt;网络号&gt;, &lt;主机号&gt;}  </p><p>​::&#x3D; 代表 “定义为”</p> <img src="../images/计算机网络.assets/image-20211113145344804.png" alt="image-20211113145344804" style="zoom:50%;" /><p>好处：</p><p>​各种网络差异很大，有的网络拥有很多主机，而有的网络拥有的主机数目很少。</p><p>​将IP地址划分成不同类别A、 B、 C可以满足不同用户的需求。</p><p>​当一个单位申请到一个IP地址时，只是申请了一个网络号Net-id，具体的主机号由各个单位自行分配。  </p><h5 id="点分十进制记法"><a href="#点分十进制记法" class="headerlink" title="点分十进制记法"></a>点分十进制记法</h5> <img src="../images/计算机网络.assets/image-20211113145706059.png" alt="image-20211113145706059" style="zoom:50%;" /><h4 id="常用的三种类别的IP地址"><a href="#常用的三种类别的IP地址" class="headerlink" title="常用的三种类别的IP地址"></a>常用的三种类别的IP地址</h4><table><thead><tr><th>网络类别</th><th>最大可指派的网络数</th><th>第一个可指派的网络号</th><th>最后一个可指派的网络号</th><th>每个网络中最大主机数</th></tr></thead><tbody><tr><td>A</td><td>$126 (2^7 – 2) $</td><td>1</td><td>126</td><td>$16777214 (2^{24}-2)$</td></tr><tr><td>B</td><td>$16383 (2^{14} – 1)$</td><td>128.1</td><td>191.255</td><td>$65534 (2^{16}-2)$</td></tr><tr><td>C</td><td>$2097151 (2^{21} – 1)$</td><td>192.0.1</td><td>223.255.255</td><td>$254 (2^8-2)$</td></tr></tbody></table><h5 id="2个特殊的host-id"><a href="#2个特殊的host-id" class="headerlink" title="2个特殊的host-id"></a>2个特殊的host-id</h5><p>​<strong>全“0”</strong>的Host-id表示该IP地址是“本主机”所连接的单个网络地址。<br>​如IP地址为 5.6.7.8，则网络地址为 5.0.0.0；<br>​<strong>全“1”</strong>的Host-id表示“所有(all)”，即该网络上的所有主机。  </p><h5 id="特殊的net-id"><a href="#特殊的net-id" class="headerlink" title="特殊的net-id"></a>特殊的net-id</h5><p>A类地址<br>    (1) IP地址的全“0”表示“这个（This）” 。 0.0.0.0<br>    (2) Net-id为全“0”，是保留地址，表示“本网络”。<br>    (3) Net-id为127，为本地软件的环路测试，本主机使用。<br>B类地址<br>    Net-id全为“0”不使用 10000000 00000000 &#x3D; 128.0<br>C类地址 11000000 00000000 00000000<br>    Net-id全为“0”不使用 &#x3D; 192.0.0  </p><h5 id="一般不使用的特殊的-IP-地址"><a href="#一般不使用的特殊的-IP-地址" class="headerlink" title="一般不使用的特殊的 IP 地址"></a>一般不使用的特殊的 IP 地址</h5><table><thead><tr><th>网络号</th><th>主机号</th><th>源地址使用</th><th>目的地址使用</th><th>代表的意思</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>可以</td><td>不可</td><td>在本网络上的本主机（见 6.6 节 DHCP 协议）</td></tr><tr><td>0</td><td>host-id</td><td>可以</td><td>不可</td><td>在本网络上的某台主机 host-id</td></tr><tr><td>全 1</td><td>全 1</td><td>不可</td><td>可以</td><td>只在本网络上进行广播（各路由器均不转发）</td></tr><tr><td>net-id</td><td>全 1</td><td>不可</td><td>可以</td><td>对 net-id 上的所有主机进行广播</td></tr><tr><td>127</td><td>非全 0 或全 1 的任何数</td><td>可以</td><td>可以</td><td>用作本地软件环回测试之用</td></tr></tbody></table><h5 id="IP地址的重要特点"><a href="#IP地址的重要特点" class="headerlink" title="IP地址的重要特点"></a>IP地址的重要特点</h5><p>(1) IP 地址是一种分等级的地址结构。   </p><p>(2) 实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口。  </p><p>​当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong>  </p><p>(3) 用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id。  </p><p>(4) 所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。  </p><h3 id="4-2-3-IP地址与硬件地址"><a href="#4-2-3-IP地址与硬件地址" class="headerlink" title="4.2.3 IP地址与硬件地址"></a>4.2.3 IP地址与硬件地址</h3><p>IP 地址与硬件地址是不同的地址。  </p><p>从层次的角度看，<br>    <strong>硬件地址（或物理地址）</strong> 是数据链路层和物理层使用的地址。<br>    <strong>IP 地址</strong>是网络层和以上各层使用的地址，是一种逻辑地址（称 IP 地址是逻辑地址是<strong>因为 IP 地址是用软件实现的）</strong>。  </p><p>IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC帧的首部。  </p><p>IP 层抽象的互联网屏蔽了下层很复杂的细节</p> <img src="../images/计算机网络.assets/image-20211113155427815.png" alt="image-20211113155427815" style="zoom:50%;" /> <img src="../images/计算机网络.assets/image-20211113155646602.png" alt="image-20211113155646602" style="zoom:50%;" /><h3 id="4-2-4-地址解析协议ARP-Address-Resolution-Protocol"><a href="#4-2-4-地址解析协议ARP-Address-Resolution-Protocol" class="headerlink" title="4.2.4 地址解析协议ARP(Address Resolution Protocol)"></a>4.2.4 地址解析协议ARP(Address Resolution Protocol)</h3><p>通信时使用了两个地址：<br>    IP 地址（网络层地址）<br>    MAC 地址（数据链路层地址）  </p><p>APR的作用：从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。  </p><p><strong>只作用在同一个局域网中</strong></p><p>每一个主机都设有一个 <strong>ARP 高速缓存</strong> (ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的<strong>映射表</strong>，动态更新（新增或超时删除）。  </p> <img src="../images/计算机网络.assets/image-20211113162338905.png" alt="image-20211113162338905" style="zoom:50%;" /><p>主机A向本局域网上的主机B发送IP数据报，先在ARP告诉缓存种查看有无主机B的IP地址</p><p>​如有，则查出对应IP地址<br>​如没有，ARP在本局域网广播发送ARP请求分组，主机B发送ARP相应分组，写入自己的硬件地址，A收到后，更新ARP高速缓存</p><h4 id="ARP要点"><a href="#ARP要点" class="headerlink" title="ARP要点"></a>ARP要点</h4><p><strong>ARP请求分组</strong>的内容是发送方硬件地址 &#x2F; 发送方 IP 地址 &#x2F; 目标方硬件地址(未知时填 0) &#x2F; 目标方 IP 地址。</p><p>本地广播 ARP 请求（<strong>路由器不转发ARP请求</strong>），本局域网上所有主机都收到此ARP请求分组。</p><p><strong>ARP 响应分组</strong>的内容是发送方硬件地址 &#x2F; 发送方 IP地址 &#x2F; 目标方硬件地址 &#x2F; 目标方 IP 地址。</p><p><strong>ARP 分组封装在帧中传输</strong>。</p><p>ARP请求分组是 <strong>广播</strong>， ARP响应分组是<strong>单播</strong>  </p><h4 id="ARP高速缓存的作用"><a href="#ARP高速缓存的作用" class="headerlink" title="ARP高速缓存的作用"></a>ARP高速缓存的作用</h4><p><strong>存放最近获得的 IP 地址到 MAC 地址的绑定，以减少ARP 广播的数量。</strong></p><p>对每一个映射地址项目都设置<strong>生存时间</strong>。  </p><h4 id="应当注意的问题"><a href="#应当注意的问题" class="headerlink" title="应当注意的问题"></a>应当注意的问题</h4><p>ARP 是解决<strong>同一个局域网</strong>上的主机或路由器的 IP 地址和硬件地址的映射问题。</p><p>从 IP 地址到硬件地址的<strong>解析是自动进行</strong>的，主机的用户对这种地址解析过程是不知道的。</p><p>只要主机或路由器要和<strong>本网络上</strong>的另一个已知 IP 地址的主机或路由器进行通信， ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。</p><p>如果所要找的主机和源主机不在同一个局域网上，那么<strong>就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址</strong>， 然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。 剩下的工作就由下一个网络来做  </p><p>不直接使用硬件地址进行通信的原因：由于全世界存在着各式各样的网络， 它们<strong>使用不同的硬件地址</strong>  </p><h3 id="4-2-5-IP-数据报的格式"><a href="#4-2-5-IP-数据报的格式" class="headerlink" title="4.2.5 IP 数据报的格式"></a>4.2.5 IP 数据报的格式</h3><p>IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成  </p> <img src="../images/计算机网络.assets/image-20211113163554611.png" alt="image-20211113163554611" style="zoom:50%;" /><p>固定部分固定长度，共20字节，所有IP数据报必须具有的</p><p>可选字段长度可变</p><h4 id="IP-数据报首部的固定部分中的各字段"><a href="#IP-数据报首部的固定部分中的各字段" class="headerlink" title="IP 数据报首部的固定部分中的各字段"></a>IP 数据报首部的固定部分中的各字段</h4><p>版本——占 4 位，指 IP 协议的版本。目前的 IP 协议版本号为 4 (即 IPv4)。  </p><p>首部长度——占 4 位，可表示的最大数值是 15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节。  </p><p>区分服务——占 8 位，用来获得更好的服务。在旧标准中叫做服务类型，但实际上一直未被使用过。1998 年这个字段改名为区分服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都不使用这个字段  </p><p>总长度——占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。<strong>总长度必须不超过最大传送单元 MTU。</strong>  </p><p>标识(identification) ——占 16 位，它是一个计数器，用来产生 <strong>IP 数据报的标识</strong>  </p><p>标志(flag) ——占 3 位，目前只有前两位有意义。<strong>标志字段的最低位是 MF (More Fragment)<strong>。MF &#x3D; 1 表示后面“还有分片”。 MF &#x3D; 0 表示最后一个分片。</strong>标志字段中间的一位是 DF (Don’t Fragment)</strong> 。只有当 DF &#x3D; 0 时才允许分片  </p><p>片偏移——占13 位，指出：较长的分组在分片后某片在原分组中的相对位置。<strong>片偏移以 8 个字节为偏移单位。</strong>  </p><h6 id="例4-1"><a href="#例4-1" class="headerlink" title="例4.1"></a>例4.1</h6> <img src="../images/计算机网络.assets/image-20211113165003512.png" alt="image-20211113165003512" style="zoom:50%;" /> <img src="../images/计算机网络.assets/image-20211113165017324.png" alt="image-20211113165017324" style="zoom:50%;" /> <img src="../images/计算机网络.assets/image-20211113165042142.png" alt="image-20211113165042142" style="zoom:50%;" /><p>生存时间——占8 位，记为 TTL (Time To Live)，指示数据报在网络中可通过的路由器数的最大值。  </p><p>协议——占8 位，指出此数据报携带的数据使用何种协议，以便目的主机的 IP 层将数据部分上交给那个处理过程  </p><p>首部检验和——占16 位， <strong>只检验数据报的首部</strong>， 不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。  </p> <img src="../images/计算机网络.assets/image-20211113165300341.png" alt="image-20211113165300341" style="zoom:50%;" /><h4 id="IP-数据报首部的可变部分"><a href="#IP-数据报首部的可变部分" class="headerlink" title="IP 数据报首部的可变部分"></a>IP 数据报首部的可变部分</h4><p>IP首部的可变部分就是一个选项字段， 用来支持排错、 测量以及安全等措施， 内容很丰富。</p><p>选项字段的长度可变， 从 1 个字节到 40 个字节不等， 取决于所选择的项目。</p><p>增加首部的可变部分是为了增加 IP 数据报的功能， 但这同时也使得 IP 数据报的首部长度成为可变的。 这就增加了每一个路由器处理数据报的开销。</p><p>实际上这些选项很少被使用。  </p><h3 id="4-2-6-分组转发的流程"><a href="#4-2-6-分组转发的流程" class="headerlink" title="4.2.6 分组转发的流程"></a>4.2.6 分组转发的流程</h3><p><strong>按主机所在的网络地址来制作路由表</strong>  </p><p><strong>路由表指出，到某个网络应当先到某个路由器（即下一跳路由器） 。</strong>  </p><p>分组转发大都是<strong>基于目的主机所在的网络</strong>， 但也有特例。  </p><p>特定主机路由，<strong>这种路由是为特定的目的主机指明一个路由</strong>。  </p><p>路由器还可采用<strong>默认路由</strong>以<strong>减少路由表所占用的空间和搜索路由表所用的时间</strong>  </p><p><strong>路由器分组转发算法</strong><br>(1) 从数据报的首部提取<strong>目的主机的 IP 地址 D</strong>, 得出<strong>目的网络地址为 N</strong>。<br>(2) 若网络 N 与此路由器直接相连， 则把数据报<strong>直接交付</strong>目的主机 D；否则是<strong>间接交付</strong>， 执行 (3)。<br>(3) 若路由表中有目的地址为 D 的<strong>特定主机路由</strong>， 则把数据报传送给路由表中所指明的下一跳路由器；否则， 执行 (4)。<br>(4) 若路由表中有<strong>到达网络 N 的路由</strong>， 则把数据报传送给路由表指明的下一跳路由器；否则， 执行 (5)。<br>(5) 若路由表中有一个<strong>默认路由</strong>， 则把数据报传送给路由表中所指明的默认路由器；否则， 执行 (6)。<br>(6) 报告转发分组出错。  </p><h2 id="4-3-划分子网和构造超网"><a href="#4-3-划分子网和构造超网" class="headerlink" title="4.3 划分子网和构造超网"></a>4.3 划分子网和构造超网</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学</title>
      <link href="/posts/2f9873dc/"/>
      <url>/posts/2f9873dc/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学"><a href="#计算机图形学" class="headerlink" title="计算机图形学"></a>计算机图形学</h1><p> 泰勒级数</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6.assets/image-20221018141034032.png" alt="image-20221018141034032"></p><h2 id="Lec2-Review-of-Linear-Algebra（线性代数）"><a href="#Lec2-Review-of-Linear-Algebra（线性代数）" class="headerlink" title="Lec2 Review of Linear Algebra（线性代数）"></a>Lec2 Review of Linear Algebra（线性代数）</h2><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3> <img src="../images/计算机图形学.assets/image-20210827151009636.png" alt="image-20210827151009636" style="zoom:80%;" /><p>向量：方向和长度 </p><p>单位向量：<img src="../images/计算机图形学.assets/image-20210827151104696.png" alt="image-20210827151104696" style="zoom:67%;" /></p><h4 id="向量乘法（点乘）："><a href="#向量乘法（点乘）：" class="headerlink" title="向量乘法（点乘）："></a>向量乘法（点乘）：<img src="../images/计算机图形学.assets/image-20210827151128930.png" alt="image-20210827151128930" style="zoom:67%;" /></h4><p>公式：<img src="../images/计算机图形学.assets/image-20210827151142908.png" alt="image-20210827151142908" style="zoom:67%;" /></p><p>在笛卡尔坐标系中，向量的点乘会变得更简单</p><img src="../images/计算机图形学.assets/image-20210827151156273.png" alt="image-20210827151156273" style="zoom:67%;" /><p>投影：<img src="../images/计算机图形学.assets/image-20210827151211291.png" alt="image-20210827151211291" style="zoom:67%;" /></p><h4 id="向量乘法（叉乘）："><a href="#向量乘法（叉乘）：" class="headerlink" title="向量乘法（叉乘）："></a>向量乘法（叉乘）：</h4><p> <img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6.assets/image-20210827151234454.png" alt="image-20210827151234454"></p><p>此课程规定：使用右手螺旋法则</p><p>在笛卡尔坐标系中：<img src="../images/计算机图形学.assets/image-20210827151251999.png" alt="image-20210827151251999" style="zoom:67%;" /></p><p>叉乘在图形学中的应用：判断左和右，判断内和外（例如是否在三角形内部）</p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><p>条件：矩阵1的列数 &#x3D;&#x3D; 矩阵2的行数</p><p>矩阵性质：<img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6.assets/image-20210827151315511.png" alt="image-20210827151315511"></p><p>注意：矩阵无任何交换律</p><p>矩阵转置：<img src="../images/计算机图形学.assets/image-20210827151326488.png" alt="image-20210827151326488" style="zoom:67%;" /></p><p>单位矩阵： </p><img src="../images/计算机图形学.assets/image-20210827151337879.png" alt="image-20210827151337879" style="zoom:67%;" /><p>由单位矩阵引出矩阵的逆</p><p>向量的点乘和叉乘可以写成矩阵的形式：<img src="../images/计算机图形学.assets/image-20210827151352148.png" alt="image-20210827151352148" style="zoom:67%;" /></p><h2 id="Lec3-Transformation"><a href="#Lec3-Transformation" class="headerlink" title="Lec3 Transformation"></a>Lec3 Transformation</h2><p>Scale，缩放变换<img src="../images/计算机图形学.assets/image-20210827151407946.png" alt="image-20210827151407946" style="zoom:67%;" /></p><p>可写成矩阵形式：<img src="../images/计算机图形学.assets/image-20210827151416334.png" alt="image-20210827151416334" style="zoom:67%;" /></p><p>xy轴如果缩放比例不同：<img src="../images/计算机图形学.assets/image-20210827151434253.png" alt="image-20210827151434253" style="zoom:67%;" /></p><p>Shear Matrix 切变：<img src="../images/计算机图形学.assets/image-20210827151455704.png" alt="image-20210827151455704" style="zoom:67%;" /></p><p>Rotation Matrix 旋转：<img src="../images/计算机图形学.assets/image-20210827151509050.png" alt="image-20210827151509050" style="zoom:67%;" /></p><p>​注意：<img src="../images/计算机图形学.assets/image-20210828152549216.png" alt="image-20210828152549216" style="zoom:67%;" /></p><p>​即旋转的转置矩阵 &#x3D; 它的逆矩阵</p><p>​<em><strong>数学上，转置和逆相同的矩阵为正交矩阵</strong></em></p><h6 id="线性变化"><a href="#线性变化" class="headerlink" title="线性变化"></a>线性变化</h6><img src="../images/计算机图形学.assets/image-20210827151524227.png" alt="image-20210827151524227" style="zoom:67%;" /> <h6 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h6><img src="../images/计算机图形学.assets/image-20210827151536015.png" alt="image-20210827151536015" style="zoom:67%;" /><p>线性变换无法满足需求，需要加入额外的变量</p><img src="../images/计算机图形学.assets/image-20210827150644124.png" alt="image-20210827150644124" style="zoom:67%;" /><p>点与向量之间的转换：<img src="../images/计算机图形学.assets/image-20210827150904266.png" alt="image-20210827150904266" style="zoom:67%;" /></p><p>使用齐次坐标进行转换<img src="../images/计算机图形学.assets/image-20210827163922681.png" alt="image-20210827163922681" style="zoom:67%;" /></p><h5 id="Inverse-Transition-逆变换"><a href="#Inverse-Transition-逆变换" class="headerlink" title="Inverse Transition 逆变换"></a>Inverse Transition 逆变换</h5><img src="../images/计算机图形学.assets/image-20210827164243033.png" alt="image-20210827164243033" style="zoom:67%;" /><p>​即一种变换的反向操作</p><h6 id="注意：复杂的操作可以通过简单操作的组合实现，简单操作的顺序会影响最终的结果"><a href="#注意：复杂的操作可以通过简单操作的组合实现，简单操作的顺序会影响最终的结果" class="headerlink" title="注意：复杂的操作可以通过简单操作的组合实现，简单操作的顺序会影响最终的结果"></a>注意：复杂的操作可以通过简单操作的组合实现，简单操作的顺序会影响最终的结果</h6><img src="../images/计算机图形学.assets/image-20210827164502483.png" alt="image-20210827164502483" style="zoom:67%;" /><img src="../images/计算机图形学.assets/image-20210827164559441.png" alt="image-20210827164559441" style="zoom:67%;" /><h6 id="可以通过结合律将多种简单变换组合成一种复杂变换"><a href="#可以通过结合律将多种简单变换组合成一种复杂变换" class="headerlink" title="可以通过结合律将多种简单变换组合成一种复杂变换"></a>可以通过结合律将多种简单变换组合成一种复杂变换</h6><h2 id="Lec4-Transformation-Cont"><a href="#Lec4-Transformation-Cont" class="headerlink" title="Lec4 Transformation Cont"></a>Lec4 Transformation Cont</h2><h3 id="3D-transformations"><a href="#3D-transformations" class="headerlink" title="3D transformations"></a>3D transformations</h3><p>使用齐次坐标表示：<img src="../images/计算机图形学.assets/image-20210828152830239.png" alt="image-20210828152830239" style="zoom:67%;" /></p><p>三维变换：<img src="../images/计算机图形学.assets/image-20210828152859686.png" alt="image-20210828152859686" style="zoom:67%;" /></p><p>​注：t为平移变换，a~i为线性变换</p><img src="../images/计算机图形学.assets/image-20210828152943578.png" alt="image-20210828152943578" style="zoom:67%;" /><p>旋转：</p><img src="../images/计算机图形学.assets/image-20210828153028694.png" alt="image-20210828153028694" style="zoom:67%;" /><p>任意复杂旋转可转变为简单旋转的组合：<img src="../images/计算机图形学.assets/image-20210828153259800.png" alt="image-20210828153259800" style="zoom:67%;" /></p><p>Rodrigues’ Rotation Formula:<img src="../images/计算机图形学.assets/image-20210828153442894.png" alt="image-20210828153442894" style="zoom:67%;" /></p><h3 id="View-x2F-Camera-Transformation"><a href="#View-x2F-Camera-Transformation" class="headerlink" title="View&#x2F;Camera Transformation"></a>View&#x2F;Camera Transformation</h3><h5 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h5><img src="../images/计算机图形学.assets/image-20210828161602848.png" alt="image-20210828161602848" style="zoom:67%;" /><h5 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h5><img src="../images/计算机图形学.assets/image-20210905152934702.png" alt="image-20210905152934702" style="zoom:67%;" /><img src="../images/计算机图形学.assets/image-20210905153933357.png" alt="image-20210905153933357" style="zoom:67%;" /><img src="../images/计算机图形学.assets/image-20210905153724201.png" alt="image-20210905153724201" style="zoom:67%;" /><img src="../images/计算机图形学.assets/image-20210905153637582.png" alt="image-20210905153637582" style="zoom:67%;" /><p>其中A是矩阵中三行三列的值，B是三行四列的值，三行一、二列均为0</p><h2 id="Lec5-Rasterization1-Triangles"><a href="#Lec5-Rasterization1-Triangles" class="headerlink" title="Lec5 Rasterization1(Triangles)"></a>Lec5 Rasterization1(Triangles)</h2><p> 在物体的位置固定在-1到1的位置之后需要改变的东西：宽高比、可视范围（垂直可视角度）</p><p> 光栅化：把东西画在屏幕上的过程</p>  <img src="../images/计算机图形学.assets/image-20210913160159543.png" alt="image-20210913160159543" style="zoom:67%;" /><p>三角形光栅化过程： 遍历全部像素，遍历过程中，利用叉乘对每个像素进行计算，判断其是否在三角形内部</p><h2 id="Lec6-Rasterization2（Antialiasing-and-Z-Buffering）"><a href="#Lec6-Rasterization2（Antialiasing-and-Z-Buffering）" class="headerlink" title="Lec6 Rasterization2（Antialiasing and Z-Buffering）"></a>Lec6 Rasterization2（Antialiasing and Z-Buffering）</h2><p>采样和光栅化过程中可能会走样或者锯齿。</p><h6 id="走样：不同的函数，在相同采样频率之下，得到的结果相同"><a href="#走样：不同的函数，在相同采样频率之下，得到的结果相同" class="headerlink" title="走样：不同的函数，在相同采样频率之下，得到的结果相同"></a>走样：不同的函数，在相同采样频率之下，得到的结果相同</h6><h6 id="滤波：去掉一系列的频率"><a href="#滤波：去掉一系列的频率" class="headerlink" title="滤波：去掉一系列的频率"></a>滤波：去掉一系列的频率</h6><p>解决方案：在采样之前，首先对图形进行模糊化处理，对处理过后的图形进行采样和光栅化</p><p>走样：在频域上，指会重合</p><p>抗锯齿方案：MSAA、FXAA、TAA</p><p>MSAA（Multi Sampling Anti-Aliasing）：增加样本数，对其做平均，得出区域均值</p><p>FXAA（Fast Approximate AA）：图像后期处理，先得到有锯齿的图，再把有锯齿的地方找到，将其换成没有锯齿的边</p><p>TAA（Temporal AA）：在时间上进行反走样，将上一帧检测到的结果复用，相当于将MSAA的结果运用在时间上</p><p>超分辨率抗锯齿：即将一个分辨率较低的图改编成分辨率较高的图，类似于MSAA的抗锯齿方法</p><p>​常用方法：DLSS（Deep Learning Super Sampling）深度学习nb，即将缺失的分辨率猜出来</p><h2 id="Lec7-Shadings1（Illumination，Shading-and-Graphics-Pipeline）"><a href="#Lec7-Shadings1（Illumination，Shading-and-Graphics-Pipeline）" class="headerlink" title="Lec7 Shadings1（Illumination，Shading and Graphics Pipeline）"></a>Lec7 Shadings1（Illumination，Shading and Graphics Pipeline）</h2><p>Painter’s Algorithm：从背景往前景画，先画最远的，层层叠加</p><h6 id="但是！如果存在互相遮挡的状况，计算机就无法计算，例如："><a href="#但是！如果存在互相遮挡的状况，计算机就无法计算，例如：" class="headerlink" title="但是！如果存在互相遮挡的状况，计算机就无法计算，例如："></a>但是！如果存在互相遮挡的状况，计算机就无法计算，例如：</h6> <img src="../images/计算机图形学.assets/image-20210927152254604.png" alt="image-20210927152254604" style="zoom:25%;" /><h4 id="Z-Buffer-深度缓存"><a href="#Z-Buffer-深度缓存" class="headerlink" title="Z-Buffer(深度缓存)"></a>Z-Buffer(深度缓存)</h4><p>Idea：</p><p>​Store current min. z-value for each sample(pixel)</p><p>​Needs an additional buffer for depth values</p><ol><li><p>frame buffer stores color values缓存原图</p></li><li><p>depth buffer (z-buffer)  stores depth        缓存每个像素的深度</p><p>注意！该处的深度不是颜色深浅，而是指距离相机的远近程度</p><p>距离越远深度越大（即颜色越浅）</p></li></ol> <img src="../images/计算机图形学.assets/image-20210927153118430.png" alt="image-20210927153118430" style="zoom:25%;" /><p>算法思路：</p><p>​对任意一个三角形（即屏幕上由三个像素点构成的三角形区域），我们都可以把它光栅化。开始时，我们把每一个像素的深度都定为无穷大，然后对每一个三角形，计算它的深度值，如果小于对应像素点的深度，则覆盖，并更新深度图，否则，什么也不做</p><p> <img src="../images/计算机图形学.assets/image-20210927153538652.png" alt="image-20210927153538652" style="zoom: 25%;" /><img src="计算机图形学.assets/image-20210927154114541.png" alt="image-20210927154114541" style="zoom:25%;" /></p><p> 画家算法和深度缓存算法对比：</p><p>​画家算法：对n个三角形进行排序，然后对这些三角形进行光栅化，算法复杂度：O(nlogn)</p><p>​深度缓存算法：并没有对算法进行排序，每次计算只是比较每个像素点的最小值，算法复杂度：O(n)</p><p>​</p><h3 id="Shading"><a href="#Shading" class="headerlink" title="Shading"></a>Shading</h3><p>Blinn-Phong Reflectance Model 较为简单的模型，不考虑物理真实性</p><p>注意着色不代表阴影，着色只会影响物体表面明暗程度</p><h5 id="Diffuse-Reflection-漫反射"><a href="#Diffuse-Reflection-漫反射" class="headerlink" title="Diffuse Reflection 漫反射"></a>Diffuse Reflection 漫反射</h5><p>和反射点法线和光源的角度有关系，和人的视线方向没有关系</p> <img src="../images/计算机图形学.assets/image-20210927161020618.png" alt="image-20210927161020618" style="zoom:25%;" /> <img src="../images/计算机图形学.assets/image-20210927161340094.png" alt="image-20210927161340094" style="zoom:25%;" /><p>其中，I为光强，r为光源到反射点的距离，kd为漫反射系数</p><h2 id="Lec8-Shading-2-Shading-Pipeline-and-Texture-Mapping"><a href="#Lec8-Shading-2-Shading-Pipeline-and-Texture-Mapping" class="headerlink" title="Lec8 Shading 2 (Shading, Pipeline and Texture Mapping)"></a>Lec8 Shading 2 (Shading, Pipeline and Texture Mapping)</h2><h4 id="Specular-Term-Blinn-Phong-高光"><a href="#Specular-Term-Blinn-Phong-高光" class="headerlink" title="Specular Term (Blinn-Phong)  (高光)"></a>Specular Term (Blinn-Phong)  (高光)</h4> <img src="../images/计算机图形学.assets/image-20211009081702341.png" alt="image-20211009081702341" style="zoom:25%;" /><p>对于高光，其半程向量（入射光、反射光夹角的一半）和法线方向接近</p><p>由于Blinn-Phong是经验模型，计算高光的过程中，不考虑吸收（n和l的点乘，同漫反射）</p><p>注意：<img src="../images/计算机图形学.assets/image-20211009082448239.png" alt="image-20211009082448239" style="zoom: 50%;" />该式中，p次的原因是，n点乘h的范围很大，曲线很平滑，当夹角为45度时仍然有很大的范围（见下图），即高光的范围很大。因此，为了使高光范围变小，通常加上指数，一般在100-200之间，高光区域为3-5度。指数p是为了控制高光的大小</p> <img src="../images/计算机图形学.assets/image-20211009082646067.png" alt="image-20211009082646067" style="zoom:50%;" /><h4 id="Ambient-Term-环境光"><a href="#Ambient-Term-环境光" class="headerlink" title="Ambient Term (环境光)"></a>Ambient Term (环境光)</h4><p>假设，任何一个点接收到来自环境光的光照是完全相同的</p> <img src="../images/计算机图形学.assets/image-20211009083135752.png" alt="image-20211009083135752" style="zoom: 25%;" /><h4 id="Blinn-Phong-Reflection-Model"><a href="#Blinn-Phong-Reflection-Model" class="headerlink" title="Blinn-Phong Reflection Model"></a>Blinn-Phong Reflection Model</h4> <img src="../images/计算机图形学.assets/image-20211009083324335.png" alt="image-20211009083324335" style="zoom:33%;" /><h4 id="Shading-Frequencies-着色频率"><a href="#Shading-Frequencies-着色频率" class="headerlink" title="Shading Frequencies 着色频率"></a>Shading Frequencies 着色频率</h4> <img src="../images/计算机图形学.assets/image-20211009083917661.png" alt="image-20211009083917661" style="zoom:25%;" /> <img src="../images/计算机图形学.assets/image-20211009083940118.png" alt="image-20211009083940118" style="zoom:25%;" /> <img src="../images/计算机图形学.assets/image-20211009084115021.png" alt="image-20211009084115021" style="zoom:25%;" /><p>求顶点法线方法：</p><p>顶点周围三角形的法线的加权平均值（面积）</p> <img src="../images/计算机图形学.assets/image-20211009084805076.png" alt="image-20211009084805076" style="zoom:25%;" /><h3 id="Graphics-Real-time-Rendering-Pipeline"><a href="#Graphics-Real-time-Rendering-Pipeline" class="headerlink" title="Graphics (Real-time Rendering) Pipeline"></a>Graphics (Real-time Rendering) Pipeline</h3> <img src="../images/计算机图形学.assets/image-20211009090154060.png" alt="image-20211009090154060" style="zoom:33%;" /><p>着色器练习网站：<a href="http://shadertoy.com/view/ld3Gz2">http://shadertoy.com/view/ld3Gz2</a></p><h3 id="Texture-Mapping-纹理映射"><a href="#Texture-Mapping-纹理映射" class="headerlink" title="Texture Mapping 纹理映射"></a>Texture Mapping 纹理映射</h3><p>由于在一个具体的图形中，每一个像素可能有不同的着色方式，因此，我们需要用纹理映射的方式来决定每个像素的着色方式</p><p>对概念的理解：对一个无色的模型贴贴纸使其上色的过程</p> <img src="../images/计算机图形学.assets/image-20211009092907239.png" alt="image-20211009092907239" style="zoom:33%;" /><h2 id="Lec9-Shading-3-Texture-Mapping-cont"><a href="#Lec9-Shading-3-Texture-Mapping-cont" class="headerlink" title="Lec9 Shading 3 (Texture Mapping cont.)"></a>Lec9 Shading 3 (Texture Mapping cont.)</h2><h3 id="Interpolation-Across-Triangles-Barycentric-Coordinates-重心坐标"><a href="#Interpolation-Across-Triangles-Barycentric-Coordinates-重心坐标" class="headerlink" title="Interpolation Across Triangles: Barycentric Coordinates (重心坐标)"></a>Interpolation Across Triangles: Barycentric Coordinates (重心坐标)</h3><p>插值：比如一个三角形三个角分别是红、绿、蓝色三种颜色，我们需要通过计算使三角形中间的部分进行平滑的颜色过渡</p> <img src="../images/计算机图形学.assets/image-20211009124853081.png" alt="image-20211009124853081" style="zoom:25%;" /><p>有一个三角形，它的三个顶点为A、B、C，在三角形平面上的任意一个点可以表示成<img src="计算机图形学.assets/image-20211009125446817.png" alt="image-20211009125446817" style="zoom:50%;" />的形式，其中<img src="../images/计算机图形学.assets/image-20211009125511830.png" alt="image-20211009125511830" style="zoom:50%;" />，如果该点在三角形内部，α、β、γ均大于0</p><p>求重心坐标的方法：</p> <img src="../images/计算机图形学.assets/image-20211011150638462.png" alt="image-20211011150638462" style="zoom:33%;" /><p>公式的一般形式：</p> <img src="../images/计算机图形学.assets/image-20211011151122213.png" alt="image-20211011151122213" style="zoom:33%;" /><p>重心坐标的缺点：进行投影变换之后，重心坐标可能会改变。比如将一个三角形从三维空间投影到二维空间之后，重心坐标很有可能会发生改变。</p><p>在纹理上的应用：比如一个三角形，对于三角形内部一个点的属性，先计算该点的重心坐标，然后在纹理对象中查找相应的坐标</p><h3 id="Texture-Magnification"><a href="#Texture-Magnification" class="headerlink" title="Texture Magnification"></a>Texture Magnification</h3><h4 id="纹理分辨率过低问题"><a href="#纹理分辨率过低问题" class="headerlink" title="纹理分辨率过低问题"></a>纹理分辨率过低问题</h4> <img src="../images/计算机图形学.assets/image-20211011152632241.png" alt="image-20211011152632241" style="zoom:33%;" /><h5 id="Bilinear-Interpolation-双线性插值"><a href="#Bilinear-Interpolation-双线性插值" class="headerlink" title="Bilinear Interpolation 双线性插值"></a>Bilinear Interpolation 双线性插值</h5> <img src="../images/计算机图形学.assets/image-20211011152935067.png" alt="image-20211011152935067" style="zoom:33%;" /><p>对一个点进行水平方向上两次线性插值，垂直方向上一次线性插值</p> <img src="../images/计算机图形学.assets/image-20211011153530594.png" alt="image-20211011153530594" style="zoom:33%;" /><h5 id="Bicubic-Interpolation"><a href="#Bicubic-Interpolation" class="headerlink" title="Bicubic Interpolation"></a>Bicubic Interpolation</h5><p>和Bilinear类似，对周围16个点进行插值处理（不是线性插值）</p><h4 id="纹理分辨率更大问题"><a href="#纹理分辨率更大问题" class="headerlink" title="纹理分辨率更大问题"></a>纹理分辨率更大问题</h4><p>在距离远近不同的地方，一个像素覆盖的纹理上的区域大小是不一样的</p><h5 id="Mipmap"><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h5><p> 简而言之，就是，对一张纹理原图设为第0层，分辨率小1&#x2F;4的图成为第二层，第三层、第四层以此类推</p><p>比如，128 * 128的纹理分辨率，第0层为128 * 128，第1层为64 * 64，第2层为32 * 32，以此类推，最后一层为1 * 1。该方法所需要的额外空间只占原图的1&#x2F;3</p><p>为了使纹理的过渡更加平滑，我们需要用到小数层，比如第1.8层，如果要求第1.8层的点，可以这么做：对第1层和第2层进行插值处理，再对两层得出的结果做插值处理</p><h6 id="Mipmap-Limitation"><a href="#Mipmap-Limitation" class="headerlink" title="Mipmap Limitation"></a>Mipmap Limitation</h6><p>在一个像素点覆盖的范围比较大的时候，很容易产生不规则的纹理覆盖面积（在纹理坐标之中），使用Mipmap很难处理这样的问题。</p><p>对应的，可以用多向异性过滤。</p><p>多向异性过滤：</p> <img src="../images/计算机图形学.assets/image-20211011162037295.png" alt="image-20211011162037295" style="zoom:33%;" /><h3 id="纹理应用"><a href="#纹理应用" class="headerlink" title="纹理应用"></a>纹理应用</h3><p>环境光：凹凸贴图产生真实阴影效果</p> <img src="../images/计算机图形学.assets/image-20211013140318721.png" alt="image-20211013140318721" style="zoom: 67%;" /><p>位移贴图：效果更好，但要求模型更精细</p><h2 id="Lec10-Geometry1-Introduction"><a href="#Lec10-Geometry1-Introduction" class="headerlink" title="Lec10 Geometry1 (Introduction)"></a>Lec10 Geometry1 (Introduction)</h2><p>“Implicit” Representations of Geometry: 几何的隐式表述：通过一些公式等形容一个几何形体，但是没有具体点的体现，比如一条直线: y &#x3D; x + b</p><p>“Explicit” Representations of Geometry: 显式</p><p>方法1：直接给出具体的点</p><p>方法2：通过参数映射的方式，比如一个二维图片，通过一些方法、函数映射到三维空间之中</p><p>隐式表示方法：</p><p>​数学公式：便于计算，但不直观</p><p>​Constructive Solid Geometry：通过一些简单基础的几何形成一些复杂的几何</p><img src="../images/计算机图形学.assets/image-20211013142158359.png" alt="image-20211013142158359" style="zoom:50%;" /><p>​Distance Functions：比较适合两个几何体间做圆滑过渡</p><img src="../images/计算机图形学.assets/image-20211013142502281.png" alt="image-20211013142502281" style="zoom:50%;" /><p>​水平集：举例就是等高线</p><p>​Fractals：递归，即不断放大不断循环</p><img src="../images/计算机图形学.assets/image-20211013142844698.png" alt="image-20211013142844698" style="zoom:50%;" /><h2 id="Lec11-Geometry2-Curves-and-Surfaces"><a href="#Lec11-Geometry2-Curves-and-Surfaces" class="headerlink" title="Lec11  Geometry2 (Curves and Surfaces)"></a>Lec11  Geometry2 (Curves and Surfaces)</h2><h3 id="Explicit-Representation-in-Computer-Graphics"><a href="#Explicit-Representation-in-Computer-Graphics" class="headerlink" title="Explicit Representation in Computer Graphics"></a>Explicit Representation in Computer Graphics</h3><h4 id="Point-Cloud"><a href="#Point-Cloud" class="headerlink" title="Point Cloud"></a>Point Cloud</h4><p>即是用全部用点表示</p><h4 id="Polygon-Mesh"><a href="#Polygon-Mesh" class="headerlink" title="Polygon Mesh"></a>Polygon Mesh</h4><p>用多个基本图形进行组合</p> <img src="../images/计算机图形学.assets/image-20211018152413217.png" alt="image-20211018152413217" style="zoom: 25%;" /><h4 id="The-WaveFront-Object-File-Obj-Format"><a href="#The-WaveFront-Object-File-Obj-Format" class="headerlink" title="The WaveFront Object File(.Obj)  Format"></a>The WaveFront Object File(.Obj)  Format</h4><img src="../images/计算机图形学.assets/image-20211018153836860.png" alt="image-20211018153836860" style="zoom:50%;" /><p>通过两个文件存储图形数据</p><p>文件一存放顶点、法线</p><p>文件二存放顶点、法线之间的联系</p><h3 id="Bezier-Curves"><a href="#Bezier-Curves" class="headerlink" title="Bezier Curves"></a>Bezier Curves</h3><p>用一系列的控制点去定义一个曲线</p><h4 id="de-Casteljau-Algorithm"><a href="#de-Casteljau-Algorithm" class="headerlink" title="de Casteljau Algorithm"></a>de Casteljau Algorithm</h4><p>不记得了就去看视频，20分钟左右</p><p>Bezier Curves性质：</p><p>​仿射变换：取顶点做仿射变换，对变换后的顶点做相同Bezier曲线过程，得到的曲线与原曲线对应，此性质不适用于投影变换</p><p>​凸包性质(Convex Hull)：由控制点构成的贝塞尔曲线必定在由控制点形成的凸包中</p><img src="../images/计算机图形学.assets/image-20211018160944936.png" alt="image-20211018160944936" style="zoom:33%;" /><h4 id="Piecewise-Bezier-Curves-逐段的贝塞尔曲线"><a href="#Piecewise-Bezier-Curves-逐段的贝塞尔曲线" class="headerlink" title="Piecewise Bezier Curves 逐段的贝塞尔曲线"></a>Piecewise Bezier Curves 逐段的贝塞尔曲线</h4><p>每四个控制点形成一条贝塞尔曲线</p> <img src="../images/计算机图形学.assets/image-20211018161634461.png" alt="image-20211018161634461" style="zoom:33%;" /><p>C0连续(continuity)：一条曲线的起点等于另一条曲线的终点</p><p>C1连续(continuity)：当且仅当同一点的两条贝塞尔曲线共线、反向、等长的时候，该点处两条曲线的连接是光滑的。</p><p>Cn连续：即二次求导的结果，同上</p><h3 id="Other-types-of-splines-样条，即曲线的总称"><a href="#Other-types-of-splines-样条，即曲线的总称" class="headerlink" title="Other types of  splines(样条，即曲线的总称)"></a>Other types of  splines(样条，即曲线的总称)</h3><h4 id="B-splines"><a href="#B-splines" class="headerlink" title="B-splines"></a>B-splines</h4> <img src="../images/计算机图形学.assets/image-20211018162226634.png" alt="image-20211018162226634" style="zoom:33%;" /><p>Basis splines：基曲线，由基本曲线组成的曲线</p><p>理解为，更高阶的贝塞尔曲线，较为困难，本课程中不多做介绍</p><h3 id="Bezier-Surface"><a href="#Bezier-Surface" class="headerlink" title="Bezier Surface"></a>Bezier Surface</h3><p>实现方式：双线性插值的应用，即水平和竖直方向上做两次贝塞尔曲线的过程</p><p>难点：不同的贝塞尔曲面之间的结合，使拼接部分更为光滑，本节课中不多做介绍</p><h2 id="Lec12-Geometry3-Surfaces"><a href="#Lec12-Geometry3-Surfaces" class="headerlink" title="Lec12 Geometry3(Surfaces)"></a>Lec12 Geometry3(Surfaces)</h2> <img src="../images/计算机图形学.assets/image-20211021080948481.png" alt="image-20211021080948481" style="zoom:67%;" /><p>Mesh Subdivision（细分）：增加更多的面，使画面更精细</p><p>Mesh Simplification：使网格变少，画面简化</p><p>Mesh Regularization：在改变三角形质量的同时，不能改变模型本身的质量</p><h3 id="Mesh-Subdivision"><a href="#Mesh-Subdivision" class="headerlink" title="Mesh Subdivision"></a>Mesh Subdivision</h3><h4 id="Loop-Subdivision"><a href="#Loop-Subdivision" class="headerlink" title="Loop Subdivision"></a>Loop Subdivision</h4><p>分成两个步骤：1、增加三角形的数量；2、改变三角形的位置使画面更精细</p><h6 id="适用于以三角形为基本图形的模型的细分"><a href="#适用于以三角形为基本图形的模型的细分" class="headerlink" title="适用于以三角形为基本图形的模型的细分"></a>适用于以三角形为基本图形的模型的细分</h6> <img src="../images/计算机图形学.assets/image-20211021081811508.png" alt="image-20211021081811508" style="zoom:50%;" /><p>上图：新顶点（白色点的位置） &#x3D; A、B、C、D点的位置的加权平均</p> <img src="../images/计算机图形学.assets/image-20211021082116985.png" alt="image-20211021082116985" style="zoom:67%;" /><p>上图：旧顶点（白色点的位置）</p><p>​n: 该顶点的度，u:其他旧顶点的权值 </p><h4 id="Catmull-Clark-Subdivision"><a href="#Catmull-Clark-Subdivision" class="headerlink" title="Catmull-Clark Subdivision"></a>Catmull-Clark Subdivision</h4><h6 id="适用于非只有三角形网格的模型"><a href="#适用于非只有三角形网格的模型" class="headerlink" title="适用于非只有三角形网格的模型"></a>适用于非只有三角形网格的模型</h6> <img src="../images/计算机图形学.assets/image-20211021082639494.png" alt="image-20211021082639494" style="zoom:50%;" /><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>奇异点：度不是4的点</p><p>非四边形面：不是四边形的面</p> <img src="../images/计算机图形学.assets/image-20211021083003337.png" alt="image-20211021083003337" style="zoom:50%;" /><p>主要方法：每一个边取中点，每一个面也取中点，然后把它们连起来</p><p>由例图可知：奇异点增加2，非四边形面减少两个</p><p>由上理解可知，在做第一次Catmull-Clark Subdivision之后，非四边形面全部消失，减少的数量等于奇异点增加的数量，第二次细分开始，奇异点、非四边形面的数量不再改变</p><p>第二次细分如图：<img src="../images/计算机图形学.assets/image-20211021083507849.png" alt="image-20211021083507849" style="zoom:50%;" /></p><p>点的更新方式：</p><img src="../images/计算机图形学.assets/image-20211021083659728.png" alt="image-20211021083659728" style="zoom:50%;" /><h3 id="Mesh-Simplification"><a href="#Mesh-Simplification" class="headerlink" title="Mesh Simplification"></a>Mesh Simplification</h3><h4 id="Collapsing-An-Edge-边的坍缩"><a href="#Collapsing-An-Edge-边的坍缩" class="headerlink" title="Collapsing An Edge 边的坍缩"></a>Collapsing An Edge 边的坍缩</h4><h5 id="Quadric-Error-Metrics-二次误差度量"><a href="#Quadric-Error-Metrics-二次误差度量" class="headerlink" title="Quadric Error Metrics 二次误差度量"></a>Quadric Error Metrics 二次误差度量</h5><p>求一条边对应的新的顶点到相关联的面的平方和，取平方和最小的新顶点</p> <img src="../images/计算机图形学.assets/image-20211021084615475.png" alt="image-20211021084615475" style="zoom:50%;" /> <img src="../images/计算机图形学.assets/image-20211021084831930.png" alt="image-20211021084831930" style="zoom:50%;" /><p>注意：是边的坍缩，上图帮助理解探索的过程</p><h4 id="Simplification-via-Quadric-Error"><a href="#Simplification-via-Quadric-Error" class="headerlink" title="Simplification via Quadric Error"></a>Simplification via Quadric Error</h4><p>核心算法： 对每一条边计算它的二次度量误差，从二次度量误差最小的边开始坍缩</p><p>问题：当对一条边进行坍缩之后，与这条边相关的边发生变化，对应的二次度量误差发生变化，影响核心算法的执行。</p><p>解决方法：选择堆作为数据结构，在更新某些变得二次度量误差之后，可以用最小的代价动态更新任何一点的值。</p><h6 id="注意：这种算法其实是一种贪心算法，无法获得实际最优解"><a href="#注意：这种算法其实是一种贪心算法，无法获得实际最优解" class="headerlink" title="注意：这种算法其实是一种贪心算法，无法获得实际最优解"></a>注意：这种算法其实是一种贪心算法，无法获得实际最优解</h6><h3 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h3><p>第一步：对光源进行光栅化，记录光源可以看到的点及其深度</p><p>第二步：从实际摄像头位置看向这个点，计算这个点到光源的深度，与光源记录的最大可见深度比较，可见则着色，不可见则为阴影</p><p>问题：</p><p>​1、数据精度问题，由于计算结果是浮点数，会产生误差</p><p>​2、当Shadow Mapping精度过低（分辨率），会产生走样问题</p><p>​3、只适合硬阴影</p> <img src="../images/计算机图形学.assets/image-20211021092131378.png" alt="image-20211021092131378" style="zoom:50%;" /><h2 id="Lec13-Ray-Tracing-1-Whitted-Style-Ray-Tracing"><a href="#Lec13-Ray-Tracing-1-Whitted-Style-Ray-Tracing" class="headerlink" title="Lec13 Ray Tracing 1(Whitted-Style Ray Tracing)"></a>Lec13 Ray Tracing 1(Whitted-Style Ray Tracing)</h2><h3 id="Why-Ray-Tracing"><a href="#Why-Ray-Tracing" class="headerlink" title="Why Ray Tracing?"></a>Why Ray Tracing?</h3><p>1、光栅化的局限性</p><p>​很难去做阴影，尤其是全局化的阴影、软阴影</p><p>​光线的多点反射也很困难（间接光照），比如镜面等</p><p>2、光栅化比较适合实施的应用，光追比较适合非实时的应用</p><h3 id="Light-Rays"><a href="#Light-Rays" class="headerlink" title="Light Rays"></a>Light Rays</h3><p>Three ideas about light rays</p><pre><code>1. Light travels in straight lines. (though this is wrong)2. Light rays do not &quot;collide&quot; with each other if they cross. (though this is still wrong)3. Light rays travel from the light sources to the eye. (but the physics is invariant under path reversal)</code></pre><h3 id="基础思路"><a href="#基础思路" class="headerlink" title="基础思路"></a>基础思路</h3><p>从眼睛（摄像机）开始，对可视范围内的每一个像素点发出射线，找到第一个接触点，将该点和光源进行连线，根据结果着色</p><h3 id="Whited-Style-Ray-Tracing"><a href="#Whited-Style-Ray-Tracing" class="headerlink" title="Whited-Style Ray Tracing"></a>Whited-Style Ray Tracing</h3> <img src="../images/计算机图形学.assets/image-20211022084717782.png" alt="image-20211022084717782" style="zoom:50%;" /><p>要点：在找到第一个接触点之后，会根据折射、反射的性质找到第二个、第三个等等的接触点，且在每一个接触点都会判断是否是阴影，根据结果着色</p><p>第一根射线叫primary ray，之后的其他射线都叫secondary rays，向光源发出的射线叫shadow rays</p><h4 id="Ray-Surface-Intersection"><a href="#Ray-Surface-Intersection" class="headerlink" title="Ray-Surface Intersection"></a>Ray-Surface Intersection</h4><h5 id="Ray-Equation"><a href="#Ray-Equation" class="headerlink" title="Ray Equation"></a>Ray Equation</h5><img src="../images/计算机图形学.assets/image-20211022085452527.png" alt="image-20211022085452527" style="zoom:50%;" /><p>解释：任何一个点，在t时间，从光源o开始，往d方向射出的距离</p><h5 id="隐式表面"><a href="#隐式表面" class="headerlink" title="隐式表面"></a>隐式表面</h5><p>sphere:</p> <img src="../images/计算机图形学.assets/image-20211022085856063.png" alt="image-20211022085856063" style="zoom: 25%;" /><p> Plane equation: <img src="../images/计算机图形学.assets/image-20211022090631635.png" alt="image-20211022090631635" style="zoom: 25%;" /></p><h5 id="显式表面"><a href="#显式表面" class="headerlink" title="显式表面"></a>显式表面</h5><p>Axis-Aligned Box轴对齐包围盒：把一个复杂物体包裹起来的盒子，如果光线不和包围盒相交，那么也不可能和里面的物体相交</p><p>对面：同法线的面，轴对齐包围盒有三组对面</p> <img src="../images/计算机图形学.assets/image-20211022093125021.png" alt="image-20211022093125021" style="zoom:50%;" /><p>计算方法：计算包围盒的六个面所在的无限大的平面与光线的交点，计算每一组对面的进入点和离开点，三组对面中最晚的进入点即光线进入包围盒的时间，三组对面中最早的离开点即光线离开包围盒的时间。</p><h2 id="Lec14-Ray-Tracing-2-Acceleration-amp-Rrdiometry"><a href="#Lec14-Ray-Tracing-2-Acceleration-amp-Rrdiometry" class="headerlink" title="Lec14 Ray Tracing 2(Acceleration &amp; Rrdiometry)"></a>Lec14 Ray Tracing 2(Acceleration &amp; Rrdiometry)</h2><h3 id="Uniform-Spatial-Partitions-Grids"><a href="#Uniform-Spatial-Partitions-Grids" class="headerlink" title="Uniform Spatial Partitions(Grids)"></a>Uniform Spatial Partitions(Grids)</h3><p>过程：</p><p>​1、对一个大场景取包围盒</p><p>​2、把该包围盒分成若干个小包围盒</p><p>​3、存取其中包含物体表面的包围盒（注意，仅包含物体内部的不需要记录）</p><p>​4、光线打入，首先判断打到的小包围盒中是否包含物体表面，否则进入下一个包围盒；是，则继续判断是否与包含的物体表面相交，再根据结果做进一步计算</p> <img src="../images/计算机图形学.assets/image-20211025151449577.png" alt="image-20211025151449577" style="zoom:67%;" /><p>注意：第二步中，把大包围盒分成的小包围盒的数量会影响效率，要适中</p><p>该方法不适合物体聚集，在空间中分布不均匀的情况</p><h3 id="Spatial-Partitions-空间划分"><a href="#Spatial-Partitions-空间划分" class="headerlink" title="Spatial Partitions 空间划分"></a>Spatial Partitions 空间划分</h3><img src="../images/计算机图形学.assets/image-20211025152209709.png" alt="image-20211025152209709" style="zoom:50%;" /><h5 id="Oct-Tree-八叉树"><a href="#Oct-Tree-八叉树" class="headerlink" title="Oct-Tree 八叉树"></a>Oct-Tree 八叉树</h5><p>在三维空间中，把包围盒均分成8块，并对其子块用此方法均分，直至达到某些条件停止均分，如包围盒过小，包围盒中无物体，等</p><p>注意，该方法在二维空间中为四叉树，如上图所示</p><p>在n维空间中为2^n叉树，也因此，在多维空间中较为复杂，不常使用</p><h5 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h5><p>每次沿一条轴进行划分，并对其子块用此方法划分，交替选取划分轴，使结果尽可能均匀</p><h5 id="BSP-Tree"><a href="#BSP-Tree" class="headerlink" title="BSP-Tree"></a>BSP-Tree</h5><p>在斜向上选择一条直线进行划分，以此类推</p><p>该方法缺点：较难计算，因为包围盒的边不是横平竖直的（与轴平行），尤其是对于高维的图形</p><h4 id="KD-Tree-1"><a href="#KD-Tree-1" class="headerlink" title="KD-Tree"></a>KD-Tree</h4> <img src="../images/计算机图形学.assets/image-20211025153858640.png" alt="image-20211025153858640" style="zoom:33%;" /><p>KD-Tree问题：</p><p>1、很难判断图形是否和包围盒有交集</p><p>2、一个物体可能存在多个包围盒中</p><h3 id="Object-Partition-amp-Bounding-Volume-Hierarchy-BVH"><a href="#Object-Partition-amp-Bounding-Volume-Hierarchy-BVH" class="headerlink" title="Object Partition &amp; Bounding Volume Hierarchy(BVH)"></a>Object Partition &amp; Bounding Volume Hierarchy(BVH)</h3> <img src="../images/计算机图形学.assets/image-20211025154657244.png" alt="image-20211025154657244" style="zoom:33%;" /><p>把物体分成两堆，求其包围盒</p><p>问题：由于是按物体划分，所以可能会产生包围盒的重叠</p><p> 技巧：</p><p>1、往最长的方向进行分割</p><p>2、找一个中位数，按其位置进行划分，使两边的三角形尽可能相同，使树的结构尽可能平衡</p><p>伪代码实现：</p> <img src="../images/计算机图形学.assets/image-20211025155709117.png" alt="image-20211025155709117" style="zoom:33%;" /><h3 id="Radiometry（辐射度量学）"><a href="#Radiometry（辐射度量学）" class="headerlink" title="Radiometry（辐射度量学）"></a>Radiometry（辐射度量学）</h3><p>Measurement system and units for illumination of light</p><p>Accurately measure the spatial properties of light</p><ul><li>New terms: Radiant flux, intensity, irradiance, radiance</li></ul><p>解释：在物理上准确定义光照的方法</p><p>Radiant Energy：</p><p>Definition: Radiant energy is the energy of electromagnetic radiation. It is measured in units of joules, and denoted bythe symbol:     Q[ J&#x3D; Joule]</p><p>Radiant Flux：</p><p>Definition: Radiant flux (power) is the energy emitted, reflected, transmitted or received, per unit time.</p><img src="../images/计算机图形学.assets/image-20211025161143819.png" alt="image-20211025161143819" style="zoom:25%;" /><p>Radiant Intensity: Light Emitted From A Source</p><p>Irradiance: Light Falling On A Surface</p><p>Radiance: Light Traveling Along A Ray</p> <img src="../images/计算机图形学.assets/image-20211025161539581.png" alt="image-20211025161539581" style="zoom:50%;" /><h4 id="Radiant-Intensity"><a href="#Radiant-Intensity" class="headerlink" title="Radiant Intensity"></a>Radiant Intensity</h4><p>Definition: The radiant(luminous) intensity is the power per unit solid angle(立体角) emitted by a point light source.</p><p>即每个立体角发出的光的能量</p><img src="../images/计算机图形学.assets/image-20211025161812363.png" alt="image-20211025161812363" style="zoom:33%;" /><h5 id="Angles-and-Solid-Angles"><a href="#Angles-and-Solid-Angles" class="headerlink" title="Angles and Solid Angles"></a>Angles and Solid Angles</h5><img src="../images/计算机图形学.assets/image-20211025162054090.png" alt="image-20211025162054090" style="zoom:33%;" /><p>Angle: l&#x2F;r</p><p>Solid Angles: 二维Angles在三维空间上的延申</p><h5 id="Differential-Solid-Angles"><a href="#Differential-Solid-Angles" class="headerlink" title="Differential Solid Angles"></a>Differential Solid Angles</h5><p>单位立体角: 即球面上很小的一块区域所对应的立体角</p> <img src="../images/计算机图形学.assets/image-20211025162547447.png" alt="image-20211025162547447" style="zoom:33%;" /> <img src="../images/计算机图形学.assets/image-20211025162737475.png" alt="image-20211025162737475" style="zoom:25%;" /><p>微分立体角：球面上任意一个点可以由两个角确定其位置，当这个点移动极小的距离，形成的新点与原点构成的新的区域对应的立体角即为微分立体角 </p> <img src="../images/计算机图形学.assets/image-20211027133123850.png" alt="image-20211027133123850" style="zoom: 67%;" /><h2 id="Lec15-Ray-Tracing-3-Light-Transport-amp-Global-Illumination"><a href="#Lec15-Ray-Tracing-3-Light-Transport-amp-Global-Illumination" class="headerlink" title="Lec15 Ray Tracing 3(Light Transport &amp; Global Illumination)"></a>Lec15 Ray Tracing 3(Light Transport &amp; Global Illumination)</h2><h3 id="Irradiance"><a href="#Irradiance" class="headerlink" title="Irradiance"></a>Irradiance</h3><p>Definition: The irrdiance is the power per (perpendicular&#x2F;projected) unit area incident on a surface point. </p><p>中文翻译(感谢b站老哥): 辐射度是入射到表面点上的单位面积的功率</p><p>注意：接收到的光线必须是与平面垂直的光线或者是光线的投影</p> <img src="../images/计算机图形学.assets/image-20211027134136717.png" alt="image-20211027134136717" style="zoom:50%;" /> <img src="../images/计算机图形学.assets/image-20211027134409748.png" alt="image-20211027134409748" style="zoom:50%;" /><h3 id="Radiance"><a href="#Radiance" class="headerlink" title="Radiance"></a>Radiance</h3><p>Radiance is the fundamental field quantity that describes the distribution of light in an environment.</p><p>Definition: The radiance(luminance) is the power emitted, reflected, transmitted or  received by a surface, per unit solid angle, per projected unit area. </p> <img src="../images/计算机图形学.assets/image-20211027140547454.png" alt="image-20211027140547454" style="zoom:50%;" /><p>比较Irridiance、Intensity、Radiance：</p><p>Intensity：每个点在单位立体角上发出的能量(点对面)</p><p>Irridiance：在单位面积上收到的能量(点对面)</p><p>Radiance：点对点的能量传送</p> <img src="../images/计算机图形学.assets/image-20211027140959172.png" alt="image-20211027140959172" style="zoom:50%;" /><h3 id="Bidirectional-Reflectance-Distribution-Function-BRDF"><a href="#Bidirectional-Reflectance-Distribution-Function-BRDF" class="headerlink" title="Bidirectional Reflectance Distribution Function(BRDF)"></a>Bidirectional Reflectance Distribution Function(BRDF)</h3><p>双向反射分布函数</p><p>BRDF解决的内容：</p><p>​理解方式一：一条光线接触到反射点，往不同的方向会反射多少的能量</p><p>​理解方式二：光线打到物体表面，被物体表面吸收，然后再从这一个点辐射出去</p> <img src="../images/计算机图形学.assets/image-20211027141936232.png" alt="image-20211027141936232" style="zoom:50%;" /><p>其中：L表示Radiance，E表示Irridiance</p> <img src="../images/计算机图形学.assets/image-20211027143410421.png" alt="image-20211027143410421" style="zoom:50%;" /><p>其中，sr是立体角单位(感谢弹幕老哥)</p> <img src="../images/计算机图形学.assets/image-20211027143754429.png" alt="image-20211027143754429" style="zoom:50%;" /><p>反射方程：也就是着色点对所有的入射光进行摄像机方向上的BRDF的转换结果之和。</p><p>渲染方程：即反射点反射的光 + 物体本身发出的光</p> <img src="../images/计算机图形学.assets/image-20211027200205032.png" alt="image-20211027200205032" style="zoom:50%;" /> <img src="../images/计算机图形学.assets/image-20211027200505808.png" alt="image-20211027200505808" style="zoom:50%;" /> <img src="../images/计算机图形学.assets/image-20211027202702840.png" alt="image-20211027202702840" style="zoom:50%;" /><p>上图最后一个方程的含义：全局光照的构成为经过0次、1次、2次、3次反射或折射的光线之和</p><p>光栅化只能实现0次或1次反射，更多次反射的光线很难通过光栅化去实现</p><h3 id="Probability-Review"><a href="#Probability-Review" class="headerlink" title="Probability Review"></a>Probability Review</h3><h4 id="Random-Variables"><a href="#Random-Variables" class="headerlink" title="Random Variables"></a>Random Variables</h4><p>随机变量和概率分布</p> <img src="../images/计算机图形学.assets/image-20211027203218973.png" alt="image-20211027203218973" style="zoom:50%;" /><h4 id="Probabilities"><a href="#Probabilities" class="headerlink" title="Probabilities"></a>Probabilities</h4> <img src="../images/计算机图形学.assets/image-20211027203332712.png" alt="image-20211027203332712" style="zoom:50%;" /><h4 id="Expected-Value-of-a-Random-Variable"><a href="#Expected-Value-of-a-Random-Variable" class="headerlink" title="Expected Value of a Random Variable"></a>Expected Value of a Random Variable</h4> <img src="../images/计算机图形学.assets/image-20211027203939103.png" alt="image-20211027203939103" style="zoom:50%;" /><h4 id="Probability-Distribution-Function-PDF"><a href="#Probability-Distribution-Function-PDF" class="headerlink" title="Probability Distribution Function(PDF)"></a>Probability Distribution Function(PDF)</h4> <img src="../images/计算机图形学.assets/image-20211027204226914.png" alt="image-20211027204226914" style="zoom:50%;" /><h4 id="Function-of-a-Random-Variable"><a href="#Function-of-a-Random-Variable" class="headerlink" title="Function of a Random Variable"></a>Function of a Random Variable</h4> <img src="../images/计算机图形学.assets/image-20211027204330345.png" alt="image-20211027204330345" style="zoom:50%;" /><h2 id="Lec16-Ray-Tracing-4-Monte-Carlo-Path-Tracing"><a href="#Lec16-Ray-Tracing-4-Monte-Carlo-Path-Tracing" class="headerlink" title="Lec16 Ray Tracing 4(Monte Carlo Path Tracing)"></a>Lec16 Ray Tracing 4(Monte Carlo Path Tracing)</h2><h2 id="Monte-Carlo-Integration"><a href="#Monte-Carlo-Integration" class="headerlink" title="Monte Carlo Integration"></a>Monte Carlo Integration</h2><p>蒙特卡洛积分：</p><p>随机取点，求其面积(定积分)，重复上述操作，求结果均值</p><p>$$<br>F_N&#x3D;\frac{1}{N}\sum^N_{i&#x3D;1}\frac{f(X_i)}{p(X_i)}<br>$$</p><h2 id="Path-Tracing"><a href="#Path-Tracing" class="headerlink" title="Path Tracing"></a>Path Tracing</h2><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6.assets/image-20220314180615986.png" alt="image-20220314180615986"></p><h1 id="面试准备–by策"><a href="#面试准备–by策" class="headerlink" title="面试准备–by策"></a>面试准备–by策</h1><h2 id="题目-1-判断两个三角形是否交叉"><a href="#题目-1-判断两个三角形是否交叉" class="headerlink" title="题目 1 判断两个三角形是否交叉"></a>题目 1 判断两个三角形是否交叉</h2><p>容易出在最后一道题</p><p><strong>解题思路</strong>：</p><ol><li>判断AABB盒子是否相交：未相交，则两个三角形不可能交叉；相交，则进入步骤2。</li><li>判断两个三角形是否交叉，其实只要知道其中任意一个三角形的一条边是否与另一个三角形有交点，则问题转换为求三角形和线段是否有交点的问题，进入步骤3。</li><li>判断线段的两个端点是否在三角形面的同侧：在同侧，则两个三角形不可能交叉；有任意一点在三角形平面上，判断该点是否在三角形内部，具体情况具体分析；在异侧，求两个端点到三角形平面的投影，求其插值，得到线段与三角形平面的交点，进入步骤4。</li><li>判断交点是否在三角形内部：在，则线段与三角形相交，即两个三角形交叉；不在，则线段与三角形不相交，进入步骤5。</li><li>对每个三角形的每一条边进行步骤3、4的操作，直至找到线段与三角形平面的交点在三角形内部的情况，此时，证明两个三角形交叉；或者，当遍历完所有的情况，未发现线段与三角形平面的交点在三角形内部，此时，证明两个三角形不交叉。</li></ol><h2 id="题目-2-图像渲染的四个阶段"><a href="#题目-2-图像渲染的四个阶段" class="headerlink" title="题目 2  图像渲染的四个阶段"></a>题目 2  图像渲染的四个阶段</h2><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6.assets/image-20211216141417993.png" alt="image-20211216141417993"></p><p>Application阶段：在CPU上运行</p><p>Geometry　processing：主要是transform，projection</p><p>Rasterization：三个顶点</p><p>Pixel　Processing：每个屏幕上点的颜色</p><h3 id="应用程序阶段-application-stage"><a href="#应用程序阶段-application-stage" class="headerlink" title="应用程序阶段　application　stage"></a>应用程序阶段　application　stage</h3><p>宏观上的、大范围的、物体级别的渲染处理。</p><p>这阶段CPU上运行的可能可以多线程，碰撞检测比较费</p><p>提供给下一阶段的数据：Draw Call，一般的优化方案：减少Draw Call的次数</p><p>简单来说，其实就是，生成指令，即这一块该怎么渲染，哪一部分应该先渲染，哪一部分应该后渲染</p><h3 id="几何处理-Geometry-Processing"><a href="#几何处理-Geometry-Processing" class="headerlink" title="几何处理 Geometry Processing"></a>几何处理 Geometry Processing</h3><p>微观的，顶点（三角面）级别的数据处理。</p><p>还是四个阶段。</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6.assets/image-20211216141535185.png" alt="image-20211216141535185"></p><h4 id="Vertex-Shading"><a href="#Vertex-Shading" class="headerlink" title="Vertex Shading"></a>Vertex Shading</h4><p>空间变换：顶点空间-&gt;世界空间-&gt;Camera空间</p><p>​    tessellation, geometry shading, and stream output</p><h4 id="Projection"><a href="#Projection" class="headerlink" title="Projection"></a>Projection</h4><p>生成屏幕空间的三角面数据，2D的，但带有深度信息</p><h4 id="Clipping"><a href="#Clipping" class="headerlink" title="Clipping"></a>Clipping</h4><p>裁剪</p><h4 id="Screen-Mapping"><a href="#Screen-Mapping" class="headerlink" title="Screen Mapping"></a>Screen Mapping</h4><p>映射到屏幕空间，进行拉伸等操作</p><h3 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h3><p>光栅化</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6.assets/image-20211221233335410.png" alt="image-20211221233335410"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/posts/d04bd5bc/"/>
      <url>/posts/d04bd5bc/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1-操作系统的应用"><a href="#1-1-操作系统的应用" class="headerlink" title="1.1 操作系统的应用"></a>1.1 操作系统的应用</h1><p>操作系统的定义：操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各作业进行调度，以及方便用户使用的程序的集合</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>方便：方便用户使用</p><p>有效：提高系统的资源利用率；提高系统的吞吐量</p><p>可扩充性：适用硬件、体系结构、应用的发展需求；误解偶-&gt;模块化-&gt;层次结构-&gt;面向对象</p><p>开放性：遵循国际标准，以实现兼容性</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>用户与计算机硬件系统之间的接口</p><p>计算机系统资源的管理者</p><p>实现对计算机资源的抽象</p><h2 id="推动OS发展的动力"><a href="#推动OS发展的动力" class="headerlink" title="推动OS发展的动力"></a>推动OS发展的动力</h2><p>不断提高计算机资源利用率</p><p>方便用户</p><p>器件的不断更新</p><p>计算机体系结构的不断发展</p><p>不断提出新的应用需求</p><h1 id="1-2-操作系统的发展过程"><a href="#1-2-操作系统的发展过程" class="headerlink" title="1.2 操作系统的发展过程"></a>1.2 操作系统的发展过程</h1><h2 id="人工操作方式"><a href="#人工操作方式" class="headerlink" title="人工操作方式"></a>人工操作方式</h2><p>用户独占全机</p><p>CPU等待人工操作</p><h2 id="脱机输入输出方式"><a href="#脱机输入输出方式" class="headerlink" title="脱机输入输出方式"></a>脱机输入输出方式</h2><p>解决问题：人机矛盾、CPU和I&#x2F;O设备之间速度不匹配</p><p>减少CPU空闲时间</p><p>提高I&#x2F;O速度</p><h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><p>批处理系统旨在提高系统资源利用率和系统吞吐量</p><p>缺点：系统中的资源得不到充分利用</p><h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><p>后备队列</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>资源利用率高</p><p>系统吞吐量大</p><p>平均周转时间长</p><p>无交互能力</p><h3 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h3><p>处理机争用问题</p><p>内存分配和保护问题</p><p>I&#x2F;O设备分配问题</p><p>文件的组织和管理问题</p><p>作业管理问题</p><p>用户与系统的接口问题</p><h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><p>主要动力：满足用户对人机交互的需求</p><p>用户需求：人机交互、共享主机</p><p>关键问题：及时接收、及时处理（作业直接进入内存、采用轮转运行方式）</p><p>特征1：多路性</p><p>特征2：独立性</p><p>特征3：及时性</p><p>特征4：交互性</p><h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h2><p>特征1-4同分时系统</p><p>特征5：可靠性</p><p>注意点：开始截止时间、完成截止时间、硬实时任务(HRT)、软实时任务(SRT)</p><h2 id="微机系统"><a href="#微机系统" class="headerlink" title="微机系统"></a>微机系统</h2><p>单用户单任务OS：只允许一个用户上机且只允许用户程序作为一个任务运行，CP&#x2F;M、MS-DOS</p><p>单用户多任务OS：只允许一个用户上机但允许用户把程序分为若干个任务使它们并发执行</p><p>多用户多任务OS：允许多个用户通过各自的终端，使用同一台机器，共享主机系统中的各种资源，而每个用户程序又可进一步分为几个任务，使它们能并发执行，从而可进一步提高资源利用率和系统吞吐量，UNIX OS</p><h1 id="1-3-操作系统的基本特性"><a href="#1-3-操作系统的基本特性" class="headerlink" title="1.3 操作系统的基本特性"></a>1.3 操作系统的基本特性</h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>互斥共享</p><p>同时访问</p><h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><p>互斥共享技术</p><p>​虚拟处理机技术</p><p>​虚拟设备技术</p><p>空分复用技术</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>进程以人们不可预知的顺序推进，但是无论以何种顺序推进，结构都相同</p><h1 id="1-4-操作系统的主要功能"><a href="#1-4-操作系统的主要功能" class="headerlink" title="1.4 操作系统的主要功能"></a>1.4 操作系统的主要功能</h1><h2 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h2><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>创建</p><p>撤销</p><p>状态转换</p><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><p>互斥</p><p>同步</p><p>锁-信号</p><p>临界资源</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>管道</p><p>消息队列</p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>作业调度</p><p>进程调度</p><h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><p>主要任务：为多道程序的运行提供良好的环境，提高存储器的利用率，方便用户使用，并能从逻辑上扩充内存</p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>主要任务：为每道程序分配内存空间、提高存储器的利用率、允许正在运行的程序申请附加的内存空间</p><p>静态分配</p><p>动态分配</p><h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>主要任务：1、确保每道用户程序都仅在自己的内存空间内运行，彼此互不干扰。2、绝不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中去执行</p><h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><h3 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h3><p>请求调入功能</p><p>置换功能</p><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><p>主要任务：</p><p>1、完成用户进程提供的I&#x2F;O请求，为用户进程分配所需的I&#x2F;O设备，并完成指定的I&#x2F;O操作</p><p>2、提高CPU和I&#x2F;O设备的利用率，提高I&#x2F;O速度，方便用户使用I&#x2F;O设备</p><h3 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h3><p>缓和CPU和I&#x2F;O设备速度不匹配的矛盾，提高CPU的利用率，进而提高系统吞吐量</p><h3 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h3><h3 id="设备处理"><a href="#设备处理" class="headerlink" title="设备处理"></a>设备处理</h3><p>驱动</p><p>实现CPU和设备控制器之间的通信</p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>主要任务：对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性</p><h3 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h3><p>为每个文件分配必要的外存空间，提高外存的利用率，进而提高文件系统的存、取速度</p><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><p>为每个文件建立目录项，并对众多的目录项有效组织，以实现方便的按名存取</p><h3 id="文件的读写管-x2F-理和保护"><a href="#文件的读写管-x2F-理和保护" class="headerlink" title="文件的读写管&#x2F;理和保护"></a>文件的读写管&#x2F;理和保护</h3><p>文件保护：防止未经核准的用户存取文件、防止冒名顶替存取文件、防止以不正确的方式使用文件</p><h3 id="操作系统与用户之间的接口"><a href="#操作系统与用户之间的接口" class="headerlink" title="操作系统与用户之间的接口"></a>操作系统与用户之间的接口</h3><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211121162225300.png" alt="image-20211121162225300"></p><h4 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h4><p>联机用户接口</p><p>脱机用户接口</p><p>图形用户接口</p><h4 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h4><h3 id="现代操作系统的新功能"><a href="#现代操作系统的新功能" class="headerlink" title="现代操作系统的新功能"></a>现代操作系统的新功能</h3><h4 id="系统安全"><a href="#系统安全" class="headerlink" title="系统安全"></a>系统安全</h4><p>认证技术</p><p>密码技术</p><p>访问控制技术</p><p>反病毒技术</p><h4 id="网络功能和服务"><a href="#网络功能和服务" class="headerlink" title="网络功能和服务"></a>网络功能和服务</h4><p>网络通信</p><p>资源管理</p><p>应用互操作</p><h4 id="支持多媒体"><a href="#支持多媒体" class="headerlink" title="支持多媒体"></a>支持多媒体</h4><p>接纳控制功能</p><p>实时调度</p><p>多媒体文件的存储</p><h1 id="1-5-操作系统的结构设计"><a href="#1-5-操作系统的结构设计" class="headerlink" title="1.5 操作系统的结构设计"></a>1.5 操作系统的结构设计</h1><h2 id="传统操作系统结构"><a href="#传统操作系统结构" class="headerlink" title="传统操作系统结构"></a>传统操作系统结构</h2><p>无结构操作系统</p><p>模块化操作系统</p><p>​优点：</p><p>​提高了OS设计的正确性、可理解性和可维护性</p><p>​容易扩充，增强了OS的可适应性</p><p>​加速了OS的开发过程</p><p>​缺点</p><p>​模块及接口划分较困难</p><p>​从功能上划分模块，未区别共享资源和独占资源</p><p>​由于管理的差异，使OS结构变得不够清晰</p><p>分层结构操作系统</p><p>​优点：</p><p>​功能明确，调用关系清晰（高层对低层单向依赖），有利于<strong>保证设计和实现的正确性</strong></p><p>​低层和高层可分别实现（<strong>便于扩充和维护</strong>）；高层错误不会影响到低层；避免递归调用</p><p>​缺点：</p><p>​<strong>系统效率降低</strong>，各系统对具体划分多少层次有不同的看法。</p><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>在CPU设计和生产的时候就划分了特权指令和非特权指令</p><p>应用程序只能使用非特权指令，如加法指令、减法指令</p><p>内核程序可以执行特权指令，如内存清零指令</p><p>特权指令只能由操作系统内核来使用</p><p>CPU 有两种状态，<strong>“内核态”</strong>和<strong>“用户态”</strong> （在CPU程序状态字寄存器PSW中存储）</p><p>处于<strong>内核态时</strong>，说明此时正在运行的是内核程序，此时可以执行<strong>特权指令</strong> </p><p>处于<strong>用户态时</strong>，说明此时正在运行的是应用程序，此时只能执行<strong>非特权指令</strong></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211121155241687.png" alt="image-20211121155241687"></p><p><strong>内核</strong>是操作系统最基本、最核心的部分。 实现操作系统内核功能的那些程序就是<strong>内核程序</strong>。</p><p>注意：操作系统内核需要运行在<strong>内核态</strong><br>操作系统的非内核功能运行在<strong>用户态</strong></p><h2 id="客户-x2F-服务器模式"><a href="#客户-x2F-服务器模式" class="headerlink" title="客户&#x2F;服务器模式"></a>客户&#x2F;服务器模式</h2><p>优点</p><p>​数据分布处理和存储、便于集中管理、灵活性和可扩充性、易于改编应用软件</p><p>缺点</p><p>​不可靠性和瓶颈问题、各模块与微内核间通过通信机制交互，系统运行效率较低</p><h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><h2 id="微内核OS结构"><a href="#微内核OS结构" class="headerlink" title="微内核OS结构"></a>微内核OS结构</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>增强了操作系统的可扩展性</p><p>增强了系统的可靠性</p><p>可移植性强</p><p>提供了对分布式系统的支持</p><p>融入了面向对象技术</p><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题#"></a>存在问题#</h3><p>内核态与用户态频繁切换，导致运行效率有所降低</p><h2 id="操作行动的体系结构"><a href="#操作行动的体系结构" class="headerlink" title="操作行动的体系结构"></a>操作行动的体系结构</h2><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><h4 id="两种指令"><a href="#两种指令" class="headerlink" title="两种指令"></a>两种指令</h4><p>特权指令如：内存清零指令</p><p>非特权指令如：普通的运算指令</p><h4 id="两种处理器状态"><a href="#两种处理器状态" class="headerlink" title="两种处理器状态"></a>两种处理器状态</h4><p>核心态#</p><p>用户态</p><h4 id="两种程序"><a href="#两种程序" class="headerlink" title="两种程序"></a>两种程序</h4><p>内核程序</p><p>应用程序</p><h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211121161219150.png" alt="image-20211121161219150"></p><h4 id="时钟管理"><a href="#时钟管理" class="headerlink" title="时钟管理"></a>时钟管理</h4><p>实现计时功能</p><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><p>负责实现中断机制</p><h4 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h4><p>是一种特殊的程序</p><p>处于操作系统最底层，是最接近硬件的部分</p><p>这种程序的运行具有原子性——其运行只能一气呵成，不可中断</p><p>运行时间较短，调用频繁</p><h4 id="对系统资源进行管理的功能"><a href="#对系统资源进行管理的功能" class="headerlink" title="对系统资源进行管理的功能"></a>对系统资源进行管理的功能</h4><p>进程管理</p><p>存储器管理</p><p>设备管理</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211121161236992.png" alt="image-20211121161236992"></p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211121161247400.png" alt="image-20211121161247400"></p><p>CPU 上会运行两种程序，一种是<strong>操作系统内核程序</strong>，一种是应用程序</p><p>“中断”是让操作系统内核夺回CPU使用权的<strong>唯一途径</strong></p><p>如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序</p><p>中断”会使CPU由<strong>用户态</strong>变为<strong>内核态</strong>，使操作系统重新夺回对CPU的控制权</p><p>内中断：与当前执行的指令有关， 中断信号来源于CPU内部</p><p>​如除法指令除数为0、陷入指令（应用程序请求操作系统服务）</p><p>外中断：与当前执行的指令无关， 中断信号来源于CPU外部</p><p>​如始终不见每30ms发送一个时钟中断信号</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211121162122531.png" alt="image-20211121162122531"></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211121162154377.png" alt="image-20211121162154377"></p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211121162312288.png" alt="image-20211121162312288"></p><p>应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是<strong>与共享资源有关的操作（如存储分配、I&#x2F;O操作、文件管理等）</strong>，都必须通过系统调用的方式向操作系统内核提 出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p><h1 id="2-1-程序"><a href="#2-1-程序" class="headerlink" title="2.1 程序"></a>2.1 程序</h1><h2 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h2><h2 id="程序顺序执行特征"><a href="#程序顺序执行特征" class="headerlink" title="程序顺序执行特征"></a>程序顺序执行特征</h2><p>顺序性</p><p>封闭性</p><p>可再现性</p><h2 id="程序并发执行特征"><a href="#程序并发执行特征" class="headerlink" title="程序并发执行特征"></a>程序并发执行特征</h2><p>间断性</p><p>失去封闭性</p><p>不可再现性</p><h1 id="2-2-进程的描述"><a href="#2-2-进程的描述" class="headerlink" title="2.2 进程的描述"></a>2.2 进程的描述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>程序关于某个数据集合的一次执行过程</p><h2 id="组成部分-PCB-程序段-数据段"><a href="#组成部分-PCB-程序段-数据段" class="headerlink" title="组成部分(PCB+程序段+数据段)"></a>组成部分(PCB+程序段+数据段)</h2><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>动态性</p><p>并发性</p><p>独立性</p><p>异步性</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><h3 id="就绪、执行、堵塞"><a href="#就绪、执行、堵塞" class="headerlink" title="就绪、执行、堵塞"></a>就绪、执行、堵塞</h3><img src="../images/操作系统.assets/image-20211122132938642.png" alt="image-20211122132938642" style="zoom:50%;" /><h3 id="挂起原语"><a href="#挂起原语" class="headerlink" title="挂起原语"></a>挂起原语</h3><p>引起挂起状态的原因：<br>    终端用户的请求<br>    父进程请求<br>    负荷调节的需要<br>    操作系统的需要  </p><h3 id="PCB的作用"><a href="#PCB的作用" class="headerlink" title="PCB的作用"></a>PCB的作用</h3><h3 id="PCB中的信息"><a href="#PCB中的信息" class="headerlink" title="PCB中的信息"></a>PCB中的信息</h3><h4 id="进程标识符"><a href="#进程标识符" class="headerlink" title="进程标识符"></a>进程标识符</h4><p>内部标识符</p><p>外部标识符</p><h4 id="处理机状态"><a href="#处理机状态" class="headerlink" title="处理机状态"></a>处理机状态</h4><p>通用寄存器</p><p>指令计数器</p><p>程序状态字PSW</p><p>用户栈指针</p><h4 id="进程调度信息"><a href="#进程调度信息" class="headerlink" title="进程调度信息"></a>进程调度信息</h4><p>进程状态</p><p>进程优先级</p><p>进程调度算法</p><p>事件：进程变为堵塞态的事件</p><h4 id="进程控制信息"><a href="#进程控制信息" class="headerlink" title="进程控制信息"></a>进程控制信息</h4><p>程序和数据地址</p><p>进程同步和通信机制</p><p>资源清单</p><h3 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h3><p>线性方式</p><p>链接方式</p><p>索引方式</p><img src="../images/操作系统.assets/image-20211122133547810.png" alt="image-20211122133547810" style="zoom:50%;" /><h1 id="2-3-进程控制"><a href="#2-3-进程控制" class="headerlink" title="2.3 进程控制"></a>2.3 进程控制</h1><p>进程的创建</p><p>进程的终止</p><p>进程的堵塞与唤醒</p><p>进程的挂起与激活</p><p>无论哪个进程控制原语， 要做的无非三类事情：<br>    更新PCB中的信息<br>        a. 所有的进程控制原语一定都会修改进程状态标志<br>        b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境<br>        c. 某进程开始运行前必然要恢复其运行环境<br>    将PCB插入合适的队列<br>    分配&#x2F;回收资源  </p><h1 id="2-4-2-5-进程同步"><a href="#2-4-2-5-进程同步" class="headerlink" title="2.4-2.5 进程同步"></a>2.4-2.5 进程同步</h1><h2 id="两种制约方式"><a href="#两种制约方式" class="headerlink" title="两种制约方式"></a>两种制约方式</h2><p>间接制约方式</p><p>直接制约方式</p><h2 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h2><img src="../images/操作系统.assets/image-20211122140209517.png" alt="image-20211122140209517" style="zoom:50%;" /><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>进程访问临界资源的<strong>代码段</strong></p><h2 id="同步规则"><a href="#同步规则" class="headerlink" title="同步规则"></a>同步规则</h2><p> <strong>空闲让进、忙则等待、有限等待、让权等待</strong></p><h2 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h2><p>关中断</p><p>test-and-set指令：测试指令</p><p>Swap指令：交换指令</p><img src="../images/操作系统.assets/image-20211122141413327.png" alt="image-20211122141413327" style="zoom:50%;" /><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>整形信号量</p><p>记录型信号量：满足忙则等待</p><p>AND型信号量</p><p>信号量集</p><p>​Swait(S, d, d)， 只有一个信号量S， 允许每次申请d个资源，若现有资源数少于d， 不予分配<br>​Swait(S, 1, 1)， 蜕化为一般的记录型信号量(S&gt;1时)或互斥信号量(S&#x3D;1时)<br>​Swait(S, 1, 0)， 当S&gt;&#x3D;1时， 允许多个进程进入某特定区， 当S变为0后， 阻止任何进程进入特定区， 相当于可控开关  </p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>进程互斥</p><p>实现前驱关系</p><h2 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h2><h2 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a>经典进程同步问题</h2><p>生产者-消费者问题</p><p>哲学家进餐问题</p><p>读者-写者问题</p><p><strong>行人过桥问题</strong></p><h1 id="2-6-进程通信"><a href="#2-6-进程通信" class="headerlink" title="2.6 进程通信"></a>2.6 进程通信</h1><h2 id="进程通信的类型"><a href="#进程通信的类型" class="headerlink" title="进程通信的类型"></a>进程通信的类型</h2><p>低级通信，进程间仅交换一些状态和少量数据。 如： 进程之间的互斥和同步<br>    信号量机制作为通信工具的缺点：(1)效率低 (2)通信对用户不透明<br>    共享某些数据结构或共享存储区</p><p>高级通信： 进程间可交换大量数据，对用户透明<br>    共享存储器系统、 消息传递系统、 管道通信系统、 客户机-服务器</p><h3 id="共享存储器系统"><a href="#共享存储器系统" class="headerlink" title="共享存储器系统"></a>共享存储器系统</h3><p>基于共享数据结构的通信方式</p><p>基于共享存储区的通信方式</p><h3 id="管道通信系统"><a href="#管道通信系统" class="headerlink" title="管道通信系统"></a>管道通信系统</h3><p>只能实现单向的传输</p><p>各进程要互斥地访问管道</p><p>数据以字符流的形式写入管道， 当管道写满时， 写进程的write()系统调用将被阻塞， 等待读进程将数据取走。 当读进程将数据全部取走后， 管道变空， 此时读进程的read()系统调用将被阻塞。</p><p>如果没写完， 就不允许读。 如果没读空， 就不允许写。</p><p>数据一旦被读出， 就从管道中被抛弃， 这就意味着读进程最多只能有一个</p><h3 id="消息传递系统"><a href="#消息传递系统" class="headerlink" title="消息传递系统"></a>消息传递系统</h3><p>直接通信方式</p><p>间接通信方式：信箱通信</p><h3 id="客户端-服务器系统"><a href="#客户端-服务器系统" class="headerlink" title="客户端-服务器系统"></a>客户端-服务器系统</h3><p>套接字</p><p>远程过程与方法调用</p><h2 id="消息传递通信的实现方式"><a href="#消息传递通信的实现方式" class="headerlink" title="消息传递通信的实现方式"></a>消息传递通信的实现方式</h2><h3 id="直接消息传递系统"><a href="#直接消息传递系统" class="headerlink" title="直接消息传递系统"></a>直接消息传递系统</h3><p>对称寻址方式</p><p>非对称寻址方式</p><h3 id="邮箱通信"><a href="#邮箱通信" class="headerlink" title="邮箱通信"></a>邮箱通信</h3><p>信箱通信</p><h1 id="2-7-2-8-线程"><a href="#2-7-2-8-线程" class="headerlink" title="2.7-2.8 线程"></a>2.7-2.8 线程</h1><h2 id="调度单位"><a href="#调度单位" class="headerlink" title="调度单位"></a>调度单位</h2><h2 id="不是资源拥有单位"><a href="#不是资源拥有单位" class="headerlink" title="不是资源拥有单位"></a>不是资源拥有单位</h2><h2 id="进程与线程的比较"><a href="#进程与线程的比较" class="headerlink" title="进程与线程的比较"></a>进程与线程的比较</h2><table><thead><tr><th align="center"></th><th align="center">调度的基本单位</th><th align="center">并发性</th><th align="center">拥有资源</th><th align="center">独立性</th><th align="center">系统开销</th><th align="center">多处理机</th></tr></thead><tbody><tr><td align="center">无线程的OS</td><td align="center">进程</td><td align="center">√</td><td align="center">以进程为单位</td><td align="center">进程高</td><td align="center">大</td><td align="center">不支持</td></tr><tr><td align="center">有线程的OS</td><td align="center">线程</td><td align="center">进程+线程</td><td align="center">线程仅拥有必不可少的部分资源</td><td align="center">线程低</td><td align="center">小</td><td align="center">支持</td></tr></tbody></table><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>内核支持线程KST</p><p>用户级线程</p><p>组合方式及对应关系：一对一、多对一、多对多</p><h2 id="线程的实现-1"><a href="#线程的实现-1" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>内核支持线程KST</p><p>用户级线程</p><p>组合方式及对应关系：一对一、多对一、多对多</p><h1 id="3-1-处理机调度的层次和目标"><a href="#3-1-处理机调度的层次和目标" class="headerlink" title="3.1 处理机调度的层次和目标"></a>3.1 处理机调度的层次和目标</h1><p>作业：外存-&gt;内存</p><h2 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h2><p>高级调度(作业调度、长程调度)</p><p>中级调度(内存调度，挂起+激活)</p><p>低级调度(进程调度、短程调度)</p><table><thead><tr><th align="center"></th><th align="center">要做什么</th><th align="center">调度发生在..</th><th align="center">发生 频率</th><th align="center">对进程状态的影响</th></tr></thead><tbody><tr><td align="center">高级调度 （作业调度）</td><td align="center">按照某种规则，从后备队列中 选择合适的作业将其调入内存，并为其创建进程</td><td align="center">外存→内存</td><td align="center">最低</td><td align="center">无→创建态→就绪态</td></tr><tr><td align="center">中级调度 （内存调度）</td><td align="center">按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td><td align="center">外存→内存</td><td align="center">中等</td><td align="center">禁止就绪→活动就绪 （禁止阻塞→活动阻塞）</td></tr><tr><td align="center">低级调度 （进程调度）</td><td align="center">按照某种规则，从就绪队列中 选择一个进程为其分配处理机</td><td align="center">内存→CPU</td><td align="center">最高</td><td align="center">就绪态→运行态</td></tr></tbody></table><h2 id="处理机调度目标"><a href="#处理机调度目标" class="headerlink" title="处理机调度目标"></a>处理机调度目标</h2><h3 id="共同目标"><a href="#共同目标" class="headerlink" title="共同目标"></a>共同目标</h3><p>提高资源利用率</p><p>公平性(面向进程)</p><p>平衡性(面向设备)</p><p>策略强制执行</p><h3 id="批处理OS的目标"><a href="#批处理OS的目标" class="headerlink" title="批处理OS的目标"></a>批处理OS的目标</h3><p>平均周转时间短：在后备队列上的时间+在就绪队列的时间+在CPU的时间+等待I&#x2F;O完成的时间</p><p>系统吞吐量高</p><p>处理机利用率高</p><h3 id="分时系统目标"><a href="#分时系统目标" class="headerlink" title="分时系统目标"></a>分时系统目标</h3><p>响应时间快</p><p>均衡性</p><h3 id="实时系统目标"><a href="#实时系统目标" class="headerlink" title="实时系统目标"></a>实时系统目标</h3><p>截止时间保证</p><p>可预测性</p><h1 id="3-2-作业与作业调度（早期批处理系统）"><a href="#3-2-作业与作业调度（早期批处理系统）" class="headerlink" title="3.2 作业与作业调度（早期批处理系统）"></a>3.2 作业与作业调度（早期批处理系统）</h1><h2 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h2><table><thead><tr><th>算法思想</th><th>主要从“公平” 的角度考虑（类似于我们生活中排队买东西的例子）</th></tr></thead><tbody><tr><td>算法规则</td><td>按照作业&#x2F;进程到达的先后顺序进行服务</td></tr><tr><td>用于作业&#x2F;进 程调度</td><td>用于作业调度时， 考虑的是哪个作业先到达后备队列； 用于进程调度 时， 考虑的是哪个进程先到达就绪队列</td></tr><tr><td>是否可抢占？</td><td>非抢占式的算法</td></tr><tr><td>优缺点</td><td>优点： 公平、 算法实现简单 缺点： 排在长作业（进程） 后面的短作业 需要等待很长时 间， 带权周转时间很大， 对短作业来说用户体验不好。 即， FCFS算法对长作业有利， 对短作业不利（Eg ： 排队买奶茶…）</td></tr><tr><td>是否会导致 饥饿</td><td>不会</td></tr></tbody></table><h2 id="短作业优先SJF"><a href="#短作业优先SJF" class="headerlink" title="短作业优先SJF"></a>短作业优先SJF</h2><table><thead><tr><th>算法思想</th><th>追求最少的平均等待时间， 最少的平均周转时间、 最少的平均带权周转时间</th></tr></thead><tbody><tr><td>算法规则</td><td>最短的作业&#x2F;进程优先得到服务（所谓“最短” ， 是指<strong>要求服务时间最短</strong></td></tr><tr><td>用于作业&#x2F;进 程调度</td><td>即可用于作业调度， 也可用于进程调度。 用于进程调度时称为“短进程 优先（<strong>SPF</strong>, Shortest Process First） 算法”</td></tr><tr><td>是否可抢占？</td><td>SJF和SPF是<strong>非抢占式</strong>的算法。 但是也有抢占式的版本——<strong>最短剩余时 间优先算法</strong>（SRTN, Shortest Remaining Time Next） ， <strong>默认非抢占式</strong></td></tr><tr><td>优缺点</td><td>优点： “最短的” <strong>平均等待时间、 平均周转时间</strong> <br />缺点： 不公平。 <strong>对短作业有利， 对长作业不利</strong>。 可能产生饥饿现象。</td></tr><tr><td>是否会导致 饥饿</td><td>会。 如果源源不断地有短作业&#x2F;进程到来， 可能使长作业&#x2F;进程长时间得不 到服务， 产生“<strong>饥饿</strong>” 现象。 如果一直得不到服务， 则称为“<strong>饿死</strong>”</td></tr></tbody></table><h2 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h2><p>Priority-Scheduling Algorithm, PSA</p><p>外部赋予</p><h2 id="高相应比优先调度算法"><a href="#高相应比优先调度算法" class="headerlink" title="高相应比优先调度算法"></a>高相应比优先调度算法</h2><p>Highest Response Ratio Next, HRRN</p><p>优先权 &#x3D; (等待服务时间 + 要求服务时间) &#x2F; 要求服务时间</p><table><thead><tr><th>算法思想</th><th>要综合考虑作业&#x2F;进程的等待时间和要求服务的时间</th></tr></thead><tbody><tr><td>算法规则</td><td>在每次调度时先计算各个作业&#x2F;进程的<strong>响应比</strong>，选择<strong>响应比最高</strong>的作业&#x2F;进程为其服务</td></tr><tr><td>用于作业&#x2F;进程调度</td><td>即可用于作业调度，也可用于进程调度。</td></tr><tr><td>是否可抢占？</td><td><strong>非抢占式</strong>的算法。 因此只有当前运行的作业&#x2F;进程<strong>主动放弃处理机</strong>时，才需要调度，才需要计算响应比</td></tr><tr><td>优缺点</td><td>综合考虑了等待时间和运行时间（要求服务时间）等待时间相同时，要求服务时间短的优先（SJF的优点） 要求服务时间相同时， 等待时间长的优先（FCFS 的优点） 对于长作业来说， 随着等待时间越来越久， 其响应比也会 越来越大， 从而避免了长作业饥饿的问题</td></tr><tr><td>是否会导致饥饿</td><td>不会</td></tr></tbody></table><img src="../images/操作系统.assets/image-20211122202818695.png" alt="image-20211122202818695" style="zoom:50%;" /><h1 id="3-3-进程调度（交互式系统）"><a href="#3-3-进程调度（交互式系统）" class="headerlink" title="3.3 进程调度（交互式系统）"></a>3.3 进程调度（交互式系统）</h1><h3 id="轮转调度算法Round-Robin-RR"><a href="#轮转调度算法Round-Robin-RR" class="headerlink" title="轮转调度算法Round Robin, RR"></a>轮转调度算法Round Robin, RR</h3><table><thead><tr><th>算法思想</th><th>公平地、 轮流地为各个进程服务， 让每个进程在一定时间间隔得到内都可以响应</th></tr></thead><tbody><tr><td>算法规则</td><td>按照各进程到达就绪队列的顺序， 轮流让各个进程执行<strong>一个时间片</strong>（如 100ms） 。 若进程未在一个时间片内执行完， 则剥夺处理机， 将进程重 新放到就绪队列队尾重新排队。</td></tr><tr><td>用于作业&#x2F;进 程调度</td><td>用于<strong>进程调度</strong>（只有作业放入内存建立了相应的进程后， 才能被分配处 理机时间片）</td></tr><tr><td>是否可抢占？</td><td>若进程未能在时间片内运行完， 将被强行剥夺处理机使用权， 因此时间 片轮转调度算法属于<strong>抢占式的算法</strong>。 由时钟装置发出时钟中断来通知 CPU时间片已到</td></tr><tr><td>优缺点</td><td>优点： 公平； 响应快， 适用于分时操作系统； 缺点： 由于高频率的进程切换， 因此有一定开销； 不区分任务的紧急程 度。</td></tr><tr><td>是否会导致 饥饿</td><td>不会</td></tr></tbody></table><h3 id="优先级调度算法-1"><a href="#优先级调度算法-1" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p>此算法常用于<strong>批处理系统</strong>中， 作为<strong>作业调度算法</strong>。 也作为多种操作系统中的<strong>进程调度算法</strong>， 还可用于<strong>实时系统</strong>中。</p><p>两种占用CPU的方式：<strong>非抢占式优先级算法</strong>， <strong>抢占式优先级算法</strong></p><p><strong>非抢占式优先级算法</strong>：主要用于<strong>批处理系统</strong></p><p><strong>抢占式优先级算法</strong>：优点： 能更好的满足<strong>紧迫作业</strong>的要求。 主要用于比较严格的<strong>实时系统</strong></p><p><strong>优先级类型</strong>：</p><p>​<strong>静态优先级</strong>：在进程创建时确定的， 在进程整个运行期间保持不变</p><p>​<strong>优先级</strong>： 利用某一范围的整数来表示， 该整数称为优先数。 如：0—7， 0—255</p><p>​<strong>确定优先级的依据</strong>：进程类型、进程对资源的需求、用户要求</p><table><thead><tr><th>算法思想</th><th>随着计算机的发展， 特别是实时操作系统的出现， 越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</th></tr></thead><tbody><tr><td>算法规则</td><td>调度时选择<strong>优先级最高</strong>的作业&#x2F;进程</td></tr><tr><td>用于作业&#x2F;进 程调度</td><td>既可用于作业调度， 也可用于进程调度。 甚至， 还会用于在之后会学习 的I&#x2F;O调度中</td></tr><tr><td>是否可抢占？</td><td><strong>抢占式、 非抢占式</strong>都有。 做题时的区别在于： 非抢占式只需在进程主动 放弃处理机时进行调度即可， 而抢占式还需在就绪队列变化时， 检查是 否会发生抢占。</td></tr><tr><td>优缺点</td><td>优点： 用优先级区分紧急程度、 重要程度， 适用于实时操作系统。 可灵 活地调整对各种作业&#x2F;进程的偏好程度。 缺点： 若源源不断地有高优先级进程到来， 则可能导致饥饿</td></tr><tr><td>是否会导致 饥饿</td><td>会</td></tr></tbody></table><h3 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h3><h3 id="多级反馈队列调度算法Multileved-Feedback-Queue"><a href="#多级反馈队列调度算法Multileved-Feedback-Queue" class="headerlink" title="多级反馈队列调度算法Multileved Feedback Queue"></a>多级反馈队列调度算法Multileved Feedback Queue</h3><table><thead><tr><th>算法思想</th><th>对其他调度算法的折中权衡</th></tr></thead><tbody><tr><td>算法规则</td><td>1. 设置多级就绪队列， 各级队列优先级从高到低， 时间片从小到大 <br />2. 新进程到达时先进入第1级队列， 按FCFS原则排队等待被分配时间片若用完时间片进程还未结束， 则进程进入下一级队列队尾。 如果此时已经是在最下级的队列， 则重新放回该队列队尾 <br />3. 只有第 k 级队列为空时， 才会为 k+1 级队头的进程分配时间片</td></tr><tr><td>用于作业&#x2F;进程调度</td><td>用于进程调度</td></tr><tr><td>是否可抢占？</td><td><strong>抢占式</strong>的算法。 新进程可抢占低级进程的处理机</td></tr><tr><td>优缺点</td><td>对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点）</td></tr><tr><td>是否会导致饥饿</td><td>会</td></tr></tbody></table><img src="../images/操作系统.assets/image-20211122204803811.png" alt="image-20211122204803811" style="zoom:50%;" /><h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3><h1 id="3-4-实时调度"><a href="#3-4-实时调度" class="headerlink" title="3.4 实时调度"></a>3.4 实时调度</h1><p>最早截止时间优先算法Earliest Deadline First, EDF</p><p>最低松弛度优先算法Least Laxity First, LLF</p><p>优先级倒置问题优先级继承</p><h1 id="3-5-死锁概述"><a href="#3-5-死锁概述" class="headerlink" title="3.5 死锁概述"></a>3.5 死锁概述</h1><h2 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h2><p>一组进程死锁指：进程所等待的事件是该组中其他进程释放所占有的资源</p><img src="../images/操作系统.assets/image-20211122205032791.png" alt="image-20211122205032791" style="zoom:50%;" /><h2 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h2><p>竞争不可抢占资源</p><p>竞争可消耗性资源</p><p>进程推进顺序不当：进程异步性特征</p><h2 id="处理死锁的必要条件"><a href="#处理死锁的必要条件" class="headerlink" title="处理死锁的必要条件"></a>处理死锁的必要条件</h2><p>互斥：只有对必须互斥使用的资源的争抢才会导致死锁</p><p>请求和保持：进程已经保持了至少一个资源， 但又提出了新的资源请求， 而该资源又被其他进程占有， 此时请求进程被阻塞， 但又对自己已有的资源保持不放</p><p>不可抢占：进程所获得的资源在未使用完之前， 不能由其他进程强行夺走， 只能主动释放。</p><p>循环等待&#x2F;环路等待：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。<br>    注意！ 发生死锁时一定有循环等待， 但是发生循环等待时未必死锁  </p><h2 id="处理死锁的方法"><a href="#处理死锁的方法" class="headerlink" title="处理死锁的方法"></a>处理死锁的方法</h2><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><h4 id="互斥条件是由设备固有条件所决定的，应加以保证，不可破坏"><a href="#互斥条件是由设备固有条件所决定的，应加以保证，不可破坏" class="headerlink" title="互斥条件是由设备固有条件所决定的，应加以保证，不可破坏"></a>互斥条件是由设备<strong>固有条件</strong>所决定的，应加以保证，不可破坏</h4><h4 id="破坏“请求和保持”"><a href="#破坏“请求和保持”" class="headerlink" title="破坏“请求和保持”"></a>破坏“请求和保持”</h4><p>第一种协议： 即进程在运行前一次申请完它所需要的全部资源， 在它的资源未满足前， 不让它投入运行。 一旦投入运行后， 这些资源就一直归它所有， 该进程就不会再请求别的任何资源了。</p><p>优点： 算法简单、 易于实现且很安全。 缺点： 资源浪费严重和进程延容易</p><p>第二种协议： 允许进程只获得运行初期所需的资源， 便开始运行。 运行过程中再逐步释放已分配给自己的资源及已用毕的资源， 然后再请求新的资源。</p><p>优点： 提高设备利用率， 减少进程发生饥饿的概率。  </p><h4 id="破坏“不可抢占”"><a href="#破坏“不可抢占”" class="headerlink" title="破坏“不可抢占”"></a>破坏“不可抢占”</h4><p>破坏不可抢占条件： 当某个进程请求新的资源得不到满足时， 它必须立即释放保持的所有资源， 待以后需要时再重新申请。  </p><p>缺点：</p><ol><li>实现起来比较复杂。</li><li>释放已获得的资源可能造成前一阶段工作的<strong>失效</strong>。 因此这种方法一般只适用于易保存和恢复状态的资源， 如CPU。</li><li>反复地申请和释放资源会<strong>增加系统开销</strong>， 降低<strong>系统吞吐量</strong>。</li><li>意味着只要暂时得不到某个资源， 之前获得的那些资源就都需要放弃， 以后再重新申请。 如果一直发生这样的情况， 就会导致进程<strong>饥饿</strong>。</li></ol><h4 id="破坏“循环等待”"><a href="#破坏“循环等待”" class="headerlink" title="破坏“循环等待”"></a>破坏“循环等待”</h4><p>顺序资源分配法  </p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>安全状态</p><p>银行家算法</p><h3 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h3><p>资源分配图，能完全简化则无死锁</p><h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><p>以最小代价终止进程，解除死锁</p><p>剥夺资源、撤销进程</p><h1 id="第4章-存储器管理"><a href="#第4章-存储器管理" class="headerlink" title="第4章 存储器管理"></a>第4章 存储器管理</h1><h2 id="4-1-存储器的层次结构"><a href="#4-1-存储器的层次结构" class="headerlink" title="4.1 存储器的层次结构"></a>4.1 存储器的层次结构</h2><h3 id="4-1-1-多级存储器结构"><a href="#4-1-1-多级存储器结构" class="headerlink" title="4.1.1 多级存储器结构"></a>4.1.1 多级存储器结构</h3><p>存储层次至少应有三级：<strong>CPU寄存器</strong>、<strong>主存</strong>、<strong>辅存</strong></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211203081235616.png" alt="image-20211203081235616"></p><h3 id="4-1-2-主存储器与寄存器（可执行存储器）"><a href="#4-1-2-主存储器与寄存器（可执行存储器）" class="headerlink" title="4.1.2 主存储器与寄存器（可执行存储器）"></a>4.1.2 主存储器与寄存器（可执行存储器）</h3><ol><li>主存储器</li></ol><p>​CPU可从其中取指令和数据，数据能从主存读取并装入到寄存器中，或从寄存器存入到主存。用于保存进程运行时的程序和数据。</p><ol start="2"><li>寄存器</li></ol><p>​寄存器访问速度最快，与处理机相同。其长度以字为单位。</p><h3 id="4-1-3-高速缓存和磁盘缓存"><a href="#4-1-3-高速缓存和磁盘缓存" class="headerlink" title="4.1.3 高速缓存和磁盘缓存"></a>4.1.3 高速缓存和磁盘缓存</h3><ol><li>高速缓存（cache)</li></ol><p>​容量大于寄存器，访问速度快于内存。</p><p>​Cache分类：</p><p>​一级cache紧靠内存，速度最高，容量最小。</p><p>​二级cache容量稍大，速度也稍低。</p><ol start="2"><li>磁盘缓存</li></ol><p>​目的：为了缓和磁盘的I&#x2F;O速度和主存的访问速度的不匹配，暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数</p><p>​磁盘缓存本身并不是一种实际存储介质。</p><p>​实质：利用主存中的存储空间，来暂存从磁盘中读出或写入的信息</p><h2 id="4-2-程序的装入和链接"><a href="#4-2-程序的装入和链接" class="headerlink" title="4.2 程序的装入和链接"></a>4.2 程序的装入和链接</h2><p>用户程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可以执行的程序，通常要经过以下几个步骤：编译、链接、装入</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211203084447428.png" alt="image-20211203084447428"></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211203090827395.png" alt="image-20211203090827395"></p><p><strong>物理地址</strong>：物理内存的地址，内存以字节为单位编址，物理地址空间是所有物理地址的集合</p><p><strong>逻辑地址（虚拟地址）</strong>：程序编译后使用的相对于0字节的地址。逻辑地址空间是由程序锁生成的所有逻辑地址的集合</p><p>用大白话说：符号地址是用户视图，物理地址是计算机视图，逻辑地址是其中的转换视图</p><h3 id="4-2-1-程序的装入"><a href="#4-2-1-程序的装入" class="headerlink" title="4.2.1 程序的装入"></a>4.2.1 程序的装入</h3><h4 id="1-绝对装入方式"><a href="#1-绝对装入方式" class="headerlink" title="1. 绝对装入方式"></a>1. 绝对装入方式</h4><p>编译时产生的地址使用绝对地址</p><p>程序或数据被修改时，需要重新编译程序</p><p>只适用于单道程序环境</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220301115758934.png" alt="image-20220301115758934"></p><h4 id="2-可重定位装入方式"><a href="#2-可重定位装入方式" class="headerlink" title="2. 可重定位装入方式"></a>2. 可重定位装入方式</h4><p>编译后的目标模块使用相对地址</p><p>在装入时，完成重定位（<strong>静态重定位</strong>）</p><p>需硬件支持</p><p><strong>重定位</strong>：逻辑地址转换为物理地址的过程，称为重定位，也称为地址变换</p><p>可重定位装入的特点是在一个作业装入内存时， 必须分配其要求的全部内存空间， 如果没有足够的内存， 就不能装入该作业。 作业一旦进入内存后， 在运行期间就不能再移动， 也不能再申请内存空间  </p><h4 id="3-动态运行时的装入方式"><a href="#3-动态运行时的装入方式" class="headerlink" title="3. 动态运行时的装入方式"></a>3. 动态运行时的装入方式</h4><p>编译后的目标模块使用相对地址</p><p>在运行时，完成重定位（动态重定位）</p><p>需要<strong>重定位寄存器</strong></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211203093413322.png" alt="image-20211203093413322"></p><p>编译： 由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言）</p><p>链接： 由链接程序将编译后形成的一组目标模块， 以及所需库函数链接在一起， 形成一个完整的装入模块</p><p>装入（装载） ： 由装入程序将装入模块装入内存运行  </p><h3 id="4-2-2-程序的链接"><a href="#4-2-2-程序的链接" class="headerlink" title="4.2.2 程序的链接"></a>4.2.2 程序的链接</h3><p>源程序经过编译后，可得到一组目标模块。链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块。</p><p>具体工作：对相对地址修改；变换外部调用符号</p><h4 id="1-静态链接方式"><a href="#1-静态链接方式" class="headerlink" title="1. 静态链接方式"></a>1. 静态链接方式</h4><p>在程序运行前，将各目标模块及它们所需的库函数链接成一个完整的模块，以后不再拆开</p><p>对相对地址进行修改；变换外部调用符号</p><h4 id="2-装入时动态链接"><a href="#2-装入时动态链接" class="headerlink" title="2. 装入时动态链接"></a>2. 装入时动态链接</h4><p>在装入内存时，采用边装入边链接的链接方式</p><p>便于修改和更新</p><p>便于实现对目标模块的共享</p><h4 id="3-运行时动态链接"><a href="#3-运行时动态链接" class="headerlink" title="3. 运行时动态链接"></a>3. 运行时动态链接</h4><p>将某些模块的链接推迟到执行时才执行。即在执行过程中，若发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将它装入内存，并把它链接到调用者模块上。</p><p>加快装入过程，节省大量内存空间，便于实现对目标模块的共享</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220301121121112.png" alt="image-20220301121121112"></p><h2 id="4-3-连续分配存储管理方式"><a href="#4-3-连续分配存储管理方式" class="headerlink" title="4.3 连续分配存储管理方式"></a>4.3 连续分配存储管理方式</h2><p>为用户程序分配一个连续的内存空间，曾被广泛应用，且现在仍被采用。</p><h3 id="4-3-1-单一连续分配"><a href="#4-3-1-单一连续分配" class="headerlink" title="4.3.1 单一连续分配"></a>4.3.1 单一连续分配</h3><p>在单道程序环境下，仅装有一道用户程序，即整个内存的用户空间由该程序独占</p><p>优点： 实现简单； 无外部碎片； 可以采用覆盖技术扩充内存； 不一定需要采取内存保护（ eg： 早期的 PC 操作系统MS-DOS）。<br>缺点： 只能用于单用户、 单任务的操作系统中； 有内部碎片； 存储器利用率极低。</p><h3 id="4-3-2-固定分区分配"><a href="#4-3-2-固定分区分配" class="headerlink" title="4.3.2 固定分区分配"></a>4.3.2 固定分区分配</h3><p>预先把可分配的主存空间分割成若干个连续的区域，称为一个分区</p><p><strong>划分分区的方法</strong>：分区大小一样、分区大小不等</p><p><strong>内存分配管理</strong>：</p><p>​将分区按大小排队，一般由小到大</p><p>​建立分区使用表——起址、大小、状态</p><p>​程序装入时，由内存分配程序检索<strong>分区使用表</strong>，找到符合要求的分区，并进行标记。</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211205152438930.png" alt="image-20211205152438930"></p><p>分区大小相等： 缺乏灵活性， 但是很适合用于用一台计算机控制多个相同对象的场合（ 比如： 钢铁厂有n个相 同的炼钢炉， 就可把内存分为n个大小相等的区域存放 n个炼钢炉控制程序）</p><p>分区大小不等： 增加了灵活性， 可以满足不同大小的进程需求。 根据常在系统中运行的作业大小情况进行划分 （比如： 划分多个小分区、 适量中等分区、 少量大分区）  </p><p>优点： 实现简单。<br>缺点： a. 当用户程序太大时， 可能所有的分区都不能满足需求；<br>b. 会产生内部碎片， 内存利用率低  </p><h3 id="4-3-3-动态分区分配"><a href="#4-3-3-动态分区分配" class="headerlink" title="4.3.3 动态分区分配"></a>4.3.3 动态分区分配</h3><p>根据进程的实际需要，动态地分配内存空间</p><h4 id="1-动态分区分配中的数据结构"><a href="#1-动态分区分配中的数据结构" class="headerlink" title="1. 动态分区分配中的数据结构"></a>1. 动态分区分配中的数据结构</h4><p>空闲分区表：每个空闲分区占一个表目，表目中包括分区号、分区大小和分区始址等数据项</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211205155320206.png" alt="image-20211205155320206"></p><p>空闲分区链：双向链表</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211205155659713.png" alt="image-20211205155659713"></p><h4 id="2-动态分区分配算法"><a href="#2-动态分区分配算法" class="headerlink" title="2. 动态分区分配算法"></a>2. 动态分区分配算法</h4><p>4.3.4 - 4.3.5</p><h4 id="3-分区分配操作"><a href="#3-分区分配操作" class="headerlink" title="3. 分区分配操作"></a>3. 分区分配操作</h4><p><strong>分配内存</strong></p><p>从空闲分区链（表）中找到所需大小的分区。</p><p>设请求的分区大小为u.size，表中每个空闲分区的大小为m.size，规定的不再切割的分区大小为size</p><p>判断条件：M.Size - U.Size ≦ Size</p><p>剩余部分挂接到空闲分区链（表）上。</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211205183339657.png" alt="image-20211205183339657"></p><p><strong>回收内存</strong></p><p>回收区与插入点的前一个空闲分区相邻接</p><p>回收区与插入点的后一个空闲分区相邻接</p><p>回收区与插入点的前后两个空闲分区相邻接</p><p>回收区不与任何一个空闲分区相邻接</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211205183408673.png" alt="image-20211205183408673"></p><h3 id="4-3-4-基于顺序搜索的动态分区分配算法"><a href="#4-3-4-基于顺序搜索的动态分区分配算法" class="headerlink" title="4.3.4 基于顺序搜索的动态分区分配算法"></a>4.3.4 基于顺序搜索的动态分区分配算法</h3><p><strong>首次适应算法（First Fit, FF）</strong>：</p><p>  空闲分区按起址递增次序排列，从头开始直至找到第一个满足要求的空闲分区。</p><p>  特点：内存低端会留下小的空闲区，高端有大的空闲区</p><p><strong>循环首次适应算法（Next Fit, NF）</strong>：</p><p>  从上次分配的位置之后开始查找。</p><p>  特点：使内存的空闲分区均匀，但缺乏大的空闲分区</p><p><strong>最佳适应算法（Best Fit, BF）</strong>：</p><p>  搜索整个序列，找到适合条件的最小的分区进行分配</p><p>  空闲分区按其容量从小到大的顺序链接</p><p>  用最小空间满足要求，但缺点明显会留下大量难以利用的小碎片。</p><p><strong>最坏适应算法（Worst Fit, WF）</strong>：</p><p>  与BF正好相反，空闲分区按大小从大到小的次序排列，最前面的最大的空闲分区就是找到的分区。</p><p>  优点：分割后空闲块仍为较大空块</p><p>  缺点：一段时间后就不能满足对于较大空闲区的分配要求。</p><h3 id="4-3-5-基于索引搜索的动态分区分配算法"><a href="#4-3-5-基于索引搜索的动态分区分配算法" class="headerlink" title="4.3.5 基于索引搜索的动态分区分配算法"></a>4.3.5 基于索引搜索的动态分区分配算法</h3><p><strong>快速适应算法（Quick Fit）</strong>：</p><p>  空闲分区按容量大小进行分类。</p><p>  优点是查找效率高， 仅需要根据进程的长度， 寻找到能容纳它的最小空闲区链表， 并取下第一块进行分配即可。 在进行空闲分区分配时，不会对任何分区产生分割， 所以能保留大的分区， 满足对大空间的需求， 也不会产生内存碎片。  </p><p>  对于每一类具有相同容量的所有空闲空间分区，单独设立一个空闲分区链表。</p><p>  在内存中设立一张管理索引表，每个表项对应一种空闲分区类型。</p><p>  优点：不分割分区，不产生碎片，查找效率高</p><p>  缺点：分区归还主存时算法复杂。一个进程占用一个分区，存在浪费</p><p><strong>伙伴系统（Bubby system）</strong>：</p><p>分区（已分配和空闲）大小均为2的k次幂（1&lt;&#x3D;k&lt;&#x3D;m), $2^m$为可分配内存大小。</p><p>对不连续的空闲分区，按分区大小进行分类。对具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表，即会存在k个空闲分区链表。</p><p>分配时，设需分配长度为n，找$2^i$分区链的分区，使$2^{i-1}&lt;n&lt;2^i$，若无，找$2^{i+1}$且把它均分两块，称为伙伴。一个加入$2^i$分区链，一个分配；…….</p><p>回收时，若已存在$2^i$空闲分区，则将其于伙伴合并为$2^{i+1}$分区，…..</p><p>特点：性能取决于查找空闲分区的位置和分割、合并的时间。 时间上不及快速适应算法，但空闲分区的使用率高</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211205184852165.png" alt="image-20211205184852165"></p><p><strong>哈希算法</strong>：</p><p>利用哈希快速查找的优点，以及空闲分区在可利用空闲区表中的分布规律，建立哈希函数。</p><p>构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表。</p><p>分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，找到对应的空闲分区表。</p><p>优点：查找快速</p><h3 id="4-3-6-可重定位分区分配"><a href="#4-3-6-可重定位分区分配" class="headerlink" title="4.3.6 可重定位分区分配"></a>4.3.6 可重定位分区分配</h3><p>随着系统接收的作业的增加，内存中连续的大块分区不复存在，产生了大量的“碎片”。</p><p>新的作业无法装入到每个“碎片”小分区上运行，但所有碎片的空间总和可能大于需求。</p><p>紧凑：通过移动内存中进程位置，一把原来多个分散的小分区拼接成一个大分区的方法，也叫作 “拼接”。</p><p>动态重定位：在指令运行时，实现地址转换（从相对地址转换为绝对地址）</p><p>分配算法：类似于动态分区分配，增加了紧凑的功能。</p><p>缺点： 用户程序在内存中的地址发生变化， 必须重定位。</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220301130416316.png" alt="image-20220301130416316"></p><h2 id="4-4-对换"><a href="#4-4-对换" class="headerlink" title="4.4 对换"></a>4.4 对换</h2><p>定义：把内存中暂时不能运行的进程或者暂时不用的程序和数据换出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据换入内存</p><p>目的：用于解决内存不足的问题，提高内存利用率，目前广泛应用于OS中。</p><p>实现进程对换， 系统必须具备的功能： 对换空间的管理、 进程的换出、 进程的换入</p><p><strong>对换的类型</strong></p><p>​整体对换（中级调度）：以进程为单位的对换</p><p>​部分对换（页面替换算法）：以“页”或“段”为单位的对换</p><p><strong>对换空间的管理</strong></p><p>外存的划分：文件区、对换区</p><p>​文件区管理目标：首先是提高文件存储空间利用率，然后才是提高文件的访问速度，采用离散分配方式</p><p>​对换区管理目标：首先是提高进程换入和换出的速度，然后才是提高文件存储空间的利用率，采取连续分配方式，较少考虑外存中的碎片问题</p><p>管理方式：空闲分区表、空闲分区链</p><p>分配算法：首次适应法、循环首次适应法、最佳适应法</p><p><strong>进程的换出与换入</strong></p><p>进程的换出</p><p>​选择处于阻塞或睡眠状态且优先级最低的进程</p><p>​将该进程的程序和数据传送到磁盘的对换区上</p><p>​回收内存空间，修改该进程的PCB</p><p>进程的换入</p><p>​定时查看进程状态</p><p>​将处于就绪态的，换出时间最久的进程换入内存</p><h2 id="4-5-分页存储管理方式"><a href="#4-5-分页存储管理方式" class="headerlink" title="4.5 分页存储管理方式"></a>4.5 分页存储管理方式</h2><p>离散分配方式：分页存储管理方式、分段存储管理方式、段页式存储管理方式</p><h3 id="4-5-1-分页存储管理的基本方法"><a href="#4-5-1-分页存储管理的基本方法" class="headerlink" title="4.5.1 分页存储管理的基本方法"></a>4.5.1 分页存储管理的基本方法</h3><p>页面：分页存储管理将进程的逻辑地址空间分成若干个页</p><p><strong>地址结构</strong>：<img src="../images/操作系统.assets/image-20211206083810275.png" alt="image-20211206083810275" style="zoom:50%;" /></p><p>图中的地址长度为32位，其中0<del>11位为页内地址，即每页的大小为4KB，12</del>31位为页号，地址空间最多允许有1M页</p><p>对于特定机器，地址结构一定，给定一个逻辑地址空间中的地址为A，页面的大小为L，页号P和页内地址d可按下式求得：<img src="../images/操作系统.assets/image-20211206084142281.png" alt="image-20211206084142281" style="zoom:50%;" /></p><p>其中，INT是整除函数，MOD是取余函数</p><p><strong>页表</strong>：实现从页号到物理块号的地址映射</p><h3 id="4-5-2-地址变换机构"><a href="#4-5-2-地址变换机构" class="headerlink" title="4.5.2 地址变换机构"></a>4.5.2 地址变换机构</h3><p>将用户地址空间中的逻辑地址转换为内存空间中的物理地址</p><p>借助<strong>页表</strong>实现</p><p><strong>基本的地址变换机构</strong>：设置页表寄存器PTR</p><p>二次访问内存，第一次访问页表，第二次访问真实物理地址</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211206091927662.png" alt="image-20211206091927662"></p><p><strong>快表</strong>：又称为联想寄存器，效果类似于cache</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211206092221266.png" alt="image-20211206092221266"></p><h3 id="4-5-3-访问内存的有效时间"><a href="#4-5-3-访问内存的有效时间" class="headerlink" title="4.5.3 访问内存的有效时间"></a>4.5.3 访问内存的有效时间</h3><p>从进程发出指定逻辑地址的访问请求，经过地址变换，到在内存中找到的实际地址单元并取出数据，所需要花费的总时间，称为内存的有效访问时间EAT。</p><p>假设访问依次内存的时间为t，</p><p>​在基本分页存储管理方式中：$EAT&#x3D;t+t&#x3D;2t$</p><p>​在引入快表的分页存储管理方式中：$EAT&#x3D;a<em>\lambda + (t+\lambda)(1-a)+t&#x3D;2t+\lambda-t</em>a$</p><p>​其中，$\lambda$表示查找快表所需要的时间，a为命中率，t表示访问一次内存所需要的时间</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211206093114190.png" alt="image-20211206093114190"></p><h3 id="4-5-4-两级和多级页表"><a href="#4-5-4-两级和多级页表" class="headerlink" title="4.5.4 两级和多级页表"></a>4.5.4 两级和多级页表</h3><p>解决页表过大且连续的问题：</p><pre><code> 1. 对于页表所需的内存空间，可采用离散分配方式，以解决难以找到一块连续的大内存空间的问题 2. 只将当前需要的部分页表项调入内存，其余的页表仍驻留在磁盘上，需要时再调入</code></pre><h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h4><p>将页表分页，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，然后离散地将各个页面分别存放再不同物理块中 ，并再建立一张页表，称为<strong>外层页表</strong></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211206093813352.png" alt="image-20211206093813352"></p><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>多用于64位计算机</p><h3 id="4-5-5-反置页表"><a href="#4-5-5-反置页表" class="headerlink" title="4.5.5 反置页表"></a>4.5.5 反置页表</h3><p>一般页表记录一个进程的逻辑地址，每个进程都有一份，反置页表记录物理块号，只有一份，大大减少空间占用</p><p>可利用Hash算法进行检索</p><h2 id="4-6-分段存储管理方式"><a href="#4-6-分段存储管理方式" class="headerlink" title="4.6 分段存储管理方式"></a>4.6 分段存储管理方式</h2><p>引入分段存储管理方式的目的：满足用户（程序员）在编程和使用上多方面的需求</p><h3 id="4-6-1-分段存储管理方式的引入"><a href="#4-6-1-分段存储管理方式的引入" class="headerlink" title="4.6.1 分段存储管理方式的引入"></a>4.6.1 分段存储管理方式的引入</h3><p>方便编程</p><p>信息共享</p><p>信息保护</p><p>动态增长</p><p>动态链接</p><h3 id="4-6-2-分段系统的基本原理"><a href="#4-6-2-分段系统的基本原理" class="headerlink" title="4.6.2 分段系统的基本原理"></a>4.6.2 分段系统的基本原理</h3><h4 id="1-分段"><a href="#1-分段" class="headerlink" title="1. 分段"></a>1. 分段</h4><p>分段地址的结构：</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211213084509517.png" alt="image-20211213084509517"></p><h4 id="2-段表"><a href="#2-段表" class="headerlink" title="2. 段表"></a>2. 段表</h4><p>从物理内存中找到每个逻辑段对应的位置</p><p>用于实现从逻辑段到物理内存的映射</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211213084909837.png" alt="image-20211213084909837"></p><h4 id="3-地址变换机构"><a href="#3-地址变换机构" class="headerlink" title="3. 地址变换机构"></a>3. 地址变换机构</h4><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211213090104238.png" alt="image-20211213090104238"></p><p>段式存储方式和页式存储方式访问一次数据都须访问两次内存，成倍降低计算机速率， 解决方法：增设联想存储器</p><h4 id="4-分页和分段的主要区别"><a href="#4-分页和分段的主要区别" class="headerlink" title="4. 分页和分段的主要区别"></a>4. 分页和分段的主要区别</h4><p>页是信息的物理单位</p><p>页的大小固定且有系统决定</p><p>分页的用户程序地址空间是一维的</p><h3 id="4-6-3-信息共享"><a href="#4-6-3-信息共享" class="headerlink" title="4.6.3 信息共享"></a>4.6.3 信息共享</h3><h4 id="1-分页系统中对程序和数据的共享"><a href="#1-分页系统中对程序和数据的共享" class="headerlink" title="1. 分页系统中对程序和数据的共享"></a>1. 分页系统中对程序和数据的共享</h4><h4 id="2-分段系统中程序和数据的共享"><a href="#2-分段系统中程序和数据的共享" class="headerlink" title="2. 分段系统中程序和数据的共享"></a>2. 分段系统中程序和数据的共享</h4><h3 id="4-6-4-段页式存储管理方式"><a href="#4-6-4-段页式存储管理方式" class="headerlink" title="4.6.4 段页式存储管理方式"></a>4.6.4 段页式存储管理方式</h3><p>优点：便于实现、分段可共享、易于保护、可动态链接、便于解决外部碎片</p><h4 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h4><p>先将用户程序分成若干个段，再把每个段分成若干个页</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211213091334288.png" alt="image-20211213091334288"></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211213091434136.png" alt="image-20211213091434136"></p><h4 id="2-地址变换过程"><a href="#2-地址变换过程" class="headerlink" title="2. 地址变换过程"></a>2. 地址变换过程</h4><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211213091456176.png" alt="image-20211213091456176"></p><p>需三次访问内存，需要增加高速缓冲寄存器</p><h2 id="第四章复习"><a href="#第四章复习" class="headerlink" title="第四章复习"></a>第四章复习</h2><p>4.2 程序的装入和链接</p><h1 id="第5章-虚拟存储器"><a href="#第5章-虚拟存储器" class="headerlink" title="第5章 虚拟存储器"></a>第5章 虚拟存储器</h1><h2 id="5-1-虚拟存储器概述"><a href="#5-1-虚拟存储器概述" class="headerlink" title="5.1 虚拟存储器概述"></a>5.1 虚拟存储器概述</h2><p>虚拟存储器解决的问题：</p><ol><li>作业过大，所需内存空间超过内存总容量</li><li>大量作业要求运行，内存容量不足</li></ol><p>解决思路：从逻辑上扩充内存容量</p><h3 id="5-1-1-常规存储管理方式的特征和局部性原理"><a href="#5-1-1-常规存储管理方式的特征和局部性原理" class="headerlink" title="5.1.1 常规存储管理方式的特征和局部性原理"></a>5.1.1 常规存储管理方式的特征和局部性原理</h3><h4 id="1-常规存储器管理方式的特征"><a href="#1-常规存储器管理方式的特征" class="headerlink" title="1. 常规存储器管理方式的特征"></a>1. 常规存储器管理方式的特征</h4><p>一次性</p><p>驻留性</p><h4 id="2-局部性原理"><a href="#2-局部性原理" class="headerlink" title="2. 局部性原理"></a>2. 局部性原理</h4><ol><li>程序执行时，除了少部分的转移和过程调用指令外，在大多数情况下时顺序执行的</li><li>过程调用将会使程序的执行轨迹由一部分区域转移至另一部分区域</li><li>程序中存在许多循环结构，这些结构虽然只由少数指令构成，但是它们被多次执行</li><li>程序中还包括许多对数据结构的处理，如对数组进行操作，这些处理往往都局限于很小的范围内</li></ol><p>局限性又表现在下述两个方面：</p><ol><li>时间局限性</li><li>空间局限性</li></ol><h4 id="3-虚拟存储器的基本工作情况"><a href="#3-虚拟存储器的基本工作情况" class="headerlink" title="3. 虚拟存储器的基本工作情况"></a>3. 虚拟存储器的基本工作情况</h4><p>缺页中断：调入缺页</p><p>置换功能：调出暂时不用的页（段）</p><h3 id="5-1-2-虚拟存储器的定义和特征"><a href="#5-1-2-虚拟存储器的定义和特征" class="headerlink" title="5.1.2 虚拟存储器的定义和特征"></a>5.1.2 虚拟存储器的定义和特征</h3><h4 id="1-虚拟存储器的定义"><a href="#1-虚拟存储器的定义" class="headerlink" title="1. 虚拟存储器的定义"></a>1. 虚拟存储器的定义</h4><p>具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</p><p>逻辑容量由内存容量和外存容量之和所决定</p><h4 id="2-虚拟存储器的特征"><a href="#2-虚拟存储器的特征" class="headerlink" title="2. 虚拟存储器的特征"></a>2. 虚拟存储器的特征</h4><p>多次性</p><p>对换性</p><p>虚拟性</p><p>虚拟性是以多次性和对换性为基础；多次性和对换性必须建立在离散分配的基础上</p><h3 id="5-1-3-虚拟存储器的实现方法"><a href="#5-1-3-虚拟存储器的实现方法" class="headerlink" title="5.1.3 虚拟存储器的实现方法"></a>5.1.3 虚拟存储器的实现方法</h3><p>建立在离散分配存储管理方式的基础上</p><h4 id="1-分页请求系统"><a href="#1-分页请求系统" class="headerlink" title="1. 分页请求系统"></a>1. 分页请求系统</h4><p>在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统</p><p><strong>硬件支持</strong>：</p><ol><li>请求分页的页表机制</li><li>缺页中断机构</li><li>地址变换机构</li></ol><p><strong>实现请求分页的软件</strong>：包括所有用于实现请求调页的软件和实现页面置换的软件</p><h4 id="2-请求分段系统"><a href="#2-请求分段系统" class="headerlink" title="2. 请求分段系统"></a>2. 请求分段系统</h4><p>在分段系统的基础上增加了请求掉段及分段置换功能所形成的段式虚拟存储系统</p><p><strong>硬件支持</strong>：</p><ol><li>请求分段的段表机制</li><li>缺页中断机构</li><li>地址变换机构</li></ol><p><strong>软件支持</strong>：包括所有用于实现请求调段的软件和实现段置换的软件</p><h2 id="5-2-请求分页存储管理方式"><a href="#5-2-请求分页存储管理方式" class="headerlink" title="5.2 请求分页存储管理方式"></a>5.2 请求分页存储管理方式</h2><h3 id="5-2-1-请求分页中的硬件支持"><a href="#5-2-1-请求分页中的硬件支持" class="headerlink" title="5.2.1 请求分页中的硬件支持"></a>5.2.1 请求分页中的硬件支持</h3><h4 id="1-请求页表机制"><a href="#1-请求页表机制" class="headerlink" title="1. 请求页表机制"></a>1. 请求页表机制</h4><p>请求页表：将用户地址空间中的逻辑地址映射为内存空间中的物理地址</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220080751563.png" alt="image-20211220080751563"></p><p>状态位（存在位）P：用于指示该页是否已调入内存</p><p>访问字段A：用于记录本页在一段时间内被访问的次数</p><p>修改位M：标识该页是否被修改过</p><p>外存地址：指出该页在外存上的地址</p><h4 id="2-缺页中断机构"><a href="#2-缺页中断机构" class="headerlink" title="2. 缺页中断机构"></a>2. 缺页中断机构</h4><p>缺页中断是一种特殊的中断，表现在：</p><ol><li>CPU通常是在一条指令执行完后才检查是否有中断请求到达，而缺页中断是在指令执行期间产生和处理中断信号</li><li>一条指令在执行期间可能产生多次缺页中断</li></ol><h4 id="3-地址变换机构-1"><a href="#3-地址变换机构-1" class="headerlink" title="3. 地址变换机构"></a>3. 地址变换机构</h4><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220081644587.png" alt="image-20211220081644587"></p><h3 id="5-2-2-请求分页中的内存分配"><a href="#5-2-2-请求分页中的内存分配" class="headerlink" title="5.2.2 请求分页中的内存分配"></a>5.2.2 请求分页中的内存分配</h3><h4 id="1-最小物理块数的确定"><a href="#1-最小物理块数的确定" class="headerlink" title="1. 最小物理块数的确定"></a>1. 最小物理块数的确定</h4><p>最小物理块数是指能保证进程正常运行所需的最小物理块数。低于这个数量，进程将无法运行。</p><h4 id="2-内存分配策略"><a href="#2-内存分配策略" class="headerlink" title="2.  内存分配策略"></a>2.  内存分配策略</h4><p>固定分配：为每个进程分配一组固定的物理块</p><p>可变分配：为每个进程分配一定的物理块，运行期间可适当增减</p><p>局部置换：进程在运行中发现缺页，只能从分配给该进程的n个页面中选出一页换出，然后再调入一页</p><p>全局置换：缺页时，在OS所保留的全部空闲物理块中选择一块调出</p><ol><li><p>固定分配局部置换</p><p>实现困难：应为每个进程分配多少个物理块难以确认</p></li><li><p>可变分配全局置换</p></li><li><p>可变分配局部置换</p></li></ol><h4 id="3-物理块分配算法"><a href="#3-物理块分配算法" class="headerlink" title="3. 物理块分配算法"></a>3. 物理块分配算法</h4><ol><li><p>平均分配算法</p></li><li><p>按比例分配算法</p><p>系统中共有n个进程，每个进程的页面数为$S_i$，则系统中各进程页面数的总和为：$S&#x3D;\sum^n_{i&#x3D;1}S_i$，又假定系统中可用的物理块总数为m，则每个进程所能分到的物理块数为$b_i$，则$b_i&#x3D;\frac{S_i}{S}*m$，这里，$b_i$应该取整且大于最小物理块数</p></li><li><p>考虑优先权的分配算法</p></li></ol><h3 id="5-2-3-页面调入策略"><a href="#5-2-3-页面调入策略" class="headerlink" title="5.2.3 页面调入策略"></a>5.2.3 页面调入策略</h3><h4 id="1-何时调入页面"><a href="#1-何时调入页面" class="headerlink" title="1. 何时调入页面"></a>1. 何时调入页面</h4><p>确定系统将进程运行时所缺的页面调入内存的时机</p><ol><li>预调页策略：将那些预计在不久之后便会被访问的页面预先调入内存</li><li>请求调页策略：发现缺页便提出请求，开销大</li></ol><h4 id="2-从何处调入页面"><a href="#2-从何处调入页面" class="headerlink" title="2. 从何处调入页面"></a>2. 从何处调入页面</h4><ol><li>系统拥有足够的对换区空间：全部从对换区调入所需页面，提高调页速度</li><li>系统缺少足够的对换区空间：对于不会被修改的文件，在文件区调入换出；可能被修改的文件，在对换区调入换出</li><li>UNIX方式</li></ol><h4 id="3-页面调入过程"><a href="#3-页面调入过程" class="headerlink" title="3. 页面调入过程"></a>3. 页面调入过程</h4><p>对用户透明</p><h4 id="4-缺页率"><a href="#4-缺页率" class="headerlink" title="4. 缺页率"></a>4. 缺页率</h4><p>假设一个进程的逻辑空间为n页，系统为其分配的内存物理块数为m($m\leq n$)，在进程运行过程中，访问页面成功的次数为S，访问失败的次数为F，则总访问次数为$A&#x3D;S+F$，则缺页率为$f&#x3D;\frac{F}{A}$</p><p>影响缺页率的因素：</p><ol><li>页面大小</li><li>进程所分配的物理块的数目</li><li>页面置换算法</li><li>程序固有特性</li></ol><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220085538480.png" alt="image-20211220085538480"></p><h2 id="5-3-页面置换算法"><a href="#5-3-页面置换算法" class="headerlink" title="5.3 页面置换算法"></a>5.3 页面置换算法</h2><p>抖动：刚被换出的页很快又被访问，需要重新调入，选一页调出，而被换出的页又很快被访问，需要重新调入。</p><h3 id="5-3-1-最佳置换算法和先进先出置换算法"><a href="#5-3-1-最佳置换算法和先进先出置换算法" class="headerlink" title="5.3.1 最佳置换算法和先进先出置换算法"></a>5.3.1 最佳置换算法和先进先出置换算法</h3><h4 id="1-最佳（Optimal）置换算法"><a href="#1-最佳（Optimal）置换算法" class="headerlink" title="1. 最佳（Optimal）置换算法"></a>1. 最佳（Optimal）置换算法</h4><p>调出未来最长时间内不再被访问的页面，理论算法，无法实现</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220090528400.png" alt="image-20211220090528400"></p><h4 id="2-先进先出（FIFO）页面置换算法"><a href="#2-先进先出（FIFO）页面置换算法" class="headerlink" title="2. 先进先出（FIFO）页面置换算法"></a>2. 先进先出（FIFO）页面置换算法</h4><p>按调入内存的页面的顺序建立队列，并设立替换指针，使它总是指向最老的页面</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220090544250.png" alt="image-20211220090544250"></p><h3 id="5-3-2-最近最久未使用和最少使用置换算法"><a href="#5-3-2-最近最久未使用和最少使用置换算法" class="headerlink" title="5.3.2 最近最久未使用和最少使用置换算法"></a>5.3.2 最近最久未使用和最少使用置换算法</h3><h4 id="1-LRU（Least-Recently-Used）置换算法"><a href="#1-LRU（Least-Recently-Used）置换算法" class="headerlink" title="1. LRU（Least Recently Used）置换算法"></a>1. LRU（Least Recently Used）置换算法</h4><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220090811679.png" alt="image-20211220090811679"></p><h4 id="2-LRU算法的硬件支持"><a href="#2-LRU算法的硬件支持" class="headerlink" title="2. LRU算法的硬件支持"></a>2. LRU算法的硬件支持</h4><p>寄存器和栈两类硬件之一</p><ol><li>寄存器</li></ol><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220091834803.png" alt="image-20211220091834803"></p><ol start="2"><li><p>栈</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220091939899.png" alt="image-20211220091939899"></p></li></ol><h4 id="3-最少使用（Least-Frequently-Used，LFU）置换算法"><a href="#3-最少使用（Least-Frequently-Used，LFU）置换算法" class="headerlink" title="3. 最少使用（Least Frequently Used，LFU）置换算法"></a>3. 最少使用（Least Frequently Used，LFU）置换算法</h4><h3 id="5-3-3-Clock置换算法"><a href="#5-3-3-Clock置换算法" class="headerlink" title="5.3.3 Clock置换算法"></a>5.3.3 Clock置换算法</h3><h4 id="1-简单的Clock置换算法"><a href="#1-简单的Clock置换算法" class="headerlink" title="1. 简单的Clock置换算法"></a>1. 简单的Clock置换算法</h4><p>又称为最近未用算法或NRU（Not Recently Used）算法</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220092425270.png" alt="image-20211220092425270"></p><h4 id="2-改进型Clock置换算法"><a href="#2-改进型Clock置换算法" class="headerlink" title="2. 改进型Clock置换算法"></a>2. 改进型Clock置换算法</h4><p>由访问位A和修改位M可以组合成下面四种类型的页面：</p><p>​1类（A&#x3D;0，M&#x3D;0）：表示该页最近既未被访问，又未被修改，是最佳淘汰页</p><p>​2类（A&#x3D;0，M&#x3D;1）：表示该页最近未被访问，但已被修改，并不是很好的淘汰页</p><p>​3类（A&#x3D;1，M&#x3D;0）：表示该页最近已被访问，但未被修改，该页有可能再被访问</p><p>​4类（A&#x3D;1，M&#x3D;1）：表示该页最近已被访问且被修改，可能再被访问</p><p>算法步骤：</p><ol><li>从指针当前位置开始，寻找1类页面，扫描期间不改变访问位A</li><li>若第一步失败，寻找2类页面，将所有扫描过的访问位置0</li><li>若第二步失败，将所有访问位复0，指针回到开始的位置，重复1、2步操作</li></ol><h3 id="5-3-4-页面缓冲算法（Page-Buffering-Algorithm，PBA）"><a href="#5-3-4-页面缓冲算法（Page-Buffering-Algorithm，PBA）" class="headerlink" title="5.3.4 页面缓冲算法（Page Buffering Algorithm，PBA）"></a>5.3.4 页面缓冲算法（Page Buffering Algorithm，PBA）</h3><h4 id="1-影响页面换进换出效率的若干因素"><a href="#1-影响页面换进换出效率的若干因素" class="headerlink" title="1. 影响页面换进换出效率的若干因素"></a>1. 影响页面换进换出效率的若干因素</h4><ol><li>页面置换算法</li><li>写回磁盘的频率</li><li>读入内存的频率</li></ol><h4 id="2-页面缓冲算法PBA"><a href="#2-页面缓冲算法PBA" class="headerlink" title="2. 页面缓冲算法PBA"></a>2. 页面缓冲算法PBA</h4><p>PBA主要特点：1. 显著降低页面换进换出的频率，减少磁盘I&#x2F;O次数，减少换进换出的开销；2、可采用简单的置换策略，不需要硬件支持，实现简单</p><ol><li><p>空闲页面链表</p><p>进程需要读入页面时，将空闲页面链表中的第一个物理块装入该页；页面换出时，改在空闲链表末尾，当某进程再需要该也表示，在空闲链表中查找，免除磁盘读入的操作</p></li><li><p>修改页面链表</p><p>当进程需要将一个已修改的页面换出时，系统并不立即把它换出到外存上，而是将它所在的物理块改在修改页面链表的末尾，降低磁盘内容读入的频率</p></li></ol><h3 id="5-3-5-访问内存的有效时间"><a href="#5-3-5-访问内存的有效时间" class="headerlink" title="5.3.5 访问内存的有效时间"></a>5.3.5 访问内存的有效时间</h3><ol><li><p>被访问页在内存中，且其对应的页表在快表中</p><p>此时不存在缺页中断情况，内存的有效访问时间（EAT）分为查找快表的时间（$\lambda$）和访问实际物理地址所需的时间（t）<br>$$<br>EAT&#x3D;\lambda + t<br>$$</p></li><li><p>被访问页在内存中，且其所对应的页表项不在快表中</p><p>此时不存在缺页中断情况，但需要两次访问内存，一次读取页表，一次读取数据，还需要更新快表，EAT可分为：查找快表的时间、查找页表的时间、修改快表的时间、访问实际物理地址的时间<br>$$<br>EAT &#x3D; \lambda + t + \lambda + t &#x3D; 2 * (\lambda + t)<br>$$</p></li><li><p>被访问页不在内存中</p><p>分为：查找快表的时间、查找页表的时间、处理缺页中断的时间、更新快表的时间、访问实际物理地址的时间</p><p>中断处理时间$\varepsilon$</p></li></ol><p>$$<br>EAT&#x3D;\lambda + t+\varepsilon + \lambda + t&#x3D;\varepsilon +2(\lambda + t)<br>$$</p><p>考虑到命中率a和缺页率f等因素后：<br>$$<br>EAT&#x3D;\lambda + a<em>t+(1-a)</em>[t+f*(\varepsilon + \lambda+t)+(1-f)<em>(\lambda+t)]<br>$$<br>不考虑命中率，仅考虑缺页率，即上式中的$\lambda&#x3D;0$和$a&#x3D;0$，设缺页中断处理时间为$\phi$，则<br>$$<br>EAT&#x3D;t+f</em>(\phi+t)+(1-f)*t<br>$$</p><h2 id="5-4-“抖动”与工作集"><a href="#5-4-“抖动”与工作集" class="headerlink" title="5.4 “抖动”与工作集"></a>5.4 “抖动”与工作集</h2><h3 id="5-4-1-多道程序度与“抖动”"><a href="#5-4-1-多道程序度与“抖动”" class="headerlink" title="5.4.1 多道程序度与“抖动”"></a>5.4.1 多道程序度与“抖动”</h3><ol><li><p>多道程序度与处理机的利用率</p><p>横轴表示多道程序的数量，纵轴表示相应的处理机的利用率</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220103431558.png" alt="image-20211220103431558"></p></li><li><p>产生“抖动”的原因</p><p>根本原因：同时在系统中运行的进程太多，使分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，频繁缺页</p></li></ol><h3 id="5-4-2-工作集"><a href="#5-4-2-工作集" class="headerlink" title="5.4.2 工作集"></a>5.4.2 工作集</h3><p>工作集的定义：在某段时间间隔$\Delta$里，进程实际所要访问的页面的集合</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220104551788.png" alt="image-20211220104551788"></p><h3 id="5-4-3-”抖动“的预防方法"><a href="#5-4-3-”抖动“的预防方法" class="headerlink" title="5.4.3 ”抖动“的预防方法"></a>5.4.3 ”抖动“的预防方法</h3><ol><li>采取局部置换策略</li><li>把工作集算法融入到处理机调度中</li><li>利用”L&#x3D;S“准则调节缺页率</li><li>选择暂停的进程</li></ol><h2 id="5-5-请求分段存储管理方式"><a href="#5-5-请求分段存储管理方式" class="headerlink" title="5.5 请求分段存储管理方式"></a>5.5 请求分段存储管理方式</h2><h3 id="5-5-1-请求分段中的硬件支持"><a href="#5-5-1-请求分段中的硬件支持" class="headerlink" title="5.5.1 请求分段中的硬件支持"></a>5.5.1 请求分段中的硬件支持</h3><h4 id="1-请求段表机制"><a href="#1-请求段表机制" class="headerlink" title="1. 请求段表机制"></a>1. 请求段表机制</h4><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220104859558.png" alt="image-20211220104859558"></p><p>存取方式：根据该信息的属性对段进行保护（权限）</p><p>访问字段A：记录频繁访问程度</p><p>修改位M：是否被修改过</p><p>存在位P：是否已调入内存</p><p>增补位：本段在运行过程中是否做过动态增长</p><p>外存地址：指示起始地址，即起始盘块号</p><h4 id="2-缺段中断机构"><a href="#2-缺段中断机构" class="headerlink" title="2. 缺段中断机构"></a>2. 缺段中断机构</h4><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220105245219.png" alt="image-20211220105245219"></p><h4 id="3-地址变换机构-2"><a href="#3-地址变换机构-2" class="headerlink" title="3. 地址变换机构"></a>3. 地址变换机构</h4><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220105258103.png" alt="image-20211220105258103"></p><h3 id="5-5-2-分段的共享与保护"><a href="#5-5-2-分段的共享与保护" class="headerlink" title="5.5.2 分段的共享与保护"></a>5.5.2 分段的共享与保护</h3><h4 id="1-共享段表"><a href="#1-共享段表" class="headerlink" title="1. 共享段表"></a>1. 共享段表</h4><p>系统中配置共享段表，记录共享段数据</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220105600834.png" alt="image-20211220105600834"></p><p>共享进程计数count：记录有多少进程正在共享该分段</p><p>存取控制字符：对不同进程的权限控制</p><p>段号：不同进程对于同一个共享段可以有不同的段号</p><h4 id="2-共享段的分配和回收"><a href="#2-共享段的分配和回收" class="headerlink" title="2. 共享段的分配和回收"></a>2. 共享段的分配和回收</h4><ol><li>分配：</li></ol><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220110307819.png" alt="image-20211220110307819"></p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220110329951.png" alt="image-20211220110329951"></p><ol start="2"><li>回收：</li></ol><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220110346248.png" alt="image-20211220110346248"></p><h4 id="3-分段保护"><a href="#3-分段保护" class="headerlink" title="3. 分段保护"></a>3. 分段保护</h4><ol><li><p>月结检查</p></li><li><p>存取控制检查：只读、只执行、读&#x2F;写</p></li><li><p>环保护机构：</p><p>一个程序可以访问驻留在相同环或较低特权环（外环）中的数据</p><p>一个程序可以调用驻留在相同环或较高特权环（内环）中的服务</p></li></ol><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211220110121218.png" alt="image-20211220110121218"></p><h1 id="第7章-文件管理"><a href="#第7章-文件管理" class="headerlink" title="第7章 文件管理"></a>第7章 文件管理</h1><h2 id="7-1-文件和文件系统"><a href="#7-1-文件和文件系统" class="headerlink" title="7.1 文件和文件系统"></a>7.1 文件和文件系统</h2><p>基于文件系统的概念，可以把数据组成分为数据项、记录和文件三级</p><h3 id="7-1-1-数据项、记录和文件"><a href="#7-1-1-数据项、记录和文件" class="headerlink" title="7.1.1 数据项、记录和文件"></a>7.1.1 数据项、记录和文件</h3><h4 id="1-数据项"><a href="#1-数据项" class="headerlink" title="1. 数据项"></a>1. 数据项</h4><p>在文件系统中，数据项是最低级的数据组织形式，可分为基本数据项和组合数据项</p><h4 id="2-记录"><a href="#2-记录" class="headerlink" title="2. 记录"></a>2. 记录</h4><p>一组相关数据项的集合，用于描述一个对象在某方面的属性</p><p>在不同环境下，一个对象的记录不同</p><p>关键字：用于唯一标识一个记录的一个或多个数据项的集合</p><h4 id="3-文件"><a href="#3-文件" class="headerlink" title="3. 文件"></a>3. 文件</h4><p>文件是指由创建者所定义的、具有文件名的一组相关元素的集合，可分为有结构文件和无结构文件两种。</p><p>文件属性：文件类型、文件长度、文件的物理位置、文件的建立时间</p><h3 id="7-1-2-文件名和类型"><a href="#7-1-2-文件名和类型" class="headerlink" title="7.1.2 文件名和类型"></a>7.1.2 文件名和类型</h3><p><strong>1. 文件名和扩展名</strong></p><p><strong>2. 文件类型</strong></p><ol><li>按用途分类：系统文件、用户文件、库文件</li><li>按文件中数据的形式分类：源文件、目标文件、可执行文件</li><li>按存取控制属性分类：只执行文件、只读文件、读写文件</li><li>按组织形式和处理方式分类：普通文件、目录文件、特殊文件</li></ol><h3 id="7-1-3-文件系统的层次结构"><a href="#7-1-3-文件系统的层次结构" class="headerlink" title="7.1.3 文件系统的层次结构"></a>7.1.3 文件系统的层次结构</h3><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211227123805250.png" alt="image-20211227123805250"></p><ol><li><p>对象及其属性</p><p>文件管理系统管理的对象：文件、目录、磁盘存储空间</p></li><li><p>对对象操纵和管理的软件的集合</p><p>文件系统的功能大多在这一层实现：对文件存储空间的管理、对文件目录的管理、将文件的逻辑地址转换为物理地址、对文件读和写的管理、对文件的共享与保护等功能</p><p>四个层次：I&#x2F;O控制层、基本文件系统层、基本I&#x2F;O管理程序、逻辑文件系统</p></li><li><p>文件系统的接口</p><p>命令接口、程序接口</p></li></ol><h3 id="7-1-4-文件操作"><a href="#7-1-4-文件操作" class="headerlink" title="7.1.4 文件操作"></a>7.1.4 文件操作</h3><ol><li><p>最基本的文件操作：创建文件、删除文件、读文件、写文件、设置文件的读&#x2F;写位置</p></li><li><p>文件的“打开”和“关闭”操作</p></li><li><p>其他文件操作</p></li></ol><h2 id="7-2-文件的逻辑结构"><a href="#7-2-文件的逻辑结构" class="headerlink" title="7.2 文件的逻辑结构"></a>7.2 文件的逻辑结构</h2><h3 id="7-2-1-文件逻辑结构的类型"><a href="#7-2-1-文件逻辑结构的类型" class="headerlink" title="7.2.1 文件逻辑结构的类型"></a>7.2.1 文件逻辑结构的类型</h3><h4 id="1-按文件是否有结构分类"><a href="#1-按文件是否有结构分类" class="headerlink" title="1. 按文件是否有结构分类"></a>1. 按文件是否有结构分类</h4><ol><li>有结构文件：定长记录、变长记录</li><li>无结构文件</li></ol><h4 id="2-按文件的组织方式分类"><a href="#2-按文件的组织方式分类" class="headerlink" title="2. 按文件的组织方式分类"></a>2. 按文件的组织方式分类</h4><ol><li>顺序文件</li><li>索引文件</li><li>索引顺序文件</li></ol><h3 id="7-2-2-顺序文件"><a href="#7-2-2-顺序文件" class="headerlink" title="7.2.2 顺序文件"></a>7.2.2 顺序文件</h3><h4 id="1-顺序文件的排列方式"><a href="#1-顺序文件的排列方式" class="headerlink" title="1. 顺序文件的排列方式"></a>1. 顺序文件的排列方式</h4><ol><li>串结构</li><li>顺序结构</li></ol><h4 id="2-顺序文件的优缺点"><a href="#2-顺序文件的优缺点" class="headerlink" title="2. 顺序文件的优缺点"></a>2. 顺序文件的优缺点</h4><p>优点：</p><ol><li>适用于对文件中的记录进行批量存取时（即每次要读或写一大批记录），所有逻辑文件中顺序文件的存取效率最高</li><li>对于顺序存储设备（如磁带），只有顺序文件才能被存储并能有效地工作</li></ol><p>缺点：</p><ol><li>在交互查询时效率很低</li><li>想增加或删除一个记录比较困难</li></ol><h3 id="7-2-3-记录寻址"><a href="#7-2-3-记录寻址" class="headerlink" title="7.2.3 记录寻址"></a>7.2.3 记录寻址</h3><h4 id="1-隐式寻址方式"><a href="#1-隐式寻址方式" class="headerlink" title="1. 隐式寻址方式"></a>1. 隐式寻址方式</h4><h4 id="2-显式寻址方式"><a href="#2-显式寻址方式" class="headerlink" title="2. 显式寻址方式"></a>2. 显式寻址方式</h4><ol><li>通过文件中记录的位置</li><li>利用关键字</li></ol><h3 id="7-2-4-索引文件"><a href="#7-2-4-索引文件" class="headerlink" title="7.2.4 索引文件"></a>7.2.4 索引文件</h3><ol><li>按关键字建立索引</li><li>具有多个索引表的索引文件</li></ol><h3 id="7-2-5-索引顺序文件"><a href="#7-2-5-索引顺序文件" class="headerlink" title="7.2.5 索引顺序文件"></a>7.2.5 索引顺序文件</h3><h4 id="1-索引顺序文件的特征"><a href="#1-索引顺序文件的特征" class="headerlink" title="1. 索引顺序文件的特征"></a>1. 索引顺序文件的特征</h4><ol><li>记录是按关键字的顺序组织起来的</li><li>引入了文件索引表，实现对索引文件的随机访问</li><li>增加了溢出文件，记录新增加的、删除的和修改的记录</li></ol><p>克服变长记录文件的缺点，而且代价不算太大</p><h4 id="2-一级索引顺序文件"><a href="#2-一级索引顺序文件" class="headerlink" title="2. 一级索引顺序文件"></a>2. 一级索引顺序文件</h4><p>建立方法：将变长记录顺序文件中的所有记录分为若干个组，然后为顺序文件建立一张索引表，并为每组中的第一个记录在索引表中建立一个索引项，其中含有该记录的关键字和指向该记录的指针</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20211231090431716.png" alt="image-20211231090431716"></p><h4 id="3-两级索引顺序文件"><a href="#3-两级索引顺序文件" class="headerlink" title="3. 两级索引顺序文件"></a>3. 两级索引顺序文件</h4><h3 id="7-2-6-直接文件和哈希文件"><a href="#7-2-6-直接文件和哈希文件" class="headerlink" title="7.2.6 直接文件和哈希文件"></a>7.2.6 直接文件和哈希文件</h3><ol><li>直接文件</li><li>哈希文件</li></ol><h2 id="7-3-文件目录"><a href="#7-3-文件目录" class="headerlink" title="7.3 文件目录"></a>7.3 文件目录</h2><p>对目录管理的要求如下：</p><ol><li>实现”按名存取“</li><li>提高对目录的检索速度</li><li>文件共享</li><li>允许文件重名</li></ol><h3 id="7-3-1-文件控制块和索引结点"><a href="#7-3-1-文件控制块和索引结点" class="headerlink" title="7.3.1 文件控制块和索引结点"></a>7.3.1 文件控制块和索引结点</h3><h4 id="1-文件控制块FCB"><a href="#1-文件控制块FCB" class="headerlink" title="1. 文件控制块FCB"></a>1. 文件控制块FCB</h4><ol><li>基本信息类：文件名、文件物理地址、文件逻辑结构、文件的物理结构</li><li>存取控制信息类</li><li>使用信息类</li></ol><h4 id="2-索引结点"><a href="#2-索引结点" class="headerlink" title="2. 索引结点"></a>2. 索引结点</h4><ol><li><p>索引结点的引入</p><p>检索目录文件的过程中，只用到了结点名，仅当找到了一个目录项才需读出其物理地址，其他信息一概不用</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220110080217967.png" alt="image-20220110080217967"></p></li><li><p>磁盘索引结点</p><p>每个文件有唯一的一个磁盘索引结点，主要包括：文件主标识符、文件类型、文件存取权限、文件物理地址、文件长度、文件连接计数、文件存取时间</p></li><li><p>内存索引结点</p><p>索引结点编号、状态、访问计数、文件所属系统的逻辑设备号、链接指针</p></li></ol><h3 id="7-3-2-简单的文件目录"><a href="#7-3-2-简单的文件目录" class="headerlink" title="7.3.2 简单的文件目录"></a>7.3.2 简单的文件目录</h3><h4 id="单级文件目录"><a href="#单级文件目录" class="headerlink" title="单级文件目录"></a>单级文件目录</h4><p>在整个文件系统中只建立一张目录表，每个文件占一个表项</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220110080618641.png" alt="image-20220110080618641"></p><p>单极文件目录的优点是简单，但只能实现按名存取，缺点：</p><ol><li>查找速度慢</li><li>不允许重名</li><li>不便于实现文件共享</li></ol><h4 id="两级文件目录"><a href="#两级文件目录" class="headerlink" title="两级文件目录"></a>两级文件目录</h4><p>主文件目录MFD+用户文件目录UFD</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220110080852413.png" alt="image-20220110080852413"></p><p>基本满足对文件目录的四方面的要求：</p><ol><li>提高了检索目录的速度</li><li>在不同的用户目录中，可以使用相同的文件名</li><li>不同用户还可使用不同的文件名访问系统中的同一个共享文件</li></ol><h3 id="7-3-3-树形结构目录"><a href="#7-3-3-树形结构目录" class="headerlink" title="7.3.3 树形结构目录"></a>7.3.3 树形结构目录</h3><h4 id="树形目录"><a href="#树形目录" class="headerlink" title="树形目录"></a>树形目录</h4><p>主目录被称为根目录，在每个文件目录中，有且只有一个根目录，每个文件和每个目录都只能有一个父目录，把数据文件称为树叶，其他的目录均作为树的结点，或称为子目录</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220110081404698.png" alt="image-20220110081404698"></p><h4 id="路径名和当前目录"><a href="#路径名和当前目录" class="headerlink" title="路径名和当前目录"></a>路径名和当前目录</h4><ol><li>路径名</li><li>当前目录（工作目录）</li><li>目录操作：创建目录、删除目录（不删除非空目录、可删除非空目录）、改变目录、移动目录、链接操作、查找</li></ol><h3 id="7-3-4-目录查询技术"><a href="#7-3-4-目录查询技术" class="headerlink" title="7.3.4 目录查询技术"></a>7.3.4 目录查询技术</h3><ol><li><p>线性检索法</p></li><li><p>Hash方法</p></li></ol><h2 id="7-4-文件共享"><a href="#7-4-文件共享" class="headerlink" title="7.4 文件共享"></a>7.4 文件共享</h2><h3 id="7-4-1-基于有向无循环图实现文件共享"><a href="#7-4-1-基于有向无循环图实现文件共享" class="headerlink" title="7.4.1 基于有向无循环图实现文件共享"></a>7.4.1 基于有向无循环图实现文件共享</h3><ol><li><p>有向无循环图DAG</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220110082820831.png" alt="image-20220110082820831"></p></li><li><p>利用索引结点</p></li></ol><h3 id="7-4-2-利用符号链接实现文件共享"><a href="#7-4-2-利用符号链接实现文件共享" class="headerlink" title="7.4.2 利用符号链接实现文件共享"></a>7.4.2 利用符号链接实现文件共享</h3><ol><li><p>利用符号链接的基本思想</p><p>允许一个文件或子目录有多个父目录，但其中仅有一个作为主（属主）父目录，其他的几个父目录都是通过符号链接方式与之相链接的（简称链接父目录）</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220110083452134.png" alt="image-20220110083452134"></p></li><li><p>如何利用符号链实现共享</p><p>大白话：用快捷方式实现文件共享</p></li><li><p>利用符号链接实现共享的优点</p><p>不会产生空指针的问题</p></li><li><p>利用符号链的共享方式存在的问题</p><p>每次访问文件的开销大，增加了访问磁盘的频率，耗费一定的磁盘空间为它配置一个索引结点</p></li></ol><h2 id="7-5-文件保护"><a href="#7-5-文件保护" class="headerlink" title="7.5 文件保护"></a>7.5 文件保护</h2><p>影响文件安全性的主要因素：人为因素、系统因素、自然因素</p><p>为确保文件的安全性，可采取的措施：</p><ol><li>通过存取控制机制，防止由人为因素所造成的文件不安全性</li><li>采取系统容错技术，防止由系统部分的故障所造成的文件的不安全性</li><li>建立后被系统，防止由自然因素所造成的不安全性</li></ol><h3 id="7-5-1-保护域"><a href="#7-5-1-保护域" class="headerlink" title="7.5.1 保护域"></a>7.5.1 保护域</h3><ol><li><p>访问权</p></li><li><p>保护域</p><p>进程只能在指定域内执行操作</p></li><li><p>进程和域间的静态联系</p><p>在进程和域之间可以一一对应，即一个进程只联系着一个域，换句话说，在进程的整个生命期中，可用资源是固定的，这种域被称为静态域</p></li><li><p>进程和域间的动态联系方式</p><p>进程和域之间的一对多关系，即一个进程可以联系着多个域</p></li></ol><h3 id="7-5-2-访问矩阵"><a href="#7-5-2-访问矩阵" class="headerlink" title="7.5.2 访问矩阵"></a>7.5.2 访问矩阵</h3><ol><li><p>基本的访问矩阵</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220110090140245.png" alt="image-20220110090140245"></p></li><li><p>具有域切换权的访问矩阵</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220110090620784.png" alt="image-20220110090620784"></p></li></ol><h3 id="7-5-3-访问矩阵的修改"><a href="#7-5-3-访问矩阵的修改" class="headerlink" title="7.5.3 访问矩阵的修改"></a>7.5.3 访问矩阵的修改</h3><ol><li><p>拷贝权</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220110090729234.png" alt="image-20220110090729234"></p></li><li><p>所有权</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220110090743385.png" alt="image-20220110090743385"></p></li><li><p>控制权</p><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220110090817733.png" alt="image-20220110090817733"></p></li></ol><h3 id="7-5-4-访问矩阵的实现"><a href="#7-5-4-访问矩阵的实现" class="headerlink" title="7.5.4 访问矩阵的实现"></a>7.5.4 访问矩阵的实现</h3><ol><li>访问控制表</li><li>访问权限表</li></ol><h1 id="第8章-磁盘存储器的管理"><a href="#第8章-磁盘存储器的管理" class="headerlink" title="第8章 磁盘存储器的管理"></a>第8章 磁盘存储器的管理</h1><p>对磁盘存储器管理的主要任务和要求是：</p><ol><li>有效地利用存储空间</li><li>提高磁盘的I&#x2F;O速度</li><li>提高磁盘系统的可靠性</li></ol><h2 id="8-1-外存的组织方式"><a href="#8-1-外存的组织方式" class="headerlink" title="8.1 外存的组织方式"></a>8.1 外存的组织方式</h2><ol><li>连续组织方式</li><li>链接组织方式</li><li>索引组织方式</li></ol><h3 id="8-1-1-连续组织方式"><a href="#8-1-1-连续组织方式" class="headerlink" title="8.1.1 连续组织方式"></a>8.1.1 连续组织方式</h3><p>主要优点：</p><ol><li>顺序访问容易</li><li>顺序访问速度快</li></ol><p>主要缺点：</p><ol><li>要求为一个文件分配连续的存储空间</li><li>必须事先知道文件的长度</li><li>不能灵活地删除和插入记录</li><li>对于那些动态增长的文件</li></ol><h3 id="8-1-2-链接组织方式"><a href="#8-1-2-链接组织方式" class="headerlink" title="8.1.2 链接组织方式"></a>8.1.2 链接组织方式</h3><p>主要优点：</p><ol><li>消除了磁盘的外部碎片，提高了外存的利用率</li><li>对插入、删除和修改记录都非常容易</li><li>能适应文件的动态增长，无需事先知道文件的大小</li></ol><h4 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h4><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220110091804415.png" alt="image-20220110091804415"></p><p>主要问题：只适合于顺序访问，对随机访问时及其低效的</p><p>改进方式：将几个盘块组成一个簇</p><h4 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h4><p>把用于链接文件各物理块的指针显式地存放在内存的一张链接表FAT中。</p><h3 id="8-1-3-FAT技术"><a href="#8-1-3-FAT技术" class="headerlink" title="8.1.3 FAT技术"></a>8.1.3 FAT技术</h3><ol><li>FAT12 </li><li>FAT16</li><li>FAT32</li></ol><h3 id="8-1-4-NTFS的文件组织方式"><a href="#8-1-4-NTFS的文件组织方式" class="headerlink" title="8.1.4 NTFS的文件组织方式"></a>8.1.4 NTFS的文件组织方式</h3><h4 id="NTFS新特征"><a href="#NTFS新特征" class="headerlink" title="NTFS新特征"></a>NTFS新特征</h4><ol><li>使用了64位磁盘地址</li><li>支持长文件名</li><li>具有系统容错功能</li><li>能保证系统中的数据一致性</li></ol><h4 id="磁盘组织"><a href="#磁盘组织" class="headerlink" title="磁盘组织"></a>磁盘组织</h4><h4 id="文件的组织"><a href="#文件的组织" class="headerlink" title="文件的组织"></a>文件的组织</h4><h3 id="8-1-5-索引组织方式"><a href="#8-1-5-索引组织方式" class="headerlink" title="8.1.5 索引组织方式"></a>8.1.5 索引组织方式</h3><h4 id="单级索引组织方式"><a href="#单级索引组织方式" class="headerlink" title="单级索引组织方式"></a>单级索引组织方式</h4><p>主要优点：支持直接访问</p><p>主要问题：每当建立一个索引文件时，应位该文件分配一个索引块，将分配给该文件的所有盘块号记录于其中</p><h4 id="多级索引组织方式"><a href="#多级索引组织方式" class="headerlink" title="多级索引组织方式"></a>多级索引组织方式</h4><p><img src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220110093032478.png" alt="image-20220110093032478"></p><p>主要优点：大大加快了对大型文件的查找速度</p><p>主要缺点：在访问一个盘块时，其所需启动磁盘的次数随着索引级数的增加而增多</p><h4 id="增量式索引组织方式"><a href="#增量式索引组织方式" class="headerlink" title="增量式索引组织方式"></a>增量式索引组织方式</h4><p>基本思想：</p><ol><li>对于小文件：将它们的每一个盘块地址都直接放入文件控制块FCB中</li><li>对于中等文件，采用单级索引组织方式</li><li>对于大型和特大型文件，可以采用两级和三级索引组织方式</li></ol><p>UNIX System V的组织方式：看书，不想记了</p><h2 id="8-2-文件存储空间的管理"><a href="#8-2-文件存储空间的管理" class="headerlink" title="8.2 文件存储空间的管理"></a>8.2 文件存储空间的管理</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网课：UNITY-RPG游戏从框架到实战</title>
      <link href="/posts/1466395c/"/>
      <url>/posts/1466395c/</url>
      
        <content type="html"><![CDATA[<h1 id="UNITY-–-RPG游戏从框架到实战"><a href="#UNITY-–-RPG游戏从框架到实战" class="headerlink" title="UNITY – RPG游戏从框架到实战"></a>UNITY – RPG游戏从框架到实战</h1><h2 id="软件设计原则："><a href="#软件设计原则：" class="headerlink" title="软件设计原则："></a>软件设计原则：</h2><p>1、适应变化</p><p>2、提高代码复用率</p><p>3、可维护性</p><p>4、可扩展性</p><h2 id="设计原则："><a href="#设计原则：" class="headerlink" title="设计原则："></a>设计原则：</h2><p>单一职责：单个功能使用一个类去控制</p><p>开闭原则：不能直接访问类成员，应该使用Get、Set方法或其他方法封装</p><p>依赖倒置：1、先了解需求。2、先画图。3、变成代码。</p><p>接口隔离原则：接口里面的单一原则</p><p>里氏原则：不要修改别人的代码，重写父类的代码</p><p>多态：父类的指针指向子类而调用子类的方法</p><p>合成复用原则：1、将类抽象化，父类解决共有问题，子类解决特有问题</p><p>​    2、单纯抽象化使子类继承父类会导致类越写越多越来越复杂，可以让类中包含其他类的实例</p><p>即，多用组合少用继承</p><p>迪米特法则（又称最少知识原则）：假如A类中包含B类的实例，且A类中调用B类的方法，如果B类的方法改变，例如改变方法的参数，那么A类中的调用也需要进行调整，所以方法的调整尽量不要牵扯到其他类中的代码调整</p><h2 id="设计模式："><a href="#设计模式：" class="headerlink" title="设计模式："></a>设计模式：</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>适用于整个软件生命周期有且只有一次实例，例如组织框架，每个模块的管理者</p><p>方法：public static</p><p>单例两种方式：</p><p>1、继承MonoBehavior  </p><p>用在组织框架的管理器上面</p><p>Public static test Instance;</p><p>Void Awake()</p><p>{<br>   Instance &#x3D; this;</p><p>}</p><p>2、不继承MonoBehavior</p><p>Private static test instance;</p><p>Public static text Instance</p><p>{</p><p>  get</p><p>  {</p><p>If(Instance &#x3D;&#x3D; null)</p><p>{<br>   Instance &#x3D; new test();</p><p>}</p><p>Return this;</p><p>  }</p><p>}</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>作用：用于new一些新的对象</p><p>例如：生产野怪</p><p>特点：不关心生产过程</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>作用：不断地询问</p><p>方法：</p><p>​1、计时操作，Time.deltaTime</p><p>​    2、事件监听模式</p><p>注意UnityAction是无返回值单参数委托类，利用new Unity Action注册事件的特点是，注册的事件保存在堆上</p><p>详情可看连的代码</p><h3 id="策略者模式"><a href="#策略者模式" class="headerlink" title="策略者模式"></a>策略者模式</h3><p>根据不同的输入，得到不同的输出结果</p><p>实现方法：利用多态实现</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>金字塔结构，从主要的管理者开始，细分各个功能</p><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>类与类之间不互相关联，通过第三方解决，即第三个类</p><h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>将各种不同类型的东西放在一起形成特定的功能</p><p>类似于中介者模式，即将两种不同的组件通过控件控制，类似于父物体控制子物体</p><p>注意：在写脚本的过程中尽量不要public GameObject，因为这么写会增加耦合度，可以通过transform.find方法来找</p><p>另：transform.find方法用的是深度优先遍历dps</p><p>举例：坦克的各个部件，比如炮台、履带、车身</p><h2 id="WWW封装"><a href="#WWW封装" class="headerlink" title="ＷＷＷ封装"></a>ＷＷＷ封装</h2><p>Get请求：</p><p>​１、参数在链接里面，？问号后面是参数</p><p>​</p><p>Post请求：</p><p>​１、参数在表单里面</p><p>​２、服务器</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL</title>
      <link href="/posts/38fdccb7/"/>
      <url>/posts/38fdccb7/</url>
      
        <content type="html"><![CDATA[<h1 id="以下为入门模块"><a href="#以下为入门模块" class="headerlink" title="以下为入门模块"></a>以下为入门模块</h1><h1 id="你好，窗口"><a href="#你好，窗口" class="headerlink" title="你好，窗口"></a>你好，窗口</h1><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())<span class="comment">//glfw初始化</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//glfw主版本为3</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//glfw次版本为3</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="comment">//使用核心模式</span></span><br><span class="line"></span><br><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);<span class="comment">//创建窗口，长宽名字</span></span><br><span class="line"><span class="keyword">if</span> (!window)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);<span class="comment">//将该窗口设置为当前线程的主上下文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)<span class="comment">//glew初始化</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);<span class="comment">//OpenGL渲染窗口的尺寸大小，前两个参数：左下角的位置，后两个参数：宽度和高度（像素）</span></span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);<span class="comment">//注册视口变化函数</span></span><br></pre></td></tr></table></figure><h3 id="渲染循环"><a href="#渲染循环" class="headerlink" title="渲染循环"></a>渲染循环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))<span class="comment">//该函数用于检测GLFW是否被要求退出，如果是则返回true</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="built_in">processInput</span>(window);<span class="comment">//点击ESC退出</span></span><br><span class="line"><span class="comment">//渲染指令</span></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);<span class="comment">//指定清除缓冲所用的颜色</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//指定清除颜色缓冲</span></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);<span class="comment">//交换颜色缓冲</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>();<span class="comment">//检查有没有触发什么事件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();<span class="comment">//正确释放/删除之前的分配的左右资源</span></span><br></pre></td></tr></table></figure><h1 id="你好，三角形"><a href="#你好，三角形" class="headerlink" title="你好，三角形"></a>你好，三角形</h1><ul><li>顶点数组对象：Vertex Array Object，VAO</li><li>顶点缓冲对象：Vertex Buffer Object，VBO</li><li>索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO</li></ul><p>图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p><p>有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的，在下一节中我们再花更多时间研究它。</p><img src="../images/OpenGL.assets/pipeline.png" alt="image-pipeline" style="zoom:67%;" /><p>在图形渲染的过程中，最少需要顶点着器和片段着色器两个着色器</p><h2 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h2><p>渲染一个三角形，一共要指定三个顶点，每个顶点都有一个3D位置。将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个<code>float</code>数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] = &#123;</span><br><span class="line">    -0.5f, -0.5f, 0.0f,</span><br><span class="line">     0.5f, -0.5f, 0.0f,</span><br><span class="line">     0.0f,  0.5f, 0.0f</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>标准化设备坐标</strong>：一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是<strong>标准化设备坐标</strong>了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃&#x2F;裁剪，不会显示在你的屏幕上。</p><p>创建一个VBO对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br></pre></td></tr></table></figure><p>新创建的缓冲绑定到GL_ARRAY_BUFFER目标上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);  </span><br></pre></td></tr></table></figure><p>从这一刻起，我们使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)。然后我们可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。第二个参数指定传输数据的大小(以字节为单位)；用一个简单的<code>sizeof</code>计算出顶点数据大小就行。第三个参数是我们希望发送的实际数据。</p><p>第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：</p><ul><li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li><li>GL_DYNAMIC_DRAW：数据会被改变很多。</li><li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li></ul><p>三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。</p><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h2><p>现在，我们暂时将顶点着色器的源代码硬编码在代码文件顶部的C风格字符串中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const char *vertexShaderSource = &quot;#version 330 core\n&quot;</span><br><span class="line">    &quot;layout (location = 0) in vec3 aPos;\n&quot;</span><br><span class="line">    &quot;void main()\n&quot;</span><br><span class="line">    &quot;&#123;\n&quot;</span><br><span class="line">    &quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span><br><span class="line">    &quot;&#125;\0&quot;;</span><br></pre></td></tr></table></figure><p>为了能够让OpenGL使用它，我们必须在运行时动态编译它的源代码。</p><p>我们首先要做的是创建一个着色器对象，注意还是用ID来引用的。所以我们储存这个顶点着色器为<code>unsigned int</code>，然后用glCreateShader创建这个着色器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br></pre></td></tr></table></figure><p>我们把需要创建的着色器类型以参数形式提供给glCreateShader。由于我们正在创建一个顶点着色器，传递的参数是GL_VERTEX_SHADER。</p><p>下一步我们把这个着色器源码附加到着色器对象上，然后编译它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);</span><br><span class="line">glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure><p>glShaderSource函数把要编译的着色器对象作为第一个参数。第二参数指定了传递的源码字符串数量，这里只有一个。第三个参数是顶点着色器真正的源码，第四个参数我们先设置为<code>NULL</code>。</p><p>你可能会希望检测在调用glCompileShader后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修复它们。检测编译时错误可以通过以下代码来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int  success;</span><br><span class="line">char infoLog[512];</span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br></pre></td></tr></table></figure><p>首先我们定义一个整型变量来表示是否成功编译，还定义了一个储存错误消息（如果有的话）的容器。然后我们用glGetShaderiv检查是否编译成功。如果编译失败，我们会用glGetShaderInfoLog获取错误消息，然后打印它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(!success)</span><br><span class="line">&#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);</span><br><span class="line">    std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译的时候没有检测到任何错误，顶点着色器就被编译成功了。</p><h2 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure><h2 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h2><p>创建一个程序对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>();</span><br></pre></td></tr></table></figure><p>glCreateProgram函数创建一个程序，并返回新创建程序对象的ID引用。现在我们需要把之前编译的着色器附加到程序对象上，然后用glLinkProgram链接它们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram);</span><br></pre></td></tr></table></figure><p>就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与上面不同，我们不会调用glGetShaderiv和glGetShaderInfoLog，现在我们使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span>(!success) &#123;</span><br><span class="line">    <span class="built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果就是一个程序对象，我们可以调用glUseProgram函数，用刚创建的程序对象作为它的参数，以激活这个程序对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br></pre></td></tr></table></figure><p>在把着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure><h2 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h2> <img src="../images/OpenGL.assets/vertex_attribute_pointer.png" alt="img" style="zoom:67%;" /><ul><li>位置数据被储存为32位（4字节）浮点值。</li><li>每个位置包含3个这样的值。</li><li>在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列(Tightly Packed)。</li><li>数据中第一个值在缓冲开始的位置。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;参数含义：<br>        &#x2F;&#x2F;1、顶点属性：设为0<br>        &#x2F;&#x2F;2、顶点属性的大小：顶点属性是vec3，由3个值组成，所以大小是3<br>        &#x2F;&#x2F;3、数据的类型：GL_FLOAT（GLSL中<code>vec*</code>都是由浮点数值组成的）<br>        &#x2F;&#x2F;4、是否希望数据被标准化：如果设置为GL_TRUE，则所有数据会被映射到0<br>        &#x2F;&#x2F;5、步长：在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后<br>        &#x2F;&#x2F;6、数据在缓冲中起始位置的偏移量：由于位置数据在数组的开头，所以这里是0，参数类型是<code>void*</code><br>    &#x2F;&#x2F;以顶点属性位置值作为参数，启用顶点属性</p><h2 id="顶点数组对象"><a href="#顶点数组对象" class="headerlink" title="顶点数组对象"></a>顶点数组对象</h2><p>一个顶点数组对象会储存以下这些内容：</p><ul><li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li><li>通过glVertexAttribPointer设置的顶点属性配置。</li><li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li></ul> <img src="../images/OpenGL.assets/vertex_array_objects.png" alt="img" style="zoom:67%;" /><p>创建一个VAO和创建一个VBO很类似：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定VAO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line"><span class="comment">// 4. 绘制物体</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">someOpenGLFunctionThatDrawsOurTriangle</span>();</span><br></pre></td></tr></table></figure><h2 id="三角形！！！"><a href="#三角形！！！" class="headerlink" title="三角形！！！"></a>三角形！！！</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><img src="/../images/OpenGL.assets/hellotriangle.png" alt="img"></p><p>完整的程序源码可以在<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.1.hello_triangle/hello_triangle.cpp">这里</a>找到。</p><h2 id="索引缓冲对象"><a href="#索引缓冲对象" class="headerlink" title="索引缓冲对象"></a>索引缓冲对象</h2><p>引缓冲对象(Element Buffer Object，EBO，也叫Index Buffer  Object，IBO)。要解释索引缓冲对象的工作方式最好还是举个例子：假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）。这会生成下面的顶点的集合：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在该代码中，我们制定了<code>右下角</code>和<code>左上角</code>两次，会产生额外开销</p><p>索引缓冲对象EBO功能：只要存储4个顶点，通过指定顶点的方式绘制数组，称为索引绘制(Indexed Drawing)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下一步我们需要创建索引缓冲对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> EBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br></pre></td></tr></table></figure><p>与VBO类似，我们先绑定EBO然后用glBufferData把索引复制到缓冲里。同样，和VBO类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为GL_ELEMENT_ARRAY_BUFFER。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>最后一件要做的事是用glDrawElements来替换glDrawArrays函数，来指明我们从索引缓冲渲染。使用glDrawElements时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>最后的初始化和绘制代码现在看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// ..:: 初始化代码 :: ..</span><br><span class="line">// 1. 绑定顶点数组对象</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">// 4. 设定顶点属性指针</span><br><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">// ..:: 绘制代码（渲染循环中） :: ..</span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0)</span><br><span class="line">glBindVertexArray(0);</span><br></pre></td></tr></table></figure><p>运行程序会获得下面这样的图片的结果。左侧图片看应该起来很熟悉，而右侧的则是使用线框模式(Wireframe Mode)绘制的。线框矩形可以显示出矩形的确是由两个三角形组成的。</p><p><img src="/../images/OpenGL.assets/hellotriangle2.png" alt="img"></p><p><strong>线框模式(Wireframe Mode)</strong></p><p>要想用线框模式绘制你的三角形，你可以通过<code>glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)</code>函数配置OpenGL如何绘制图元。第一个参数表示我们打算将其应用到所有的三角形的正面和背面，第二个参数告诉我们用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用<code>glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)</code>将其设置回默认模式。</p><h6 id="三角形源码"><a href="#三角形源码" class="headerlink" title="三角形源码"></a><a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.2.hello_triangle_indexed/hello_triangle_indexed.cpp">三角形源码</a></h6><h1 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h1><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><p>类C语言，为图形计算量身定制</p><p>一个典型的着色器有下面的结构：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明版本</span></span><br><span class="line"><span class="meta">#version version_number</span></span><br><span class="line"><span class="comment">// 输入变量</span></span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出变量</span></span><br><span class="line"><span class="keyword">out</span> type out_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uniform</span></span><br><span class="line"><span class="keyword">uniform</span> type uniform_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理输入并进行一些图形操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 输出处理过的结果到输出变量</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们特别谈论到顶点着色器的时候，每个输入变量也叫顶点属性(Vertex Attribute)。我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL确保至少有16个包含4分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性，你可以查询GL_MAX_VERTEX_ATTRIBS来获取具体的上限：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nrAttributes;</span><br><span class="line">glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);</span><br><span class="line">std::cout &lt;&lt; &quot;Maximum nr of vertex attributes supported: &quot; &lt;&lt; nrAttributes &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>默认基础数据类型：int, float, double,  uint, bool</p><p>容器类型：向量(Vector)和矩阵(Matrix)</p><h4 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h4><p>可以包含1、2、3、4个分量的容器，分量的类型可以是任意一个默认基础类型。</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><code>vecn</code></td><td>包含<code>n</code>个float分量的默认向量</td></tr><tr><td><code>bvecn</code></td><td>包含<code>n</code>个bool分量的向量</td></tr><tr><td><code>ivecn</code></td><td>包含<code>n</code>个int分量的向量</td></tr><tr><td><code>uvecn</code></td><td>包含<code>n</code>个unsigned int分量的向量</td></tr><tr><td><code>dvecn</code></td><td>包含<code>n</code>个double分量的向量</td></tr></tbody></table><p>可以通过x、y、z、w分别获取4个分量。对颜色可用rgba，对纹理使用stpq访问其分量。</p><h5 id="向量重组"><a href="#向量重组" class="headerlink" title="向量重组"></a>向量重组</h5><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> someVec;</span><br><span class="line"><span class="type">vec4</span> differentVec = someVec.xyxx;</span><br><span class="line"><span class="type">vec3</span> anotherVec = differentVec.zyw;</span><br><span class="line"><span class="type">vec4</span> otherVec = someVec.xxxx + anotherVec.yxzy;</span><br></pre></td></tr></table></figure><p>也可以把一个向量作为参数传给不同的向量构造参数，以减少需求参数的数量</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> vect = <span class="type">vec2</span>(<span class="number">0.5</span>, <span class="number">0.7</span>);</span><br><span class="line"><span class="type">vec4</span> result = <span class="type">vec4</span>(vect, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="type">vec4</span> otherResult = <span class="type">vec4</span>(result.xyz, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><p> 为了使着色器之间能够进行数据交流和传递，GLSL定义了in和out关键字。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入变量相匹配，就可以传递下去。（顶点和片段着色器中会有不同）</p><p>顶点着色器：接收一种特殊形式的输入，否则就会效率低下。layout (location &#x3D; 0)</p><p>片段着色器：需要一个vec4的颜色输出变量</p><p>举例：</p><p><strong>顶点着色器</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos; <span class="comment">// 位置变量的属性位置值为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> vertexColor; <span class="comment">// 为片段着色器指定一个颜色输出</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>); <span class="comment">// 注意我们如何把一个vec3作为vec4的构造器的参数</span></span><br><span class="line">    vertexColor = <span class="type">vec4</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 把输出变量设置为暗红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>片段着色器</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec4</span> vertexColor; <span class="comment">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h3><p>Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式</p><p>uniform是全局的(Global)，全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p><p>uniform的声明：uniform关键字+数据类型+变量名</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> ourColor; </span><br></pre></td></tr></table></figure><p>如果我们声明了一个uniform却没有在GLSL代码中用过，编译器会静默移除这个变量，导致最后编译出的版本中不会包含它，可能导致几个非常麻烦的错误。</p><h5 id="uniform应用实例"><a href="#uniform应用实例" class="headerlink" title="uniform应用实例"></a>uniform应用实例</h5><p>使一个三角形的颜色随时间进行改变：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取运行的秒数</span></span><br><span class="line"><span class="type">float</span> timeValue = glfwGetTime();</span><br><span class="line"><span class="comment">// 使用sin函数使timeValue在0.0到1.0之间改变</span></span><br><span class="line"><span class="type">float</span> greenValue = (<span class="built_in">sin</span>(timeValue) / <span class="number">2.0</span>f) + <span class="number">0.5</span>f;</span><br><span class="line"><span class="comment">// 查询uniform ourColor的位置值，参数为着色器程序和uniform名字</span></span><br><span class="line"><span class="type">int</span> vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);</span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">// 设置uniform值</span></span><br><span class="line">glUniform4f(vertexColorLocation, <span class="number">0.0</span>f, greenValue, <span class="number">0.0</span>f, <span class="number">1.0</span>f);</span><br></pre></td></tr></table></figure><p><strong>注意：查询uniform地址不要求你之前使用过着色器程序，但是更新一个uniform之前你必须先使用程序（调用glUseProgram)，因为它是在当前激活的着色器程序中设置uniform的。</strong></p><p>因为OpenGL在其核心是一个C库，所以它不支持类型重载，在函数参数不同的时候就要为其定义新的函数；glUniform是一个典型例子。这个函数有一个特定的后缀，标识设定的uniform的类型。可能的后缀有：</p><table><thead><tr><th>后缀</th><th>含义</th></tr></thead><tbody><tr><td><code>f</code></td><td>函数需要一个float作为它的值</td></tr><tr><td><code>i</code></td><td>函数需要一个int作为它的值</td></tr><tr><td><code>ui</code></td><td>函数需要一个unsigned int作为它的值</td></tr><tr><td><code>3f</code></td><td>函数需要3个float作为它的值</td></tr><tr><td><code>fv</code></td><td>函数需要一个float向量&#x2F;数组作为它的值</td></tr></tbody></table><p>每当你打算配置一个OpenGL的选项时就可以简单地根据这些规则选择适合你的数据类型的重载函数。在我们的例子里，我们希望分别设定uniform的4个float值，所以我们通过glUniform4f传递我们的数据(注意，我们也可以使用<code>fv</code>版本)。</p><h3 id="更多属性！"><a href="#更多属性！" class="headerlink" title="更多属性！"></a>更多属性！</h3><p>我们可以把颜色存入每个顶点数据中</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="keyword">vertices</span>[] = &#123;</span><br><span class="line">    <span class="comment">// 位置              // 颜色</span></span><br><span class="line">     <span class="number">0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,  <span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="number">0.0</span>f,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,  <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f,   <span class="comment">// 左下</span></span><br><span class="line">     <span class="number">0.0</span>f,  <span class="number">0.5</span>f, <span class="number">0.0</span>f,  <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f    <span class="comment">// 顶部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于现在有更多的数据要发送到顶点着色器，我们有必要去调整一下顶点着色器，使它能够接收颜色值作为一个顶点属性输入。需要注意的是我们用<code>layout</code>标识符来把aColor属性的位置值设置为1：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;   <span class="comment">// 位置变量的属性位置值为 0 </span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor; <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们不再使用uniform来传递片段的颜色了，现在使用<code>ourColor</code>输出变量，我们必须再修改一下片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;  </span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(ourColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们添加了另一个顶点属性，并且更新了VBO的内存，我们就必须重新配置顶点属性指针。更新后的VBO内存中的数据现在看起来像这样：</p><p><img src="/../images/OpenGL.assets/vertex_attribute_pointer_interleaved.png" alt="img"></p><p>知道了现在使用的布局，我们就可以使用glVertexAttribPointer函数更新顶点格式，</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * sizeof(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 颜色属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * sizeof(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span>* sizeof(<span class="type">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h6 id="着色器源码"><a href="#着色器源码" class="headerlink" title="着色器源码"></a><a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.2.shaders_interpolation/shaders_interpolation.cpp">着色器源码</a></h6><h2 id="我们自己的着色器类"><a href="#我们自己的着色器类" class="headerlink" title="我们自己的着色器类"></a>我们自己的着色器类</h2><p>编写、编译、管理着色器是件麻烦事。在着色器主题的最后，我们会写一个类来让我们的生活轻松一点，它可以从硬盘读取着色器，然后编译并链接它们，并对它们进行错误检测，这就变得很好用了。这也会让你了解该如何封装目前所学的知识到一个抽象对象中。</p><p>我们会把着色器类全部放在在头文件里，主要是为了学习用途，当然也方便移植。我们先来添加必要的include，并定义类结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SHADER_H</span><br><span class="line">#define SHADER_H</span><br><span class="line"></span><br><span class="line">#include &lt;glad/glad.h&gt;; // 包含glad来获取所有的必须OpenGL头文件</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Shader</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // 程序ID</span><br><span class="line">    unsigned int ID;</span><br><span class="line"></span><br><span class="line">    // 构造器读取并构建着色器</span><br><span class="line">    Shader(const GLchar* vertexPath, const GLchar* fragmentPath);</span><br><span class="line">    // 使用/激活程序</span><br><span class="line">    void use();</span><br><span class="line">    // uniform工具函数</span><br><span class="line">    void setBool(const std::string &amp;name, bool value) const;  </span><br><span class="line">    void setInt(const std::string &amp;name, int value) const;   </span><br><span class="line">    void setFloat(const std::string &amp;name, float value) const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>在上面，我们在头文件顶部使用了几个预处理指令(Preprocessor Directives)。这些预处理指令会告知你的编译器只在它没被包含过的情况下才包含和编译这个头文件，即使多个文件都包含了这个着色器头文件。它是用来防止链接冲突的。</p><p>着色器类储存了着色器程序的ID。它的构造器需要顶点和片段着色器源代码的文件路径，这样我们就可以把源码的文本文件储存在硬盘上了。除此之外，为了让我们的生活更轻松一点，还加入了一些工具函数：use用来激活着色器程序，所有的set…函数能够查询一个unform的位置值并设置它的值。</p><h3 id="从文件读取"><a href="#从文件读取" class="headerlink" title="从文件读取"></a>从文件读取</h3><p>我们使用C++文件流读取着色器内容，储存到几个<code>string</code>对象里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Shader(const char* vertexPath, const char* fragmentPath)</span><br><span class="line">&#123;</span><br><span class="line">    // 1. 从文件路径中获取顶点/片段着色器</span><br><span class="line">    std::string vertexCode;</span><br><span class="line">    std::string fragmentCode;</span><br><span class="line">    std::ifstream vShaderFile;</span><br><span class="line">    std::ifstream fShaderFile;</span><br><span class="line">    // 保证ifstream对象可以抛出异常：</span><br><span class="line">    vShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);</span><br><span class="line">    fShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);</span><br><span class="line">    try </span><br><span class="line">    &#123;</span><br><span class="line">        // 打开文件</span><br><span class="line">        vShaderFile.open(vertexPath);</span><br><span class="line">        fShaderFile.open(fragmentPath);</span><br><span class="line">        std::stringstream vShaderStream, fShaderStream;</span><br><span class="line">        // 读取文件的缓冲内容到数据流中</span><br><span class="line">        vShaderStream &lt;&lt; vShaderFile.rdbuf();</span><br><span class="line">        fShaderStream &lt;&lt; fShaderFile.rdbuf();       </span><br><span class="line">        // 关闭文件处理器</span><br><span class="line">        vShaderFile.close();</span><br><span class="line">        fShaderFile.close();</span><br><span class="line">        // 转换数据流到string</span><br><span class="line">        vertexCode   = vShaderStream.str();</span><br><span class="line">        fragmentCode = fShaderStream.str();     </span><br><span class="line">    &#125;</span><br><span class="line">    catch(std::ifstream::failure e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    const char* vShaderCode = vertexCode.c_str();</span><br><span class="line">    const char* fShaderCode = fragmentCode.c_str();</span><br><span class="line">    [...]</span><br></pre></td></tr></table></figure><p>下一步，我们需要编译和链接着色器。注意，我们也将检查编译&#x2F;链接是否失败，如果失败则打印编译时错误，调试的时候这些错误输出会及其重要（你总会需要这些错误日志的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 2. 编译着色器</span><br><span class="line">unsigned int vertex, fragment;</span><br><span class="line">int success;</span><br><span class="line">char infoLog[512];</span><br><span class="line"></span><br><span class="line">// 顶点着色器</span><br><span class="line">vertex = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">glShaderSource(vertex, 1, &amp;vShaderCode, NULL);</span><br><span class="line">glCompileShader(vertex);</span><br><span class="line">// 打印编译错误（如果有的话）</span><br><span class="line">glGetShaderiv(vertex, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">if(!success)</span><br><span class="line">&#123;</span><br><span class="line">    glGetShaderInfoLog(vertex, 512, NULL, infoLog);</span><br><span class="line">    std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 片段着色器也类似</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">// 着色器程序</span><br><span class="line">ID = glCreateProgram();</span><br><span class="line">glAttachShader(ID, vertex);</span><br><span class="line">glAttachShader(ID, fragment);</span><br><span class="line">glLinkProgram(ID);</span><br><span class="line">// 打印连接错误（如果有的话）</span><br><span class="line">glGetProgramiv(ID, GL_LINK_STATUS, &amp;success);</span><br><span class="line">if(!success)</span><br><span class="line">&#123;</span><br><span class="line">    glGetProgramInfoLog(ID, 512, NULL, infoLog);</span><br><span class="line">    std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除着色器，它们已经链接到我们的程序中了，已经不再需要了</span><br><span class="line">glDeleteShader(vertex);</span><br><span class="line">glDeleteShader(fragment);</span><br></pre></td></tr></table></figure><p>use函数非常简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void use() </span><br><span class="line">&#123; </span><br><span class="line">    glUseProgram(ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>uniform的setter函数也很类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void setBool(const std::string &amp;name, bool value) const</span><br><span class="line">&#123;</span><br><span class="line">    glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value); </span><br><span class="line">&#125;</span><br><span class="line">void setInt(const std::string &amp;name, int value) const</span><br><span class="line">&#123; </span><br><span class="line">    glUniform1i(glGetUniformLocation(ID, name.c_str()), value); </span><br><span class="line">&#125;</span><br><span class="line">void setFloat(const std::string &amp;name, float value) const</span><br><span class="line">&#123; </span><br><span class="line">    glUniform1f(glGetUniformLocation(ID, name.c_str()), value); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>现在我们就写完了一个完整的<a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/shader_s.h">着色器类</a>。使用这个着色器类很简单；只要创建一个着色器对象，从那一点开始我们就可以开始使用了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Shader ourShader(&quot;path/to/shaders/shader.vs&quot;, &quot;path/to/shaders/shader.fs&quot;);</span><br><span class="line">...</span><br><span class="line">while(...)</span><br><span class="line">&#123;</span><br><span class="line">    ourShader.use();</span><br><span class="line">    ourShader.setFloat(&quot;someUniform&quot;, 1.0f);</span><br><span class="line">    DrawStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把顶点和片段着色器储存为两个叫做<code>shader.vs</code>和<code>shader.fs</code>的文件。你可以使用自己喜欢的名字命名着色器文件；我自己觉得用<code>.vs</code>和<code>.fs</code>作为扩展名很直观。</p><h6 id="着色器类"><a href="#着色器类" class="headerlink" title="着色器类"></a><a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.3.shaders_class/shaders_class.cpp">着色器类</a></h6><h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p>纹理坐标：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> texCoords[] = &#123;</span><br><span class="line">    <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">0.5</span>f, <span class="number">1.0</span>f <span class="comment">// 上中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>纹理坐标的范围通常是(0, 0)到(1, 1)，当纹理坐标被设置在范围之外：</p><table><thead><tr><th>环绕方式</th><th>描述</th></tr></thead><tbody><tr><td>GL_REPEAT</td><td>对纹理的默认行为。重复纹理图像。</td></tr><tr><td>GL_MIRRORED_REPEAT</td><td>和GL_REPEAT一样，但每次重复图片是镜像放置的。</td></tr><tr><td>GL_CLAMP_TO_EDGE</td><td>纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td></tr><tr><td>GL_CLAMP_TO_BORDER</td><td>超出的坐标为用户指定的边缘颜色。</td></tr></tbody></table><p> <img src="/../images/OpenGL.assets/texture_wrapping.png" alt="img"></p><p>指定环绕方式代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line"><span class="comment">//第一个参数指定的纹理目标(2D)</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br></pre></td></tr></table></figure><p>S和T类似于图形学中讲到的u和v</p><p>如果我们选择GL_CLAMP_TO_BORDER选项，我们还需要指定一个边缘的颜色。这需要使用glTexParameter函数的<code>fv</code>后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> borderColor[] = &#123; <span class="number">1.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f &#125;;</span><br><span class="line">glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure><h3 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h3><p>GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色： <img src="/../images/OpenGL.assets/filter_nearest.png" alt="img"></p><p>GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色： <strong><img src="/../images/OpenGL.assets/filter_linear.png" alt="img"></strong></p><p>当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">//放大（Magnify），缩小（Minify）</span></span><br></pre></td></tr></table></figure><h3 id="多级渐远纹理（Mipmap）"><a href="#多级渐远纹理（Mipmap）" class="headerlink" title="多级渐远纹理（Mipmap）"></a>多级渐远纹理（Mipmap）</h3><p>解决远近不同的物体纹理分辨率不同的问题。</p><p>就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式：</p><table><thead><tr><th>过滤方式</th><th>描述</th></tr></thead><tbody><tr><td>GL_NEAREST_MIPMAP_NEAREST</td><td>使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td></tr><tr><td>GL_LINEAR_MIPMAP_NEAREST</td><td>使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td></tr><tr><td>GL_NEAREST_MIPMAP_LINEAR</td><td>在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td></tr><tr><td>GL_LINEAR_MIPMAP_LINEAR</td><td>在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td></tr></tbody></table><p>就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><p>一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。</p><h3 id="加载于创建纹理"><a href="#加载于创建纹理" class="headerlink" title="加载于创建纹理"></a>加载于创建纹理</h3><h4 id="stb-image-h"><a href="#stb-image-h" class="headerlink" title="stb_image.h"></a>stb_image.h</h4><p><code>stb_image.h</code>是Sean Barrett的一个非常流行的单头文件图像加载库，它能够加载大部分流行的文件格式，并且能够很简单得整合到你的工程之中。<code>stb_image.h</code>可以在<a href="https://github.com/nothings/stb/blob/master/stb_image.h">这里</a>下载。下载这一个头文件，将它以<code>stb_image.h</code>的名字加入你的工程，并另创建一个新的C++文件，输入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define STB_IMAGE_IMPLEMENTATION</span><br><span class="line">#include &quot;stb_image.h&quot;</span><br></pre></td></tr></table></figure><p>通过定义STB_IMAGE_IMPLEMENTATION，预处理器会修改头文件，让其只包含相关的函数定义源码，等于是将这个头文件变为一个 <code>.cpp</code> 文件了。现在只需要在你的程序中包含<code>stb_image.h</code>并编译就可以了。</p><p>下面的教程中，我们会使用一张<a href="https://learnopengl-cn.github.io/img/01/06/container.jpg">木箱</a>的图片。要使用<code>stb_image.h</code>加载图片，我们需要使用它的stbi_load函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int width, height, nrChannels;</span><br><span class="line">unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);</span><br></pre></td></tr></table></figure><p>这个函数首先接受一个图像文件的位置作为输入。接下来它需要三个<code>int</code>作为它的第二、第三和第四个参数，<code>stb_image.h</code>将会用图像的<strong>宽度</strong>、<strong>高度</strong>和<strong>颜色通道的个数</strong>填充这三个变量。我们之后生成纹理的时候会用到的图像的宽度和高度的。</p><h4 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建纹理对象</span></span><br><span class="line">unsigned <span class="type">int</span> <span class="built_in">texture</span>;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;<span class="built_in">texture</span>);</span><br><span class="line"><span class="comment">//绑定纹理对象</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, <span class="built_in">texture</span>);</span><br><span class="line"><span class="comment">//生成纹理</span></span><br><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line"><span class="comment">//释放图像内存</span></span><br><span class="line">stbi_image_free(data);</span><br></pre></td></tr></table></figure><p>glTexImage2D函数的参数详解：</p><ul><li>第一个参数指定了纹理目标(Target)。设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理不会受到影响）。</li><li>第二个参数为纹理指定多级渐远纹理的级别，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填0，也就是基本级别。</li><li>第三个参数告诉OpenGL我们希望把纹理储存为何种格式。我们的图像只有<code>RGB</code>值，因此我们也把纹理储存为<code>RGB</code>值。</li><li>第四个和第五个参数设置最终的纹理的宽度和高度。我们之前加载图像的时候储存了它们，所以我们使用对应的变量。</li><li>下个参数应该总是被设为<code>0</code>（历史遗留的问题）。</li><li>第七第八个参数定义了源图的格式和数据类型。我们使用RGB值加载这个图像，并把它们储存为<code>char</code>(byte)数组，我们将会传入对应值。</li><li>最后一个参数是真正的图像数据。</li></ul><p>当调用glTexImage2D时，当前绑定的纹理对象就会被附加上纹理图像。然而，目前只有基本级别(Base-level)的纹理图像被加载了，如果要使用多级渐远纹理，我们必须手动设置所有不同的图像（不断递增第二个参数）。或者，直接在生成纹理之后调用glGenerateMipmap。这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。</p><p>生成一个纹理完整代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">unsigned <span class="type">int</span> <span class="built_in">texture</span>;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;<span class="built_in">texture</span>);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, <span class="built_in">texture</span>);</span><br><span class="line"><span class="comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   </span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">// 加载并生成纹理</span></span><br><span class="line"><span class="type">int</span> width, height, nrChannels;</span><br><span class="line">unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (data)</span><br><span class="line">&#123;</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">    glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Failed to load <span class="built_in">texture</span>&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">stbi_image_free(data);</span><br></pre></td></tr></table></figure><h4 id="应用纹理"><a href="#应用纹理" class="headerlink" title="应用纹理"></a>应用纹理</h4><p>使用纹理坐标更新顶点数据：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="keyword">vertices</span>[] = &#123;</span><br><span class="line"><span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">     <span class="number">0.5</span>f,  <span class="number">0.5</span>f, <span class="number">0.0</span>f,   <span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="number">0.0</span>f,   <span class="number">1.0</span>f, <span class="number">1.0</span>f,   <span class="comment">// 右上</span></span><br><span class="line">     <span class="number">0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,   <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f,   <span class="number">1.0</span>f, <span class="number">0.0</span>f,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,   <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f,   <span class="number">0.0</span>f, <span class="number">0.0</span>f,   <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">-0.5</span>f,  <span class="number">0.5</span>f, <span class="number">0.0</span>f,   <span class="number">1.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f,   <span class="number">0.0</span>f, <span class="number">1.0</span>f    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/../images/OpenGL.assets/vertex_attribute_pointer_interleaved_textures.png" alt="img"></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * sizeof(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">6</span> * sizeof(<span class="type">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>顶点着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> aTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor;</span><br><span class="line">    TexCoord = aTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> ourTexture;<span class="comment">//传入纹理对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(ourTexture, TexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用glDrawElements之前绑定纹理了，它会自动把纹理赋值给片段着色器的采样器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glBindTexture(GL_TEXTURE_2D, <span class="built_in">texture</span>);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/../images/OpenGL.assets/textures2.png" alt="img"></p><h3 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h3><p>注意上述代码，虽然sampler2D是一个uniform，但是我们却没有给它赋值。</p><p>在阐述上述原因之前，我们需要先知道一些知识。</p><p>纹理单元：一个纹理的位置值。</p><p>纹理单元的主要目的是让我们在着色器中可以使用多余一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。就像glBindTexture一样，我们可以使用glActiveTexture激活纹理单元，传入我们需要使用的纹理单元：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE0); <span class="comment">// 在绑定纹理之前先激活纹理单元</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, <span class="built_in">texture</span>);<span class="comment">// 绑定纹理对象到当前激活的纹理单元</span></span><br></pre></td></tr></table></figure><p>其中，GL_TEXTURE0默认被激活。</p><p>OpenGL至少保证有16个纹理单元可以使用，想要激活其他纹理单元，可以使用变量名字，也可以通过GL_TEXTURE0+n的方式访问。</p><p><code>stb_image.h</code>能够在图像加载时帮助我们翻转y轴，只需要在加载任何图像前加入以下语句即可：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stbi_set_flip_vertically_on_load(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h6 id="纹理源码"><a href="#纹理源码" class="headerlink" title="纹理源码"></a><a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.2.textures_combined/textures_combined.cpp">纹理源码</a></h6><h1 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h1><p>理论教学与图形学中线性代数内容大致相同，详见计算机图形学笔记</p><h3 id="GLM"><a href="#GLM" class="headerlink" title="GLM"></a>GLM</h3><p>GLM是Open<strong>GL</strong> <strong>M</strong>athematics的缩写，它是一个<strong>只有头文件的</strong>库，也就是说我们只需包含对应的头文件就行了，不用链接和编译。GLM可以在它们的<a href="https://glm.g-truc.net/0.9.8/index.html">网站</a>上下载。把头文件的根目录复制到你的<strong>includes</strong>文件夹，然后你就可以使用这个库了。</p><p><strong>注意：GLM库从0.9.9版本起，默认会将矩阵类型初始化为一个零矩阵（所有元素均为0），而不是单位矩阵（对角元素为1，其它元素为0）。如果你使用的是0.9.9或0.9.9以上的版本，你需要将所有的矩阵初始化改为 <code>glm::mat4 mat = glm::mat4(1.0f)</code>。如果你想与本教程的代码保持一致，请使用低于0.9.9版本的GLM，或者改用上述代码初始化所有的矩阵。</strong></p><p>我们需要的GLM的大多数功能都可以从下面这3个头文件中找到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br></pre></td></tr></table></figure><p>将一个向量(1, 0, 0)位移(1, 1, 0)个单位：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义向量vec</span></span><br><span class="line"><span class="function">glm::vec4 <span class="title">vec</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="comment">// 译注：下面就是矩阵初始化的一个例子，如果使用的是0.9.9及以上版本</span></span><br><span class="line"><span class="comment">// 下面这行代码就需要改为:</span></span><br><span class="line"><span class="comment">// glm::mat4 trans = glm::mat4(1.0f)</span></span><br><span class="line"><span class="comment">// 之后将不再进行提示</span></span><br><span class="line"><span class="comment">// 定义单位矩阵mat4(默认是4×4的单位矩阵)</span></span><br><span class="line">glm::mat4 trans;</span><br><span class="line"><span class="comment">// 创建一个变换矩阵</span></span><br><span class="line">trans = glm::<span class="built_in">translate</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">vec = trans * vec;</span><br><span class="line">std::cout &lt;&lt; vec.x &lt;&lt; vec.y &lt;&lt; vec.z &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>旋转和缩放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 trans;</span><br><span class="line">trans = glm::<span class="built_in">rotate</span>(trans, glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">trans = glm::<span class="built_in">scale</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br></pre></td></tr></table></figure><p>shader增加uniform变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">uniform mat4 transform;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = transform * <span class="built_in">vec4</span>(aPos, <span class="number">1.0f</span>);</span><br><span class="line">    TexCoord = <span class="built_in">vec2</span>(aTexCoord.x, <span class="number">1.0</span> - aTexCoord.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把变换矩阵传递给着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> transformLoc = <span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;transform&quot;</span>);</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(transformLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(trans));</span><br></pre></td></tr></table></figure><p>参数二：传入几个矩阵</p><p>参数三：是否对矩阵进行置换</p><p>参数四：真实矩阵数据，由于opengl和glm的矩阵存储形式不同，通过value_ptr进行转换</p><h1 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h1><h2 id="认识3D"><a href="#认识3D" class="headerlink" title="认识3D"></a>认识3D</h2><p>将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System)。将物体的坐标变换到几个<strong>过渡</strong>坐标系(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：</p><ul><li>局部空间(Local Space，或者称为物体空间(Object Space))</li><li>世界空间(World Space)</li><li>观察空间(View Space，或者称为视觉空间(Eye Space))</li><li>裁剪空间(Clip Space)</li><li>屏幕空间(Screen Space)</li></ul><p>将坐标转化为屏幕坐标的过程：</p><p><img src="/../images/OpenGL.assets/coordinate_systems.png" alt="coordinate_systems"></p><ol><li>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</li><li>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li><li>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li><li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</li><li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li></ol><h3 id="局部空间"><a href="#局部空间" class="headerlink" title="局部空间"></a>局部空间</h3><p>我们创建的所有模型可能都以(0, 0, 0)为初始位置，在局部空间中，对于<strong>单个</strong>模型的调整会很方便。</p><h3 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h3><p>指顶点相对于世界的坐标。</p><p>世界空间用于帮助我们描述模型间的位置、朝向等关系。</p><p>从局部坐标到世界坐标的变换由模型矩阵(Model Matrix)来实现。</p><h3 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h3><p>观察空间常被人们称为OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。</p><p>观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。</p><p>这通常是由一系列的位移和旋转的组合来完成，平移&#x2F;旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵(View Matrix)里，它被用来将世界坐标变换到观察空间。</p><h3 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h3><p>在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来。</p><p>因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系，就像OpenGL期望的那样。</p><p>为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection  Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(1250,  500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。</p><p>如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。</p><p>由投影矩阵创建的<strong>观察箱</strong>(Viewing Box)被称为平截头体(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到2D观察空间坐标）被称之为投影(Projection)，因为使用投影矩阵能将3D坐标投影(Project)到很容易映射到2D的标准化设备坐标系中。</p><p>一旦所有顶点被变换到裁剪空间，最终的操作——透视除法(Perspective Division)将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行。</p><p>在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用glViewport中的设定），并被变换成片段。</p><p>将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个正射投影矩阵(Orthographic Projection Matrix)或一个透视投影矩阵(Perspective Projection Matrix)。</p><h3 id="正射投影"><a href="#正射投影" class="headerlink" title="正射投影"></a>正射投影</h3><p> <img src="/../images/OpenGL.assets/orthographic_frustum.png" alt="orthographic projection frustum"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">800.0f</span>, <span class="number">0.0f</span>, <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>前两个参数指定了左右坐标，第三和第四参数指定了底部和顶部。通过这四个参数我们定义了近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离。这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。</p><h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>透视投影矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 proj = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), (<span class="type">float</span>)width/(<span class="type">float</span>)height, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p> 参数一：定义了fov的值，它表示的是视野(Field of View)，并且设置了观察空间的大小。如果想要一个真实的观察效果，它的值通常设置为45.0f，但想要一个末日风格的结果你可以将其设置一个更大的值。</p><p>参数二：设置了宽高比，由视口的宽除以高所得。</p><p>参数三、四：设置了平截头体的<strong>近</strong>和<strong>远</strong>平面。我们通常设置近距离为0.1f，而远距离设为100.0f。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染。</p><img src="../images/OpenGL.assets/perspective_frustum.png" alt=" perspective_frustum" style="zoom:50%;" /><h3 id="把它们组合到一起"><a href="#把它们组合到一起" class="headerlink" title="把它们组合到一起"></a>把它们组合到一起</h3><p>我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标：</p><img src="../images/OpenGL.assets/image-20211014110811181.png" alt="image-20211014110811181" style="zoom:100%;" /><p>注意矩阵运算的顺序是相反的（记住我们需要从右往左阅读矩阵的乘法）。最后的顶点应该被赋值到顶点着色器中的gl_Position，OpenGL将会自动进行透视除法和裁剪。</p><h2 id="进入3D"><a href="#进入3D" class="headerlink" title="进入3D"></a>进入3D</h2><p>创建一个模型矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 model;</span><br><span class="line">model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(<span class="number">-55.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><p>创建一个观察矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view;</span><br><span class="line"><span class="comment">// 注意，我们将矩阵向我们要进行移动场景的反方向移动。</span></span><br><span class="line">view = glm::<span class="built_in">translate</span>(view, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-3.0f</span>));</span><br></pre></td></tr></table></figure><p>创建一个投影矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 projection;</span><br><span class="line">projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), screenWidth / screenHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>既然我们已经创建了变换矩阵，我们应该将它们传入着色器。首先，让我们在顶点着色器中声明一个uniform变换矩阵然后将它乘以顶点坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">...</span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意乘法要从右向左读</span></span><br><span class="line">    gl_Position = projection * view * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还应该将矩阵传入着色器（这通常在每次的渲染迭代中进行，因为变换矩阵会经常变动）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> modelLoc = <span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;model&quot;</span>));</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(modelLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(model));</span><br><span class="line">... <span class="comment">// 观察矩阵和投影矩阵与之类似</span></span><br></pre></td></tr></table></figure><h3 id="更多3D"><a href="#更多3D" class="headerlink" title="更多3D"></a>更多3D</h3><p>要想渲染一个立方体，我们一共需要36个顶点（6个面 x 每个面有2个三角形组成 x 每个三角形有3个顶点），这36个顶点的位置你可以从<a href="https://learnopengl.com/code_viewer.php?code=getting-started/cube_vertices">这里</a>获取。</p><p>为了有趣一点，我们将让立方体随着时间旋转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = glm::rotate(model, (float)glfwGetTime() * glm::radians(50.0f), glm::vec3(0.5f, 1.0f, 0.0f));</span><br></pre></td></tr></table></figure><p>然后我们使用glDrawArrays来绘制立方体，但这一次总共有36个顶点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br></pre></td></tr></table></figure><p>为了让OpenGL知道何时应该覆盖像素，我们可以利用Z缓冲。</p><h4 id="Z缓冲"><a href="#Z缓冲" class="headerlink" title="Z缓冲"></a>Z缓冲</h4><p>具体概念图形学教程中有详细提到。</p><p>在OpenGL中，该过程被称为深度测试（Depth Testing），它是由OpenGL自动完成的。</p><p>深度测试默认是关闭的，可以通过glEnable和glDisable函数启用或者禁用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure><h4 id="更多的立方体！"><a href="#更多的立方体！" class="headerlink" title="更多的立方体！"></a>更多的立方体！</h4><p>首先，让我们为每个立方体定义一个位移向量来指定它在世界空间的位置。我们将在一个<code>glm::vec3</code>数组中定义10个立方体位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cubePositions[] = &#123;</span><br><span class="line">  glm::<span class="built_in">vec3</span>( <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>), </span><br><span class="line">  glm::<span class="built_in">vec3</span>( <span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>), </span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),  </span><br><span class="line">  glm::<span class="built_in">vec3</span>( <span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),  </span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),  </span><br><span class="line">  glm::<span class="built_in">vec3</span>( <span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">  glm::<span class="built_in">vec3</span>( <span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>), </span><br><span class="line">  glm::<span class="built_in">vec3</span>( <span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>), </span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，在游戏循环中，我们调用glDrawArrays 10次，但这次在我们渲染之前每次传入一个不同的模型矩阵到顶点着色器中。我们将会在游戏循环中创建一个小的循环用不同的模型矩阵渲染我们的物体10次。注意我们也对每个箱子加了一点旋转：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  glm::mat4 model;</span><br><span class="line">  model = glm::<span class="built_in">translate</span>(model, cubePositions[i]);</span><br><span class="line">  <span class="type">float</span> angle = <span class="number">20.0f</span> * i; </span><br><span class="line">  model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">  ourShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="坐标系统源码"><a href="#坐标系统源码" class="headerlink" title="坐标系统源码"></a><a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/6.3.coordinate_systems_multiple/coordinate_systems_multiple.cpp">坐标系统源码</a></h6><h1 id="摄像机"><a href="#摄像机" class="headerlink" title="摄像机"></a>摄像机</h1><h2 id="摄像机-x2F-观察空间"><a href="#摄像机-x2F-观察空间" class="headerlink" title="摄像机&#x2F;观察空间"></a>摄像机&#x2F;观察空间</h2><p>OpenGL本身没有摄像机(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。</p><p>当我们讨论摄像机&#x2F;观察空间(Camera&#x2F;View  Space)的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。要定义一个摄像机，我们需要它在世界空间中的位置、观察的方向、一个指向它右测的向量以及一个指向它上方的向量。细心的读者可能已经注意到我们实际上创建了一个三个单位轴相互垂直的、以摄像机的位置为原点的坐标系。</p><p><img src="/../images/OpenGL.assets/camera_axes.png" alt="img"></p><p>注意：摄像机的方向虽然是正的，但是实际指向的是z轴负半轴</p><h3 id="1-摄像机位置"><a href="#1-摄像机位置" class="headerlink" title="1.摄像机位置"></a>1.摄像机位置</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br></pre></td></tr></table></figure><h3 id="2-摄像机方向"><a href="#2-摄像机方向" class="headerlink" title="2.摄像机方向"></a>2.摄像机方向</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraTarget = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glm::vec3 cameraDirection = glm::<span class="built_in">normalize</span>(cameraPos - cameraTarget);</span><br></pre></td></tr></table></figure><h3 id="3-右轴"><a href="#3-右轴" class="headerlink" title="3.右轴"></a>3.右轴</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 up = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>); </span><br><span class="line">glm::vec3 cameraRight = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(up, cameraDirection));</span><br></pre></td></tr></table></figure><h3 id="4-上轴"><a href="#4-上轴" class="headerlink" title="4.上轴"></a>4.上轴</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraUp = glm::<span class="built_in">cross</span>(cameraDirection, cameraRight);</span><br></pre></td></tr></table></figure><h2 id="Look-At"><a href="#Look-At" class="headerlink" title="Look At"></a>Look At</h2><p>使用矩阵的好处之一是如果你使用3个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这3个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是<strong>LookAt</strong>矩阵所做的，现在我们有了3个相互垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建我们自己的LookAt矩阵了：</p><img src="../images/OpenGL.assets/image-20211018194926535.png" alt="image-20211018194926535" style="zoom:80%;" /><p>其中<em>R</em>是右向量，<em>U</em>是上向量，<em>D</em>是方向向量<em>P</em>是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向。把这个LookAt矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。LookAt矩阵就像它的名字表达的那样：它会创建一个看着(Look at)给定目标的观察矩阵。</p><p>幸运的是，GLM已经提供了这些支持。我们要做的只是定义一个摄像机位置，一个目标位置和一个表示世界空间中的上向量的向量（我们计算右向量使用的那个上向量）。接着GLM就会创建一个LookAt矩阵，我们可以把它当作我们的观察矩阵：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), </span><br><span class="line">           glm::vec3(0.0f, 0.0f, 0.0f), </span><br><span class="line">           glm::vec3(0.0f, 1.0f, 0.0f));</span><br></pre></td></tr></table></figure><p>glm::LookAt函数需要一个位置、目标和上向量。它会创建一个和在上一节使用的一样的观察矩阵。</p><p>在讨论用户输入之前，我们先来做些有意思的事，把我们的摄像机在场景中旋转。我们会将摄像机的注视点保持在(0, 0, 0)。</p><p>我们需要用到一点三角学的知识来在每一帧创建一个x和z坐标，它会代表圆上的一点，我们将会使用它作为摄像机的位置。通过重新计算x和y坐标，我们会遍历圆上的所有点，这样摄像机就会绕着场景旋转了。我们预先定义这个圆的半径radius，在每次渲染迭代中使用GLFW的glfwGetTime函数重新创建观察矩阵，来扩大这个圆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> radius = <span class="number">10.0f</span>;</span><br><span class="line"><span class="type">float</span> camX = <span class="built_in">sin</span>(<span class="built_in">glfwGetTime</span>()) * radius;</span><br><span class="line"><span class="type">float</span> camZ = <span class="built_in">cos</span>(<span class="built_in">glfwGetTime</span>()) * radius;</span><br><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(camX, <span class="number">0.0</span>, camZ), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)); </span><br></pre></td></tr></table></figure><h2 id="自由移动"><a href="#自由移动" class="headerlink" title="自由移动"></a>自由移动</h2><p>先定义一些变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos   = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="number">3.0f</span>);</span><br><span class="line">glm::vec3 cameraFront = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glm::vec3 cameraUp    = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>,  <span class="number">0.0f</span>);</span><br></pre></td></tr></table></figure><p><code>LookAt</code>函数现在成了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view = glm::<span class="built_in">lookAt</span>(cameraPos, cameraPos + cameraFront, cameraUp);</span><br></pre></td></tr></table></figure><p>按键反馈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">float</span> cameraSpeed = <span class="number">0.05f</span>; <span class="comment">// adjust accordingly</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_W) == GLFW_PRESS)</span><br><span class="line">        cameraPos += cameraSpeed * cameraFront;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_S) == GLFW_PRESS)</span><br><span class="line">        cameraPos -= cameraSpeed * cameraFront;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_A) == GLFW_PRESS)</span><br><span class="line">        cameraPos -= glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_D) == GLFW_PRESS)</span><br><span class="line">        cameraPos += glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移动速度"><a href="#移动速度" class="headerlink" title="移动速度"></a>移动速度</h2><p>和Unity的Update函数类似，每一帧的刷新速度会根据电脑性能而产生些微不同，因此，在OpenGL中，我们采用计时的方式处理。</p><p>我们跟踪两个全局变量来计算出deltaTime值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float deltaTime = 0.0f; // 当前帧与上一帧的时间差</span><br><span class="line">float lastFrame = 0.0f; // 上一帧的时间</span><br></pre></td></tr></table></figure><p>在每一帧中我们计算出新的deltaTime以备后用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float currentFrame = glfwGetTime();</span><br><span class="line">deltaTime = currentFrame - lastFrame;</span><br><span class="line">lastFrame = currentFrame;</span><br></pre></td></tr></table></figure><p>现在我们有了deltaTime，在计算速度的时候可以将其考虑进去了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">float</span> cameraSpeed = <span class="number">2.5f</span> * deltaTime;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视角移动"><a href="#视角移动" class="headerlink" title="视角移动"></a>视角移动</h2><p>为了能改变视角，我们需要根据鼠标的输入改变cameraFront的值</p><h3 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h3><p>欧拉角(Euler Angle)是可以表示3D空间中任何旋转的3个值，由莱昂哈德·欧拉(Leonhard Euler)在18世纪提出。一共有3种欧拉角：俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)，下面的图片展示了它们的含义：</p><p><img src="/../images/OpenGL.assets/camera_pitch_yaw_roll.png" alt="img"></p><p>俯仰角是描述我们如何往上或往下看的角，可以在第一张图中看到。第二张图展示了偏航角，偏航角表示我们往左和往右看的程度。滚转角代表我们如何<strong>翻滚</strong>摄像机，通常在太空飞船的摄像机中使用。每个欧拉角都有一个值来表示，把三个角结合起来我们就能够计算3D空间中任何的旋转向量了。</p><p>对于我们的摄像机系统来说，我们只关心俯仰角和偏航角，所以我们不会讨论滚转角。给定一个俯仰角和偏航角，我们可以把它们转换为一个代表新的方向向量的3D向量。俯仰角和偏航角转换为方向向量的处理需要一些三角学知识，我们先从最基本的情况开始：</p><p><img src="/../images/OpenGL.assets/camera_triangle.png" alt="img"></p><p>如果我们把斜边边长定义为1，我们就能知道邻边的长度是cos <em>x</em>&#x2F;<em>h</em>&#x3D;cos <em>x</em>&#x2F;1&#x3D;cos <em>x</em></p><p>，它的对边是sin <em>y</em>&#x2F;<em>h</em>&#x3D;sin <em>y</em>&#x2F;1&#x3D;sin <em>y</em></p><p>。这样我们获得了能够得到x和y方向长度的通用公式，它们取决于所给的角度。我们使用它来计算方向向量的分量：</p><p><img src="/../images/OpenGL.assets/camera_pitch.png" alt="img"></p><p>这个三角形看起来和前面的三角形很像，所以如果我们想象自己在xz平面上，看向y轴，我们可以基于第一个三角形计算来计算它的长度&#x2F;y方向的强度(Strength)（我们往上或往下看多少）。从图中我们可以看到对于一个给定俯仰角的y值等于sin <em>θ</em></p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">direction.y = sin(glm::radians(pitch)); // 注意我们先把角度转为弧度</span><br></pre></td></tr></table></figure><p>这里我们只更新了y值，仔细观察x和z分量也被影响了。从三角形中我们可以看到它们的值等于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">direction.x = cos(glm::radians(pitch));</span><br><span class="line">direction.z = cos(glm::radians(pitch));</span><br></pre></td></tr></table></figure><p>看看我们是否能够为偏航角找到需要的分量：</p><p><img src="/../images/OpenGL.assets/camera_yaw.png" alt="img"></p><p>就像俯仰角的三角形一样，我们可以看到x分量取决于<code>cos(yaw)</code>的值，z值同样取决于偏航角的正弦值。把这个加到前面的值中，会得到基于俯仰角和偏航角的方向向量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">direction.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw)); <span class="comment">// 译注：direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的</span></span><br><span class="line">direction.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw));</span><br></pre></td></tr></table></figure><h3 id="鼠标输入"><a href="#鼠标输入" class="headerlink" title="鼠标输入"></a>鼠标输入</h3><p>隐藏光标，并捕捉(Capture)它。捕捉光标表示的是，如果焦点在你的程序上（译注：即表示你正在操作这个程序，Windows中拥有焦点的程序标题栏通常是有颜色的那个，而失去焦点的程序标题栏则是灰色的），光标应该停留在窗口中（除非程序失去焦点或者退出）。我们可以用一个简单地配置调用来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwSetInputMode</span>(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br></pre></td></tr></table></figure><p>为了计算俯仰角和偏航角，我们需要让GLFW监听鼠标移动事件。（和键盘输入相似）我们会用一个回调函数来完成，函数的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void mouse_callback(GLFWwindow* window, double xpos, double ypos);</span><br></pre></td></tr></table></figure><p>这里的xpos和ypos代表当前鼠标的位置。当我们用GLFW注册了回调函数之后，鼠标一移动mouse_callback函数就会被调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetCursorPosCallback(window, mouse_callback);</span><br></pre></td></tr></table></figure><p>在处理FPS风格摄像机的鼠标输入的时候，我们必须在最终获取方向向量之前做下面这几步：</p><ol><li>计算鼠标距上一帧的偏移量。</li><li>把偏移量添加到摄像机的俯仰角和偏航角中。</li><li>对偏航角和俯仰角进行最大和最小值的限制。</li><li>计算方向向量。</li></ol><p>第一步是计算鼠标自上一帧的偏移量。我们必须先在程序中储存上一帧的鼠标位置，我们把它的初始值设置为屏幕的中心（屏幕的尺寸是800x600）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> lastX = <span class="number">400</span>, lastY = <span class="number">300</span>;</span><br></pre></td></tr></table></figure><p>然后在鼠标的回调函数中我们计算当前帧和上一帧鼠标位置的偏移量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> xoffset = xpos - lastX;</span><br><span class="line"><span class="type">float</span> yoffset = lastY - ypos; <span class="comment">// 注意这里是相反的，因为y坐标是从底部往顶部依次增大的</span></span><br><span class="line">lastX = xpos;</span><br><span class="line">lastY = ypos;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> sensitivity = <span class="number">0.05f</span>;</span><br><span class="line">xoffset *= sensitivity;</span><br><span class="line">yoffset *= sensitivity;</span><br></pre></td></tr></table></figure><p>注意我们把偏移量乘以了sensitivity（灵敏度）值。如果我们忽略这个值，鼠标移动就会太大了；你可以自己实验一下，找到适合自己的灵敏度值。</p><p>接下来我们把偏移量加到全局变量pitch和yaw上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yaw   += xoffset;</span><br><span class="line">pitch += yoffset;</span><br></pre></td></tr></table></figure><p>第三步，我们需要给摄像机添加一些限制，这样摄像机就不会发生奇怪的移动了（这样也会避免一些奇怪的问题）。对于俯仰角，要让用户不能看向高于89度的地方（在90度时视角会发生逆转，所以我们把89度作为极限），同样也不允许小于-89度。这样能够保证用户只能看到天空或脚下，但是不能超越这个限制。我们可以在值超过限制的时候将其改为极限值来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">  pitch =  <span class="number">89.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">  pitch = <span class="number">-89.0f</span>;</span><br></pre></td></tr></table></figure><p>注意我们没有给偏航角设置限制，这是因为我们不希望限制用户的水平旋转。当然，给偏航角设置限制也很容易，如果你愿意可以自己实现。</p><p>第四也是最后一步，就是通过俯仰角和偏航角来计算以得到真正的方向向量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 front;</span><br><span class="line">front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw));</span><br><span class="line">front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">front.z = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw));</span><br><span class="line">cameraFront = glm::<span class="built_in">normalize</span>(front);</span><br></pre></td></tr></table></figure><p>计算出来的方向向量就会包含根据鼠标移动计算出来的所有旋转了。由于cameraFront向量已经包含在GLM的lookAt函数中。</p><p>最后的代码应该是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(firstMouse)</span><br><span class="line">    &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">        firstMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> xoffset = xpos - lastX;</span><br><span class="line">    <span class="type">float</span> yoffset = lastY - ypos; </span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> sensitivity = <span class="number">0.05</span>;</span><br><span class="line">    xoffset *= sensitivity;</span><br><span class="line">    yoffset *= sensitivity;</span><br><span class="line"></span><br><span class="line">    yaw   += xoffset;</span><br><span class="line">    pitch += yoffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">        pitch = <span class="number">89.0f</span>;</span><br><span class="line">    <span class="keyword">if</span>(pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">        pitch = <span class="number">-89.0f</span>;</span><br><span class="line"></span><br><span class="line">    glm::vec3 front;</span><br><span class="line">    front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    front.z = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    cameraFront = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xoffset, <span class="type">double</span> yoffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(fov &gt;= <span class="number">1.0f</span> &amp;&amp; fov &lt;= <span class="number">45.0f</span>)</span><br><span class="line">    fov -= yoffset;</span><br><span class="line">  <span class="keyword">if</span>(fov &lt;= <span class="number">1.0f</span>)</span><br><span class="line">    fov = <span class="number">1.0f</span>;</span><br><span class="line">  <span class="keyword">if</span>(fov &gt;= <span class="number">45.0f</span>)</span><br><span class="line">    fov = <span class="number">45.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(fov), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>注册滚轮回调函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwSetScrollCallback</span>(window, scroll_callback);</span><br></pre></td></tr></table></figure><h2 id="摄像机类"><a href="#摄像机类" class="headerlink" title="摄像机类"></a>摄像机类</h2><p><a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/camera.h">摄像机类</a></p><p><a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/7.4.camera_class/camera_class.cpp">使用摄像机类的源码</a></p><h1 id="GLUT-amp-GLUI配置及基础教程"><a href="#GLUT-amp-GLUI配置及基础教程" class="headerlink" title="GLUT &amp; GLUI配置及基础教程"></a>GLUT &amp; GLUI配置及基础教程</h1><p><a href="https://zhuanlan.zhihu.com/p/125686181">GLUT参考教程</a></p><h1 id="GLUI"><a href="#GLUI" class="headerlink" title="GLUI"></a>GLUI</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>GLUI是一个C++界面库，它提供了buttons, checkboxes, radio buttons, 等常用控件，以及OPENGL支持。GLUI界面系统依赖于GLUT来处理窗口、和鼠标管理等，而绘制部分采用OPENGL绘制。</p><h2 id="窗体初始化"><a href="#窗体初始化" class="headerlink" title="窗体初始化"></a>窗体初始化</h2><p>GLUI包含三个主要的类:<br>      GLUI_Master_Object<br>      GLUI<br>      GLUI_Control</p><h3 id="get-version"><a href="#get-version" class="headerlink" title=".get_version()"></a>.get_version()</h3><p>float version &#x3D; GLUI_Master.get_version();</p><p>获取当前版本号</p><h3 id="create-glui"><a href="#create-glui" class="headerlink" title=".create_glui"></a>.create_glui</h3><p>创建一个新的窗口</p><p>GLUI *GLUI_Master_Object::create_glui(char *name, int flags &#x3D; 0, int x &#x3D; -1, int y &#x3D; -1)</p><p>参数：</p><p>name:GLUI窗口的名字.<br> flags:初始化标记,如果没有给出此参数则默认值为0,被定义为在当前版本中.</p><p>x,y:初始化窗口的坐标.此参数可以不给出,因为GLUI可以自动调整窗口大小以适应所有的控件.</p><p>返回值:<br>新的GLUI窗口的指针</p><h3 id="create-glui-subwindow"><a href="#create-glui-subwindow" class="headerlink" title=".create_glui_subwindow"></a>.create_glui_subwindow</h3><p>在已经存在的GLUT窗口中创建一个新的子窗口</p><p>GLUI *GLUI_Master_Object::create_glui_subwindow(int window, int position)</p><p> 参数:<br>window:新建GLUI窗口的父窗口(一个已经存在的GLUT窗口)的ID号.<br>position:子窗口相对于父窗口的位置,可以为以下的值:<br>           GLUI_SUBWINDOW_RIGHT<br>           GLUI_SUBWINDOW_LEFT<br>           GLUI_SUBWINDOW_TOP<br>           GLUI_SUBWINDOW_BOTTOM<br> (注:可以在同一个位置创建任意个数的子窗口,多个相同位置的子窗口会简单的相互叠加,如:两个子窗口都使用了GLUI_SUBWINDOW_TOP参数,这两个子窗口都会定位在父窗口之上,同时,第一个子窗口也会覆盖在第二个子窗口之上.)</p><p> 返回值:<br> 新建的子窗口的指针.</p><h3 id="set-glutIdleFunc"><a href="#set-glutIdleFunc" class="headerlink" title=".set_glutIdleFunc"></a>.set_glutIdleFunc</h3><p>为GLUI注册一个标准的GLUT空闲回调函数。</p><p>创建一个回调函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main_window;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myGlutIdle</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//被注册的空闲回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">glutGetWindow</span>() != main_window)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">glutSetWindow</span>(main_window);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">glutPostRedisplay</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 用法:<br> void GLUI_Master_Object::set_glutIdleFunc(void (*f)(void))<br> 参数:<br> f(void):被注册的空闲回调函数.</p><h4 id="其他回调函数"><a href="#其他回调函数" class="headerlink" title="其他回调函数"></a>其他回调函数</h4><p>set_glutReshapeFunc<br>set_glutKeyboardFunc<br>set_glutMouseFunc<br>set_glutSpecialFunc<br> 用法:<br>void GLUT_Master_Object::set_glutReshapeFunc(void (*f)(int width, int height));<br>void GLUT_Master_Object::set_glutKeyboardFunc(void (*f)(unsigned char key, int x, int y));<br>void GLUT_Master_Object::set_glutMouseFunc(void (*f)(int button, int state, int x,int y));<br>void GLUI_Master_Object::set_glutSpecialFunc(void (*f)(int key, int x, int y));</p><h3 id="set-main-gfx-window"><a href="#set-main-gfx-window" class="headerlink" title="set_main_gfx_window"></a>set_main_gfx_window</h3><p>将一个GLUT窗口与一个GLUI窗口捆绑,当这个GLUI窗口中的一个控件的值发生改变,则该GLUT窗口将会被重绘.<br> 用法:<br> void GLUI::set_main_gfx_window(int window_id);<br> 参数:<br> window_id:被绑定的GLUT窗口ID,此ID号可在GLUT窗口被创建时获得(即glutCreateWindow()的返回值),或通过glutGetWindow()的返回值获得.</p><h2 id="窗体视口管理"><a href="#窗体视口管理" class="headerlink" title="窗体视口管理"></a>窗体视口管理</h2><h3 id="get-viewport-area"><a href="#get-viewport-area" class="headerlink" title=".get_viewport_area"></a>.get_viewport_area</h3><p>获取当前窗口父窗口可绘区域的左上角坐标和尺寸</p><p> 用法：void GLUI_Master_Object::auto_set_viewport(void);</p><h3 id="auto-set-viewport"><a href="#auto-set-viewport" class="headerlink" title=".auto_set_viewport"></a>.auto_set_viewport</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y, w, h;</span><br><span class="line">GLUI_Master.<span class="built_in">get_viewport_area</span>(&amp;x, &amp;y, &amp;w, &amp;h);</span><br><span class="line"><span class="built_in">glViewport</span>(x, y, w, h);</span><br></pre></td></tr></table></figure><p>以上三句的功能与下面一句等价.<br> GLUI_Master.auto_set_viewport();</p><h2 id="窗体管理"><a href="#窗体管理" class="headerlink" title="窗体管理"></a>窗体管理</h2><h3 id="get-glut-window-id"><a href="#get-glut-window-id" class="headerlink" title="get_glut_window_id"></a>get_glut_window_id</h3><p>返回一个GLUI窗口的窗口ID<br> 用法:int GLUI::get_glut_window_id(void);<br> 返回值:GLUI窗口的ID号</p><h3 id="enable-disable"><a href="#enable-disable" class="headerlink" title="enable, disable"></a>enable, disable</h3><p>使GLUI窗口可用或不可用,当一个GLUI窗口不可用时,其上的所有控件都不可用.<br> 用法:<br> void GLUI::enable(void);<br> void GLUI::disable(void);</p><h3 id="hide"><a href="#hide" class="headerlink" title="hide"></a>hide</h3><p>使GLUI窗口或子窗口隐藏.一个被隐藏的窗口或子窗口不能接受任何用户输入.<br> 用法:void GLUI::hide(void);</p><h3 id="show"><a href="#show" class="headerlink" title="show"></a>show</h3><p>使一个被隐藏的窗口或子窗口可见.<br> 用法:void GLUI::show(void);</p><h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><p>销毁一个GLUI窗口或子窗口.<br> 用法: void GLUI::close(void);</p><h3 id="close-all"><a href="#close-all" class="headerlink" title="close_all"></a>close_all</h3><p>销毁所有的GLUI窗口和子窗口.此函数应该被全局对象所调用如:GLUI_Master.close_all();<br> 用法:void GLUI_Master_Object::close_all(void);</p><h3 id="sync-live"><a href="#sync-live" class="headerlink" title="sync_live"></a>sync_live</h3><p>变量可以与控件相关联,该函数可以使一个GLUI窗口上的所有控件和与这些控件相关联的变量保持同步,也即:读取变量的值,然后根据该值设置与其相关联的控件,使该值在控件上反映出来<br> 用法:void GLUI::sync_live(void);</p><h3 id="sync-live-all"><a href="#sync-live-all" class="headerlink" title="sync_live_all"></a>sync_live_all</h3><p>使所有GLUI窗口上的所有控件与与其相关联的变量保持同步,这个函数必须通过全局对象调用,如:GLUI_Master.sync_live_all();<br> 用法:void GLUI_Master_Object::sync_live_all(void);</p><h2 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h2><p>GLUI中,所有的控件都是源于GLUI_Control类</p><h3 id="创建控件"><a href="#创建控件" class="headerlink" title="创建控件"></a>创建控件</h3><p>1、add_control() 直接将控件放在窗口之上</p><p>2、add_control_to_panel()将控件置于panel之内</p><p>panel是一个可以内置其他控件的容器，panel也可以置于另一个panel之内</p><h3 id="公共函数"><a href="#公共函数" class="headerlink" title="公共函数"></a>公共函数</h3><h4 id="set-name"><a href="#set-name" class="headerlink" title="set_name"></a>set_name</h4><p>为button,checkbox等控件设置名字.<br> 用法: void GLUI_Control::set_name(char *name);<br> 参数: name:控件的名字(即:在控件上或控件旁显示的文字)</p><h4 id="set-w-set-h"><a href="#set-w-set-h" class="headerlink" title="set_w, set_h"></a>set_w, set_h</h4><p>设置控件的最小宽度或高度<br> 用法:<br> void GLUI_Control::set_w(int new_size);<br> void GLUI_Control::set_h(int new_size);<br> 参数:<br> new_size:控件的最小宽度或高度.</p><h4 id="get-set"><a href="#get-set" class="headerlink" title="get, set"></a>get, set</h4><p>int GLUI_Control::get_int_val(void);<br>float GLUI_Control::get_float_val(void);<br>void GLUI_Control::get_float_array_val(float *float_array_ptr);<br>char *GLUI_Control::get_text(void);<br>void GLUI_Control::set_int_val(int int_val);<br>void GLUI_Control::set_float_val(float float_val);<br>void GLUI_Control::set_float_array_val(float *float_array_val);<br>void GLUI_Control::set_text(char *text);<br>(根据控件对输入输出数据值类型的要求,选取相应的函数)</p><h4 id="disable-enable"><a href="#disable-enable" class="headerlink" title="disable, enable"></a>disable, enable</h4><p>使控件可用或不可用,radio group不可用时,其中的button也不可用,panel不可用时,其中的所有控件都不可用.<br> 用法:<br> void GLUI_Control::enable(void);<br> void GLUI_Control::disable(void);</p><h4 id="set-alignment"><a href="#set-alignment" class="headerlink" title="set_alignment"></a>set_alignment</h4><p>设置控件的对齐方式(居左,居中,居右)<br>用法:<br>void GLUI_Control::set_alignment(int align);<br>参数:<br>align:对齐方式.可选下面之一:<br>       GLUI_ALIGN_CENTER<br>       GLUI_ALIGN_RIGHT<br>       GLUI_ALIGN_LEFT</p><h3 id="Panels"><a href="#Panels" class="headerlink" title="Panels"></a>Panels</h3><p>一个容器，可以内置其他控件，也可以内置另一个panel</p><h4 id="add-panel"><a href="#add-panel" class="headerlink" title="add_panel"></a>add_panel</h4><p>在GLUI窗口上新建一个panel控件.<br> 用法:GLUI_Panel *GLUI::add_panel(char *name, int type &#x3D; GLUI_PANEL_EMBOSSED);</p><h4 id="add-panel-to-panel"><a href="#add-panel-to-panel" class="headerlink" title="add_panel_to_panel"></a>add_panel_to_panel</h4><p>在另一个panel之内新建一个panel控件.<br>用法:GLUI_Panel *GLUI::add_panel_to_panel(GLUI_Panel *panel, char *name, int type &#x3D; GLUI_PANEL_EMBOSSED);</p><p>参数:</p><p>name:panel控件的名字(可以为空,如若指定了名字,会在panel的左上角显示).</p><p>type:panel的样式.<br>       GLUI_PANEL_EMBOSSED:用内嵌的线条画一个矩形框(默认值).<br>       GLUI_PANEL_RAISED:用外凸的线条画一个矩形框,不显示名字.<br>       GLUI_PANEL_NONE:不绘制矩形框,只用来将控件组织成一个控件组.<br>panel:指向另一个panel控件的指针.新建的panel控件将会置于该panel之中.</p><h3 id="Rollouts"><a href="#Rollouts" class="headerlink" title="Rollouts"></a>Rollouts</h3><p>类似于panel也是一个容器,功能上可以与panel互相替代,不同之处在于该控件可以被折叠起来,此时其内置的控件不可见,只有当其展开后,内置控件才可见.</p><h4 id="add-rollout"><a href="#add-rollout" class="headerlink" title="add_rollout"></a>add_rollout</h4><p>在GLUI窗口中新建rollout控件.<br> 用法:GLUI_Rollout *GLUI::add_rollout(char *name, int open &#x3D; true);</p><h4 id="add-rollout-to-panel"><a href="#add-rollout-to-panel" class="headerlink" title="add_rollout_to_panel"></a>add_rollout_to_panel</h4><p>在另一个已经存在的rollout或panel中新建一个rollout控件.<br> 用法:GLUI_Rollout *GLUI::add_rollout_to_panel(GLUI_Panel *panel, char *name, int open &#x3D; true);</p><p>参数:<br>name:控件的名字.<br>open:如果为true,则rollout初始设置为打开;如果为false,则初始设置为闭合.<br>panel:指向另一个panel或rollout控件的指针.新建的rollout控件将会置于该panel或rollout之中.</p><p>返回值:<br>新建rollout控件的指针.</p><h3 id="Columns"><a href="#Columns" class="headerlink" title="Columns"></a>Columns</h3><p>控件在GLUI窗口中的布局是按照控件定义的顺序自上而下放置的,在竖直方向上形成一个控件列,而column则会开辟一个新的控件列(即在旧的控件列的右侧新建一个新的控件列),其后所定义的控件将置于该新建的控件列中(即在新的控件列中自上而下布局),直至新的控件列被创建.</p><h4 id="add-column"><a href="#add-column" class="headerlink" title="add_column"></a>add_column</h4><p>在GLUI窗口上新建column.<br> 用法:void GLUI::add_column(int draw_bar &#x3D; true);</p><h4 id="add-column-to-panel"><a href="#add-column-to-panel" class="headerlink" title="add_column_to_panel"></a>add_column_to_panel</h4><p>在panel中新建column.<br>用法:void GLUI::add_column_to_panel(GLUI_Panel *panel, int draw_bar &#x3D; true);</p><p>参数:<br>draw_bar:如果为true,则在新建控件列时,会绘制一条竖线将其与原先的控件列区分开;如为false,则只创建控件列,不绘制竖线.<br>panel:指向一个panel控件的指针.新建的column控件将会置于该panel之中.</p><h3 id="Buttons"><a href="#Buttons" class="headerlink" title="Buttons"></a>Buttons</h3><p>按钮</p><h4 id="add-button"><a href="#add-button" class="headerlink" title="add_button"></a>add_button</h4><p>在GLUI窗口上直接新建按钮.<br> 用法:GLUI_Button *GLUI::add_button(char *name, int id &#x3D; -1, GLUI_Update_CB callback &#x3D; NULL);</p><h4 id="add-button-to-panel"><a href="#add-button-to-panel" class="headerlink" title="add_button_to_panel"></a>add_button_to_panel</h4><p>在一个已经存在的panel中创建按钮.<br> 用法:GLUI_Button *GLUI::add_button_to_panel(GLUI_Panel *panel,char *name,int id &#x3D; -1,GLUI_Update_CB callback &#x3D; NULL);</p><p>参数:<br>name:按钮的名字,即在按钮上显示的文字.<br>id:按钮的ID值.如果callback被定义了,则当callback被调用时,id值会作为参数传递给callback.<br>callback:接受一个整形参数的callback函数.当按钮被触发时,它会被调用.<br>panel:指向一个panel控件的指针.新建的button控件将会置于该panel之中.</p><p>返回值:<br>新建的按钮控件的指针.</p><h3 id="Checkboxes"><a href="#Checkboxes" class="headerlink" title="Checkboxes"></a>Checkboxes</h3><p>复选框</p><h4 id="add-checkbox"><a href="#add-checkbox" class="headerlink" title="add_checkbox"></a>add_checkbox</h4><p>在GLUI窗口上直接创建新的checkbox.<br> 用法:GLUI_Checkbox *GLUI::add_checkbox(char *name, int *live_var &#x3D; NULL, int id &#x3D; -1,GLUI_Update_CB callback &#x3D; NULL);</p><h4 id="add-checkbox-to-panel"><a href="#add-checkbox-to-panel" class="headerlink" title="add_checkbox_to_panel"></a>add_checkbox_to_panel</h4><p>在已经存在的panel中创建新的checkbox.<br>用法:GLUI_Checkbox *GLUI::add_check_to_panel(GLUI_Panel *panel, char *name, int *live_var &#x3D; NULL, int id &#x3D; -1, GLUI_Update_CB callback &#x3D; NULL);</p><p>参数:<br>name:checkbox的名字.<br>live_var:与控件checkbox相关联的整形指针,当checkbox控件状态发生变化时,该整形值会自动更新.<br>id:复选框的ID值.如果callback被定义了,则当callback被调用时,id值会作为参数传递给callback.<br>callback:接受一个整形参数的callback函数.当按复选框触发时,它会被调用.<br>panel:指向一个panel控件的指针.新建的checkbox控件将会置于该panel之中.</p><p>返回值:新建的checkbox控件的指针.</p><h1 id="以下为光照模块"><a href="#以下为光照模块" class="headerlink" title="以下为光照模块"></a>以下为光照模块</h1><h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><p>颜色可以数字化地由RGB三个分量组成</p><p>例如，获取一个珊瑚红(Coral)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">coral</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>现实生活中，我们所看到的某一物体的颜色并不是这个物体真正拥有的颜色，而是它所反射的(reflected)的颜色，换句话说，就是不能被物体所吸收的颜色。</p> <img src="../images/OpenGL.assets/light_reflection.png" alt="img" style="zoom:80%;" /><p>由图可知，白色的阳光其实是所有可见颜色的集合，物体吸收了其中的大部分颜色，它仅反射了代表物体颜色的部分，被反射颜色的组合就是我们所感知到的颜色</p><p>换句话说，光照的结果，其实就是光源的颜色和物体颜色的乘积，结果就是最终的颜色向量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">lightColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">toyColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>)</span></span>;</span><br><span class="line">glm::vec3 result = lightColor * toyColor; <span class="comment">// = (1.0f, 0.5f, 0.31f);</span></span><br></pre></td></tr></table></figure><h2 id="创建一个光照场景"><a href="#创建一个光照场景" class="headerlink" title="创建一个光照场景"></a>创建一个光照场景</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Lua</title>
      <link href="/posts/ee3c71cb/"/>
      <url>/posts/ee3c71cb/</url>
      
        <content type="html"><![CDATA[<h1 id="Lua基本语法"><a href="#Lua基本语法" class="headerlink" title="Lua基本语法"></a>Lua基本语法</h1><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br></pre></td></tr></table></figure><p>代码存储在 .lua 结尾的文件中</p><p>可以在命令行中输入lua hello.lua 来执行脚本</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>单行注释：两个减号–</p><p>多行注释：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">代码</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h4 id="标示符"><a href="#标示符" class="headerlink" title="标示符"></a>标示符</h4><p>用于定义一个变量</p><p>不允许使用特殊字符定义标示符</p><p>大小写敏感</p><h4 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h4><table><thead><tr><th>and</th><th>break</th><th>do</th><th>else</th></tr></thead><tbody><tr><td>elseif</td><td>end</td><td>false</td><td>for</td></tr><tr><td>function</td><td>if</td><td>in</td><td>local</td></tr><tr><td>nil</td><td>not</td><td>or</td><td>repeat</td></tr><tr><td>return</td><td>then</td><td>true</td><td>until</td></tr><tr><td>while</td><td>goto</td><td></td><td></td></tr></tbody></table><p>一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 <strong>Lua 内部全局变量</strong>。</p><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>在默认的情况下，变量总是认为是全局的</p><p>给一个全局变量赋值后即创建了这个全局变量</p><p>访问一个没有初始化的全局变量不会出错，只是会得到nil的结果</p><p>想要删除一个全局变量，将变量赋值为nil即可</p><h1 id="Lua数据类型"><a href="#Lua数据类型" class="headerlink" title="Lua数据类型"></a>Lua数据类型</h1><p>Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>nil</td><td>这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td></tr><tr><td>boolean</td><td>包含两个值：false和true。</td></tr><tr><td>number</td><td>表示双精度类型的实浮点数</td></tr><tr><td>string</td><td>字符串由一对双引号或单引号来表示</td></tr><tr><td>function</td><td>由 C 或 Lua 编写的函数</td></tr><tr><td>userdata</td><td>表示任意存储在变量中的C数据结构</td></tr><tr><td>thread</td><td>表示执行的独立线路，用于执行协同程序</td></tr><tr><td>table</td><td>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td></tr></tbody></table><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;Hello world&quot;</span>))      <span class="comment">--&gt; string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">10.4</span>*<span class="number">3</span>))             <span class="comment">--&gt; number</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">print</span>))              <span class="comment">--&gt; function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>))               <span class="comment">--&gt; function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">true</span>))               <span class="comment">--&gt; boolean</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">nil</span>))                <span class="comment">--&gt; nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(X)))            <span class="comment">--&gt; string</span></span><br></pre></td></tr></table></figure><h4 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h4><p>表示没有任何有效值</p><p>nil作比较时应该加上双引号””</p><h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><p>false：nil和false</p><p>true：除了false以外的所有，包括数字0</p><h4 id="number"><a href="#number" class="headerlink" title="number"></a>number</h4><p>即double</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2.2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0.2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2e+1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0.2e-1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">7.8263692594256e-06</span>))</span><br></pre></td></tr></table></figure><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>可用单双引号表示：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string1 = <span class="string">&quot;this is string1&quot;</span></span><br><span class="line">string2 = <span class="string">&#x27;this is string2&#x27;</span></span><br></pre></td></tr></table></figure><p>也可用2个方括号表示一块字符串</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">[[</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;a href=&quot;http://www.runoob.com/&quot;&gt;菜鸟教程&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"><span class="built_in">print</span>(html)</span><br></pre></td></tr></table></figure><p>在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字</p><p>lua中字符串相加，不能用+，而是用..</p><p>两个字符串不可相加，使用 # 来计算字符串的长度，放在字符串前面</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">len</span> = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">&gt; <span class="built_in">print</span>(#<span class="built_in">len</span>)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><h4 id="table-表"><a href="#table-表" class="headerlink" title="table(表)"></a>table(表)</h4><p>table的创建通过构造表达式</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个空的 table</span></span><br><span class="line"><span class="keyword">local</span> tbl1 = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 直接初始表</span></span><br><span class="line"><span class="keyword">local</span> tbl2 = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- table_test.lua 脚本文件</span></span><br><span class="line">a = &#123;&#125;</span><br><span class="line">a[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;value&quot;</span></span><br><span class="line">key = <span class="number">10</span></span><br><span class="line">a[key] = <span class="number">22</span></span><br><span class="line">a[key] = a[key] + <span class="number">11</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">&quot; : &quot;</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在lua中，默认索引一般从1开始</p><p>table不会固定长度，有新数据添加时，table长度会自动增加</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- table_test3.lua 脚本文件</span></span><br><span class="line">a3 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">    a3[i] = i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a3[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;val&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a3[<span class="string">&quot;key&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(a3[<span class="string">&quot;none&quot;</span>])</span><br></pre></td></tr></table></figure><h4 id="function-函数"><a href="#function-函数" class="headerlink" title="function(函数)"></a>function(函数)</h4><p>在 Lua 中，函数是被看作是”第一类值（First-Class Value）”，函数可以存在变量里</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- function_test.lua 脚本文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial1</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * factorial1(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(factorial1(<span class="number">5</span>))</span><br><span class="line">factorial2 = factorial1</span><br><span class="line"><span class="built_in">print</span>(factorial2(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>function可以通过匿名函数的方式通过参数传递</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- function_test2.lua 脚本文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFun</span><span class="params">(tab,fun)</span></span></span><br><span class="line">        <span class="keyword">for</span> k ,v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab) <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">print</span>(fun(k,v));</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tab=&#123;key1=<span class="string">&quot;val1&quot;</span>,key2=<span class="string">&quot;val2&quot;</span>&#125;;</span><br><span class="line">testFun(tab,</span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="params">(key,val)</span></span><span class="comment">--匿名函数</span></span><br><span class="line">        <span class="keyword">return</span> key..<span class="string">&quot;=&quot;</span>..val;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="thread-线程"><a href="#thread-线程" class="headerlink" title="thread(线程)"></a>thread(线程)</h4><p>在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。</p><p>线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。</p><h4 id="userdata-自定义类型"><a href="#userdata-自定义类型" class="headerlink" title="userdata(自定义类型)"></a>userdata(自定义类型)</h4><p>userdata 是一种用户自定义数据，用于表示一种由应用程序或 C&#x2F;C++ 语言库所创建的类型，可以将任意 C&#x2F;C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。</p><h1 id="Lua变量"><a href="#Lua变量" class="headerlink" title="Lua变量"></a>Lua变量</h1><p>Lua 变量有三种类型：全局变量、局部变量、表中的域。</p><p>Lua中的变量全是默认全是全局变量，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量。</p><p>局部变量的作用域从为从声明位置开始到所在语句块结束</p><p>变量的默认值均为nil</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test.lua 文件脚本</span></span><br><span class="line">a = <span class="number">5</span>               <span class="comment">-- 全局变量</span></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">5</span>         <span class="comment">-- 局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joke</span><span class="params">()</span></span></span><br><span class="line">    c = <span class="number">5</span>           <span class="comment">-- 全局变量</span></span><br><span class="line">    <span class="keyword">local</span> d = <span class="number">6</span>     <span class="comment">-- 局部变量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">joke()</span><br><span class="line"><span class="built_in">print</span>(c,d)          <span class="comment">--&gt; 5 nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">6</span>     <span class="comment">-- 局部变量</span></span><br><span class="line">    b = <span class="number">6</span>           <span class="comment">-- 对局部变量重新赋值</span></span><br><span class="line">    <span class="built_in">print</span>(a,b);     <span class="comment">--&gt; 6 6</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a,b)      <span class="comment">--&gt; 5 6</span></span><br></pre></td></tr></table></figure><h4 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h4><p>Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">10</span>, <span class="number">2</span> * x</span><br><span class="line"><span class="comment">--上下两行一致</span></span><br><span class="line">a = <span class="number">10</span>; b = <span class="number">2</span> * x</span><br></pre></td></tr></table></figure><p>遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x                     <span class="comment">-- swap &#x27;x&#x27; for &#x27;y&#x27;</span></span><br><span class="line">a[i], a[j] = a[j], a[i]         <span class="comment">-- swap &#x27;a[i]&#x27; for &#x27;a[j]&#x27;</span></span><br></pre></td></tr></table></figure><p>当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a. 变量个数 &gt; 值的个数             按变量个数补足<span class="literal">nil</span></span><br><span class="line">b. 变量个数 &lt; 值的个数             多余的值会被忽略</span><br></pre></td></tr></table></figure><p>多值赋值经常用来交换变量，或将函数调用返回给变量：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = f()</span><br></pre></td></tr></table></figure><p>f()返回两个值，第一个赋给a，第二个赋给b。</p><p>应该尽可能的使用局部变量，有两个好处：</p><ul><li><ol><li>避免命名冲突。</li></ol></li><li><ol start="2"><li>访问局部变量的速度比全局变量更快。</li></ol></li></ul><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>对table的索引使用方括号[]，Lua也提供了.操作</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; site = &#123;&#125;</span><br><span class="line">&gt; site[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">&gt; <span class="built_in">print</span>(site[<span class="string">&quot;key&quot;</span>])</span><br><span class="line">www.runoob.com</span><br><span class="line">&gt; <span class="built_in">print</span>(site.key)</span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure><h1 id="Lua循环"><a href="#Lua循环" class="headerlink" title="Lua循环"></a>Lua循环</h1><table><thead><tr><th>循环类型</th><th>描述</th></tr></thead><tbody><tr><td>while 循环</td><td>在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。</td></tr><tr><td>for 循环</td><td>重复执行指定语句，重复次数可在 for 语句中控制。</td></tr><tr><td>repeat…until</td><td>重复执行循环，直到 指定的条件为真时为止</td></tr><tr><td>循环嵌套</td><td>可以在循环内嵌套一个或多个循环语句（while do … end;for … do … end;repeat … until;）</td></tr></tbody></table><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   statements</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><h5 id="数值for循环"><a href="#数值for循环" class="headerlink" title="数值for循环"></a>数值for循环</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var=exp1,exp2,exp3 <span class="keyword">do</span>  </span><br><span class="line">    &lt;执行体&gt;  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 “执行体”。exp3 是可选的，如果不指定，默认为1。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,f(x) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">10</span>,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>for的三个表达式在循环开始前一次性求值，以后不再进行求值。比如上面的f(x)只会在循环开始前执行一次，其结果用在后面的循环中。</p><h5 id="泛型for循环"><a href="#泛型for循环" class="headerlink" title="泛型for循环"></a>泛型for循环</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--打印数组a的所有值  </span></span><br><span class="line">a = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure><p>i是数组索引值，v是对应索引的数组元素值。ipairs是Lua提供的一个迭代器函数，用来迭代数组。</p><h4 id="Lua-repeat…until-循环"><a href="#Lua-repeat…until-循环" class="headerlink" title="Lua repeat…until 循环"></a>Lua repeat…until 循环</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   statements</span><br><span class="line"><span class="keyword">until</span>( condition )</span><br></pre></td></tr></table></figure><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><table><thead><tr><th>控制语句</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/lua/lua-break-statement.html">break 语句</a></td><td>退出当前循环或语句，并开始脚本执行紧接着的语句。</td></tr><tr><td><a href="https://www.runoob.com/lua/lua-goto.html">goto 语句</a></td><td>将程序的控制点转移到一个标签处。</td></tr></tbody></table><p>goto实例</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line">::label:: <span class="built_in">print</span>(<span class="string">&quot;--- goto label ---&quot;</span>)</span><br><span class="line"></span><br><span class="line">a = a+<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> a &lt; <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">goto</span> label   <span class="comment">-- a 小于 3 的时候跳转到标签 label</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="Lua流程控制"><a href="#Lua流程控制" class="headerlink" title="Lua流程控制"></a>Lua流程控制</h1><table><thead><tr><th>语句</th><th>描述</th></tr></thead><tbody><tr><td>if 语句</td><td><strong>if 语句</strong> 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。</td></tr><tr><td>if…else 语句</td><td><strong>if 语句</strong> 可以与 <strong>else 语句</strong>搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码。</td></tr><tr><td>if 嵌套语句</td><td>你可以在<strong>if</strong> 或 <strong>else if</strong>中使用一个或多个 <strong>if</strong> 或 <strong>else if</strong> 语句 。</td></tr></tbody></table><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式为 true 时执行的语句 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( 布尔表达式 <span class="number">1</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 1 为 true 时执行该语句块 --]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elseif</span>( 布尔表达式 <span class="number">2</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 2 为 true 时执行该语句块 --]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elseif</span>( 布尔表达式 <span class="number">3</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 3 为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="comment">--[ 如果以上布尔表达式都不为 true 则执行该语句块 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="Lua函数"><a href="#Lua函数" class="headerlink" title="Lua函数"></a>Lua函数</h1><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optional_function_scope <span class="function"><span class="keyword">function</span> <span class="title">function_name</span><span class="params">( argument1, argument2, argument3..., argumentn)</span></span></span><br><span class="line">    function_body</span><br><span class="line">    <span class="keyword">return</span> result_params_comma_separated</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>optional_function_scope:</strong> 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 <strong>local</strong>。</p><p><strong>function_name:</strong> 指定函数名称。</p><p><strong>argument1, argument2, argument3…, argumentn:</strong> 函数参数，多个参数以逗号隔开，函数也可以不带参数。</p><p><strong>function_body:</strong> 函数体，函数中需要执行的代码语句块。</p><p><strong>result_params_comma_separated:</strong> 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。</p><h4 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h4><p>Lua函数中，在return后列出要返回的值的列表即可返回多值，如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maximum</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">local</span> mi = <span class="number">1</span>             <span class="comment">-- 最大值索引</span></span><br><span class="line">    <span class="keyword">local</span> m = a[mi]          <span class="comment">-- 最大值</span></span><br><span class="line">    <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">       <span class="keyword">if</span> val &gt; m <span class="keyword">then</span></span><br><span class="line">           mi = i</span><br><span class="line">           m = val</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> m, mi</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(maximum(&#123;<span class="number">8</span>,<span class="number">10</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">5</span>&#125;))</span><br></pre></td></tr></table></figure><p>执行结果为：23    3</p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>在函数参数列表中使用三点 …  表示函数有可变的参数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(...)</span></span>  </span><br><span class="line"><span class="keyword">local</span> s = <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>&#123;...&#125; <span class="keyword">do</span>   <span class="comment">--&gt; &#123;...&#125; 表示一个由所有变长参数构成的数组  </span></span><br><span class="line">    s = s + v  </span><br><span class="line">  <span class="keyword">end</span>  </span><br><span class="line">  <span class="keyword">return</span> s  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>))  <span class="comment">---&gt;25</span></span><br></pre></td></tr></table></figure><p>我们可以将可变参数赋值给一个变量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span><span class="params">(...)</span></span></span><br><span class="line">   result = <span class="number">0</span></span><br><span class="line">   <span class="keyword">local</span> <span class="built_in">arg</span>=&#123;...&#125;    <span class="comment">--&gt; arg 为一个表，局部变量</span></span><br><span class="line">   <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">arg</span>) <span class="keyword">do</span></span><br><span class="line">      result = result + v</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;总共传入 &quot;</span> .. #<span class="built_in">arg</span> .. <span class="string">&quot; 个数&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> result/#<span class="built_in">arg</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;平均值为&quot;</span>,average(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure><p>我们也可以通过 select(“#”,…) 来获取可变参数的数量:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span><span class="params">(...)</span></span></span><br><span class="line">   result = <span class="number">0</span></span><br><span class="line">   <span class="keyword">local</span> <span class="built_in">arg</span>=&#123;...&#125;</span><br><span class="line">   <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">arg</span>) <span class="keyword">do</span></span><br><span class="line">      result = result + v</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;总共传入 &quot;</span> .. <span class="built_in">select</span>(<span class="string">&quot;#&quot;</span>,...) .. <span class="string">&quot; 个数&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> result/<span class="built_in">select</span>(<span class="string">&quot;#&quot;</span>,...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;平均值为&quot;</span>,average(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure><p>有时候我们可能需要几个固定参数加上可变参数，固定参数必须放在变长参数之前:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fwrite</span><span class="params">(fmt, ...)</span></span>  <span class="comment">---&gt; 固定的参数fmt</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(fmt, ...))    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">fwrite(<span class="string">&quot;runoob\n&quot;</span>)       <span class="comment">---&gt;fmt = &quot;runoob&quot;, 没有变长参数。  </span></span><br><span class="line">fwrite(<span class="string">&quot;%d%d\n&quot;</span>, <span class="number">1</span>, <span class="number">2</span>)   <span class="comment">---&gt;fmt = &quot;%d%d&quot;, 变长参数为 1 和 2</span></span><br></pre></td></tr></table></figure><p>通常在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 <strong>select</strong> 函数来访问变长参数了：<strong>select(‘#’, …)</strong> 或者 <strong>select(n, …)</strong></p><ul><li>select(‘#’, …) 返回可变参数的长度。</li><li>select(n, …) 用于返回从起点 <strong>n</strong> 开始到结束位置的所有参数列表。</li></ul><p>调用 select 时，必须传入一个固定实参 selector(选择开关) 和一系列变长参数。如果 selector 为数字 n，那么 select 返回参数列表中从索引 <strong>n</strong> 开始到结束位置的所有参数列表，否则只能为字符串 #，这样 select 返回变长参数的总数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(...)</span></span></span><br><span class="line">    a = <span class="built_in">select</span>(<span class="number">3</span>,...)  <span class="comment">--&gt;从第三个位置开始，变量 a 对应右边变量列表的第一个参数</span></span><br><span class="line">    <span class="built_in">print</span> (a)</span><br><span class="line">    <span class="built_in">print</span> (<span class="built_in">select</span>(<span class="number">3</span>,...)) <span class="comment">--&gt;打印所有列表参数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h1 id="Lua运算符"><a href="#Lua运算符" class="headerlink" title="Lua运算符"></a>Lua运算符</h1><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>下表列出了 Lua 语言中的常用算术运算符，设定 A 的值为10，B 的值为 20：</p><table><thead><tr><th>操作符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>加法</td><td>A + B 输出结果 30</td></tr><tr><td>-</td><td>减法</td><td>A - B 输出结果 -10</td></tr><tr><td>*</td><td>乘法</td><td>A * B 输出结果 200</td></tr><tr><td>&#x2F;</td><td>除法</td><td>B &#x2F; A 输出结果 2</td></tr><tr><td>%</td><td>取余</td><td>B % A 输出结果 0</td></tr><tr><td>^</td><td>乘幂</td><td>A^2 输出结果 100</td></tr><tr><td>-</td><td>负号</td><td>-A 输出结果 -10</td></tr><tr><td>&#x2F;&#x2F;</td><td>整除运算符(&gt;&#x3D;lua5.3)</td><td>5&#x2F;&#x2F;2 输出结果 2</td></tr></tbody></table><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>下表列出了 Lua 语言中的常用关系运算符，设定 A 的值为10，B 的值为 20：</p><table><thead><tr><th>操作符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>等于，检测两个值是否相等，相等返回 true，否则返回 false</td><td>(A &#x3D;&#x3D; B) 为 false。</td></tr><tr><td>~&#x3D;</td><td>不等于，检测两个值是否相等，不相等返回 true，否则返回 false</td><td>(A ~&#x3D; B) 为 true。</td></tr><tr><td>&gt;</td><td>大于，如果左边的值大于右边的值，返回 true，否则返回 false</td><td>(A &gt; B) 为 false。</td></tr><tr><td>&lt;</td><td>小于，如果左边的值大于右边的值，返回 false，否则返回 true</td><td>(A &lt; B) 为 true。</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false</td><td>(A &gt;&#x3D; B) 返回 false。</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false</td><td>(A &lt;&#x3D; B) 返回 true。</td></tr></tbody></table><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>下表列出了 Lua 语言中的常用逻辑运算符，设定 A 的值为 true，B 的值为 false：</p><table><thead><tr><th>操作符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>and</td><td>逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。</td><td>(A and B) 为 false。</td></tr><tr><td>or</td><td>逻辑或操作符。  若 A 为 true，则返回 A，否则返回 B。</td><td>(A or B) 为 true。</td></tr><tr><td>not</td><td>逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。</td><td>not(A and B) 为 true。</td></tr></tbody></table><h4 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h4><p>下表列出了 Lua 语言中的连接运算符与计算表或字符串长度的运算符：</p><table><thead><tr><th>操作符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>..</td><td>连接两个字符串</td><td>a..b ，其中 a 为 “Hello “ ， b 为 “World”, 输出结果为 “Hello World”。</td></tr><tr><td>#</td><td>一元运算符，返回字符串或表的长度。</td><td>#”Hello” 返回 5</td></tr></tbody></table><h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>从高到低</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">^</span><br><span class="line"><span class="keyword">not</span>    - (unary)</span><br><span class="line">*      /       %</span><br><span class="line">+      -</span><br><span class="line">..</span><br><span class="line">&lt;      &gt;      &lt;=     &gt;=     ~=     ==</span><br><span class="line"><span class="keyword">and</span></span><br><span class="line"><span class="keyword">or</span></span><br></pre></td></tr></table></figure><h1 id="Lua字符串"><a href="#Lua字符串" class="headerlink" title="Lua字符串"></a>Lua字符串</h1><p>Lua 语言中字符串可以使用以下三种方式来表示：</p><ul><li>单引号间的一串字符。</li><li>双引号间的一串字符。</li><li><strong>[[</strong> 与 <strong>]]</strong> 间的一串字符。</li></ul><table><thead><tr><th>转义字符</th><th>意义</th><th>ASCII码值（十进制）</th></tr></thead><tbody><tr><td>\a</td><td>响铃(BEL)</td><td>007</td></tr><tr><td>\b</td><td>退格(BS) ，将当前位置移到前一列</td><td>008</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头</td><td>012</td></tr><tr><td>\n</td><td>换行(LF) ，将当前位置移到下一行开头</td><td>010</td></tr><tr><td>\r</td><td>回车(CR) ，将当前位置移到本行开头</td><td>013</td></tr><tr><td>\t</td><td>水平制表(HT) （跳到下一个TAB位置）</td><td>009</td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td>\</td><td>代表一个反斜线字符’’&#39;</td><td>092</td></tr><tr><td>&#39;</td><td>代表一个单引号（撇号）字符</td><td>039</td></tr><tr><td>&quot;</td><td>代表一个双引号字符</td><td>034</td></tr><tr><td>\0</td><td>空字符(NULL)</td><td>000</td></tr><tr><td>\ddd</td><td>1到3位八进制数所代表的任意字符</td><td>三位八进制</td></tr><tr><td>\xhh</td><td>1到2位十六进制所代表的任意字符</td><td>二位十六进制</td></tr></tbody></table><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><table><thead><tr><th>序号</th><th>方法 &amp; 用途</th></tr></thead><tbody><tr><td>1</td><td><strong>string.upper(argument):</strong> 字符串全部转为大写字母。</td></tr><tr><td>2</td><td><strong>string.lower(argument):</strong> 字符串全部转为小写字母。</td></tr><tr><td>3</td><td>**string.gsub(mainString,findString,replaceString,num)**在字符串中替换。 mainString 为要操作的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换），如： <code>&gt; string.gsub(&quot;aaaa&quot;,&quot;a&quot;,&quot;z&quot;,3); zzza  3</code></td></tr><tr><td>4</td><td><strong>string.find (str, substr, [init, [end]])</strong>  在一个指定的目标字符串 str 中搜索指定的内容 substr，如果找到了一个匹配的子串，就会返回这个子串的起始索引和结束索引，不存在则返回 nil。  以下实例查找字符串 “Lua” 的起始索引和结束索引位置： <code>&gt; string.find(&quot;Hello Lua user&quot;, &quot;Lua&quot;, 1)  7  9</code></td></tr><tr><td>5</td><td><strong>string.reverse(arg)</strong> 字符串反转<code>&gt; string.reverse(&quot;Lua&quot;) auL</code></td></tr><tr><td>6</td><td><strong>string.format(…)</strong> 返回一个类似printf的格式化字符串 <code>&gt; string.format(&quot;the value is:%d&quot;,4) the value is:4</code></td></tr><tr><td>7</td><td><strong>string.char(arg) 和 string.byte(arg[,int])</strong> char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。 <code>&gt; string.char(97,98,99,100) abcd &gt; string.byte(&quot;ABCD&quot;,4) 68 &gt; string.byte(&quot;ABCD&quot;) 65 &gt;</code></td></tr><tr><td>8</td><td><strong>string.len(arg)</strong> 计算字符串长度。 <code>string.len(&quot;abc&quot;) 3</code></td></tr><tr><td>9</td><td><strong>string.rep(string, n)</strong> 返回字符串string的n个拷贝 <code>&gt; string.rep(&quot;abcd&quot;,2) abcdabcd</code></td></tr><tr><td>10</td><td><strong>..</strong> 链接两个字符串 <code>&gt; print(&quot;www.runoob.&quot;..&quot;com&quot;) www.runoob.com</code></td></tr><tr><td>11</td><td><strong>string.gmatch(str, pattern)</strong> 返回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。 <code>&gt; for word in string.gmatch(&quot;Hello Lua user&quot;, &quot;%a+&quot;) do print(word) end Hello Lua user</code></td></tr><tr><td>12</td><td><strong>string.match(str, pattern, init)</strong> string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。   在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。 <code>&gt; = string.match(&quot;I have 2 questions for you.&quot;, &quot;%d+ %a+&quot;) 2 questions &gt; = string.format(&quot;%d, %q&quot;, string.match(&quot;I have 2 questions for you.&quot;, &quot;(%d+) (%a+)&quot;)) 2, &quot;questions&quot;</code></td></tr></tbody></table><h4 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h4><p>字符串截取使用 sub() 方法。</p><p>string.sub() 用于截取字符串，原型为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.sub(s, i [, j])</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>s：要截取的字符串。</li><li>i：截取开始位置。</li><li>j：截取结束位置，默认为 -1，最后一个字符。</li></ul><h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h4><p>Lua 提供了 string.format() 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。</p><p>由于格式字符串的存在, 使得产生的长字符串可读性大大提高了。这个函数的格式很像 C 语言中的 printf()。</p><p>以下实例演示了如何对字符串进行格式化操作：</p><p>格式字符串可能包含以下的转义码:</p><ul><li>%c - 接受一个数字, 并将其转化为ASCII码表中对应的字符</li><li>%d, %i - 接受一个数字并将其转化为有符号的整数格式</li><li>%o - 接受一个数字并将其转化为八进制数格式</li><li>%u - 接受一个数字并将其转化为无符号整数格式</li><li>%x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母</li><li>%X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母</li><li>%e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e</li><li>%E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E</li><li>%f - 接受一个数字并将其转化为浮点数格式</li><li>%g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式</li><li>%q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式</li><li>%s - 接受一个字符串并按照给定的参数格式化该字符串</li></ul><p>为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:</p><ul><li>(1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.</li><li>(2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.</li><li>(3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.</li><li>(4) 宽度数值</li><li>(5) 小数位数&#x2F;字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位.</li></ul><h4 id="字符串格式化-常用函数-匹配模式"><a href="#字符串格式化-常用函数-匹配模式" class="headerlink" title="字符串格式化+常用函数+匹配模式"></a><a href="https://www.runoob.com/lua/lua-strings.html">字符串格式化+常用函数+匹配模式</a></h4><h1 id="Lua数组"><a href="#Lua数组" class="headerlink" title="Lua数组"></a>Lua数组</h1><p>数组索引值可以为负</p><p>多维数组举例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 初始化数组</span></span><br><span class="line">array = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">   array[i] = &#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> j=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">         array[i][j] = i*j</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 访问数组</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">   <span class="keyword">for</span> j=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">      <span class="built_in">print</span>(array[i][j])</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="Lua迭代器"><a href="#Lua迭代器" class="headerlink" title="Lua迭代器"></a>Lua迭代器</h1><p>泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。</p><p>泛型 for 迭代器提供了集合的 key&#x2F;value 对，语法格式如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k, v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面代码中，k, v为变量列表；pairs(t)为表达式列表。</p><h4 id="无状态的迭代器"><a href="#无状态的迭代器" class="headerlink" title="无状态的迭代器"></a>无状态的迭代器</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span><span class="params">(iteratorMaxCount,currentNumber)</span></span></span><br><span class="line">   <span class="keyword">if</span> currentNumber&lt;iteratorMaxCount</span><br><span class="line">   <span class="keyword">then</span></span><br><span class="line">      currentNumber = currentNumber+<span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> currentNumber, currentNumber*currentNumber</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,n <span class="keyword">in</span> square,<span class="number">3</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(i,n)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iter</span> <span class="params">(a, i)</span></span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">local</span> v = a[i]</span><br><span class="line">    <span class="keyword">if</span> v <span class="keyword">then</span></span><br><span class="line">       <span class="keyword">return</span> i, v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ipairs</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">return</span> iter, a, <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当 Lua 调用 ipairs(a) 开始循环时，他获取三个值：迭代函数 iter、状态常量 a、控制变量初始值 0；然后 Lua 调用  iter(a,0) 返回 1, a[1]（除非 a[1]&#x3D;nil）；第二次迭代调用 iter(a,1) 返回 2, a[2]……直到第一个  nil 元素。</p><h4 id="多状态的迭代器"><a href="#多状态的迭代器" class="headerlink" title="多状态的迭代器"></a>多状态的迭代器</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">array = &#123;<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">elementIterator</span> <span class="params">(collection)</span></span></span><br><span class="line">   <span class="keyword">local</span> index = <span class="number">0</span></span><br><span class="line">   <span class="keyword">local</span> count = #collection</span><br><span class="line">   <span class="comment">-- 闭包函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">      index = index + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> index &lt;= count</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">         <span class="comment">--  返回迭代器的当前元素</span></span><br><span class="line">         <span class="keyword">return</span> collection[index]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elementIterator(array)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="Lua-table-表"><a href="#Lua-table-表" class="headerlink" title="Lua table(表)"></a>Lua table(表)</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 初始化表</span></span><br><span class="line">mytable = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定值</span></span><br><span class="line">mytable[<span class="number">1</span>]= <span class="string">&quot;Lua&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 移除引用</span></span><br><span class="line">mytable = <span class="literal">nil</span></span><br><span class="line"><span class="comment">-- lua 垃圾回收会释放内存</span></span><br></pre></td></tr></table></figure><h4 id="Table操作"><a href="#Table操作" class="headerlink" title="Table操作"></a>Table操作</h4><table><thead><tr><th>序号</th><th>方法 &amp; 用途</th></tr></thead><tbody><tr><td>1</td><td>**table.concat (table [, sep [, start [, end]]]):**concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。</td></tr><tr><td>2</td><td>**table.insert (table, [pos,] value):**在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.</td></tr><tr><td>3</td><td>**table.maxn (table)**指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(<strong>Lua5.2之后该方法已经不存在了,本文使用了自定义函数实现</strong>)</td></tr><tr><td>4</td><td>**table.remove (table [, pos])**返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。</td></tr><tr><td>5</td><td>**table.sort (table [, comp])**对给定的table进行升序排序。</td></tr></tbody></table><p><strong>注意：</strong></p><p>当我们获取 table 的长度的时候无论是使用 # 还是 table.getn 其都会在索引中断的地方停止计数，而导致无法正确取得 table 的长度。</p><p>可以使用以下方法来代替：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table_leng</span><span class="params">(t)</span></span></span><br><span class="line">  <span class="keyword">local</span> leng=<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    leng=leng+<span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> leng;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="Lua模块与包"><a href="#Lua模块与包" class="headerlink" title="Lua模块与包"></a>Lua模块与包</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 文件名为 module.lua</span></span><br><span class="line"><span class="comment">-- 定义一个名为 module 的模块</span></span><br><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 定义一个常量</span></span><br><span class="line"><span class="built_in">module</span>.constant = <span class="string">&quot;这是一个常量&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func1</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;这是一个公有函数！\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一个私有函数！&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func3</span><span class="params">()</span></span></span><br><span class="line">    func2()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure><p>由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。</p><p>上面的 func2 声明为程序块的局部变量，即表示一个私有函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的公有函数来调用.</p><h4 id="require函数"><a href="#require函数" class="headerlink" title="require函数"></a>require函数</h4><p>Lua提供了一个名为require的函数用来加载模块</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;&lt;模块名&gt;&quot;</span>)</span><br><span class="line"><span class="comment">--或者</span></span><br><span class="line"><span class="built_in">require</span> <span class="string">&quot;&lt;模块名&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>执行 require 后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test_module.lua 文件</span></span><br><span class="line"><span class="comment">-- module 模块为上文提到到 module.lua</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">module</span>.constant)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">module</span>.func3()</span><br></pre></td></tr></table></figure><p>或者给加载的模块定义一个别名变量，方便调用：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test_module2.lua 文件</span></span><br><span class="line"><span class="comment">-- module 模块为上文提到到 module.lua</span></span><br><span class="line"><span class="comment">-- 别名变量 m</span></span><br><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(m.constant)</span><br><span class="line"> </span><br><span class="line">m.func3()</span><br></pre></td></tr></table></figure><h4 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h4><p>对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。</p><p>require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。</p><p>当然，如果没有 LUA_PATH 这个环境变量，也可以自定义设置，在当前用户根目录下打开 .profile 文件（没有则创建，打开 .bashrc 文件也可以），例如把 “~&#x2F;lua&#x2F;“ 路径加入 LUA_PATH 环境变量里：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#LUA_PATH</span><br><span class="line">export LUA_PATH=<span class="string">&quot;~/lua/?.lua;;&quot;</span></span><br></pre></td></tr></table></figure><p>文件路径以 “;” 号分隔，最后的 2 个 “;;” 表示新加的路径后面加上原来的默认路径。</p><p>接着，更新环境变量参数，使之立即生效。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.profile</span><br></pre></td></tr></table></figure><p>这时假设 package.path 的值是：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/dengjoe/lua/?.lua;./?.lua;/usr/<span class="keyword">local</span>/share/lua/<span class="number">5.1</span>/?.lua;/usr/<span class="keyword">local</span>/share/lua/<span class="number">5.1</span>/?/init.lua;/usr/<span class="keyword">local</span>/lib/lua/<span class="number">5.1</span>/?.lua;/usr/<span class="keyword">local</span>/lib/lua/<span class="number">5.1</span>/?/init.lua</span><br></pre></td></tr></table></figure><p>那么调用 require(“module”) 时就会尝试打开以下文件目录去搜索目标。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/Users/dengjoe/lua/<span class="built_in">module</span>.lua;</span><br><span class="line">./<span class="built_in">module</span>.lua</span><br><span class="line">/usr/<span class="keyword">local</span>/share/lua/<span class="number">5.1</span>/<span class="built_in">module</span>.lua</span><br><span class="line">/usr/<span class="keyword">local</span>/share/lua/<span class="number">5.1</span>/<span class="built_in">module</span>/init.lua</span><br><span class="line">/usr/<span class="keyword">local</span>/lib/lua/<span class="number">5.1</span>/<span class="built_in">module</span>.lua</span><br><span class="line">/usr/<span class="keyword">local</span>/lib/lua/<span class="number">5.1</span>/<span class="built_in">module</span>/init.lua</span><br></pre></td></tr></table></figure><p>如果找过目标文件，则会调用 package.loadfile 来加载模块。否则，就会去找 C 程序库。</p><p>搜索的文件路径是从全局变量 package.cpath 获取，而这个变量则是通过环境变量 LUA_CPATH 来初始。</p><p>搜索的策略跟上面的一样，只不过现在换成搜索的是 so 或 dll 类型的文件。如果找得到，那么 require 就会通过 package.loadlib 来加载它。</p><h4 id="C包"><a href="#C包" class="headerlink" title="C包"></a>C包</h4><p>与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。</p><p>Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。所以典型的调用的例子如下:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">path</span> = <span class="string">&quot;/usr/local/lua/lib/libluasocket.so&quot;</span></span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">loadlib</span>(<span class="built_in">path</span>, <span class="string">&quot;luaopen_socket&quot;</span>)</span><br></pre></td></tr></table></figure><p>loadlib 函数加载指定的库并且连接到 Lua，然而它并不打开库（也就是说没有调用初始化函数），反之他返回初始化函数作为 Lua 的一个函数，这样我们就可以直接在Lua中调用他。</p><p>如果加载动态库或者查找初始化函数时出错，loadlib 将返回 nil 和错误信息。我们可以修改前面一段代码，使其检测错误然后调用初始化函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">path</span> = <span class="string">&quot;/usr/local/lua/lib/libluasocket.so&quot;</span></span><br><span class="line"><span class="comment">-- 或者 path = &quot;C:\\windows\\luasocket.dll&quot;，这是 Window 平台下</span></span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadlib</span>(<span class="built_in">path</span>, <span class="string">&quot;luaopen_socket&quot;</span>))</span><br><span class="line">f()  <span class="comment">-- 真正打开库</span></span><br></pre></td></tr></table></figure><p>一般情况下我们期望二进制的发布库包含一个与前面代码段相似的 stub 文件，安装二进制库的时候可以随便放在某个目录，只需要修改 stub 文件对应二进制库的实际路径即可。</p><p>将 stub 文件所在的目录加入到 LUA_PATH，这样设定后就可以使用 require 函数加载 C 库了。</p><h1 id="Lua-元表-Metatable"><a href="#Lua-元表-Metatable" class="headerlink" title="Lua 元表(Metatable)"></a>Lua 元表(Metatable)</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Latex</title>
      <link href="/posts/cd177453/"/>
      <url>/posts/cd177453/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.tug.org/texlive/acquire-ios.html">texLive</a></p><p>线上编辑器：overleaf</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;文章的标题&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;Aoi&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\maketitle</span></span><br><span class="line">你好！！！</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><p>命令格式：\命令名{ 参数 }</p><p>\documentclass[ 编码类型 ]{ 文档类型 } </p><p>​指定文档类型，常见命令参数有：</p><p>​article：普通的文章</p><p>​book、report等</p><p>​beamer：幻灯片格式</p><p>​ctexart：支持简体中文和英文的混排</p><p>​编码类型：UTF8</p><p>注意：begin之前的内容被称为前言，在其中指定大小、导入的包、格式等等信息</p><p>\begin到\end之间的内容被称为Body，在这片区域中的所有内容将会被排版到最终生成的文档中</p><p>\title{}命令可以给文档设置一个标题</p><p>\author{}命令指定作者名字</p><p>\date{}命令生成最后更改日期</p><p>​可以配合\today命令自动生成当天的日期  \date{\today}</p><p>要显示以上信息，需要在文档的正文区添加一个\maketitle命令，这个命令会在当前位置设置文档的标题，标题的内容就是前言区定义的信息</p><h1 id="格式化命令"><a href="#格式化命令" class="headerlink" title="格式化命令"></a>格式化命令</h1><h2 id="textbf-LaTex"><a href="#textbf-LaTex" class="headerlink" title="\textbf{LaTex}"></a>\textbf{LaTex}</h2><p>粗体，可以将大括号内的内容粗体化</p><p>bf：bold font的缩写</p><h2 id="textit"><a href="#textit" class="headerlink" title="\textit{}"></a>\textit{}</h2><p>斜体，it：italic</p><h2 id="underline"><a href="#underline" class="headerlink" title="\underline{}"></a>\underline{}</h2><p>下划线</p><h2 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h2><p>单独一个换行符会形成一个空格，两个换行符会形成换行</p><h2 id="section-章节名字"><a href="#section-章节名字" class="headerlink" title="\section{章节名字}"></a>\section{章节名字}</h2><p>表示开启一个新的章节</p><h2 id="subsection-二级章节名字"><a href="#subsection-二级章节名字" class="headerlink" title="\subsection{二级章节名字}"></a>\subsection{二级章节名字}</h2><p>表示开启一个二级章节</p><h2 id="subsubsection"><a href="#subsubsection" class="headerlink" title="\subsubsection{}"></a>\subsubsection{}</h2><p>开启一个三级章节</p><h2 id="chapter"><a href="#chapter" class="headerlink" title="\chapter{}"></a>\chapter{}</h2><p>对书籍排版有效，比section更大</p><p>表示书籍中的第几章</p><h2 id="part"><a href="#part" class="headerlink" title="\part{}"></a>\part{}</h2><p>对书籍排版有效，比part更大</p><p>表示书籍中的第几部</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>在前言中引入graphicx包</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125;</span><br></pre></td></tr></table></figure><p>在正文中使用\includegraphics{}命令在当前位置添加一张图片</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\includegraphics</span>[width = 0.5<span class="keyword">\textwidth</span>]&#123;图片相对路径&#125;</span><br></pre></td></tr></table></figure><p>其中，方括号中可选命令的含义是0.5倍的当前假面宽度，\textwidth命令表示当前命令宽度。</p><p>如果想给图片添加标题，可以将图片嵌套在figure环境，命令详解见下方代码</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;</span><br><span class="line"><span class="keyword">\centering</span>  // 将图片居中显示</span><br><span class="line"><span class="keyword">\includegraphics</span>[width = 0.5<span class="keyword">\textwidth</span>]&#123;图片相对路径&#125;</span><br><span class="line"><span class="keyword">\caption</span>&#123;图片标题&#125; // 指定图片标题</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>首先，创建列表环境，环境类似于作用域，任意一对begin和end中的内容表示同一个环境</p><h3 id="无序列表-itemize"><a href="#无序列表-itemize" class="headerlink" title="无序列表(itemize)"></a>无序列表(itemize)</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span> 列表项1</span><br><span class="line"><span class="keyword">\item</span> 列表项2</span><br><span class="line"><span class="keyword">\item</span> 列表项3</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br></pre></td></tr></table></figure><h3 id="有序列表-enumerate"><a href="#有序列表-enumerate" class="headerlink" title="有序列表(enumerate)"></a>有序列表(enumerate)</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line"> <span class="keyword">\item</span> 列表项1</span><br><span class="line"> <span class="keyword">\item</span> 列表项2</span><br><span class="line"> <span class="keyword">\item</span> 列表项3</span><br><span class="line"> <span class="keyword">\end</span>&#123;enumerate&#125;</span><br></pre></td></tr></table></figure><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p>行内公式：单个$，例如：$E&#x3D;mc^2$</p><p>整行公式：使用equation环境，也可以简写成\[的格式</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\[</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\]</span></span><br></pre></td></tr></table></figure><p><a href="https://latex.codecogs.com/eqneditor/editor.php">在线LaTeX公式编辑器</a></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>tabular环境</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123; c c c &#125;</span><br><span class="line">单元格1 <span class="built_in">&amp;</span> 单元格2 <span class="built_in">&amp;</span> 单元格3 <span class="keyword">\\</span></span><br><span class="line">单元格4 <span class="built_in">&amp;</span> 单元格5 <span class="built_in">&amp;</span> 单元格6 <span class="keyword">\\</span></span><br><span class="line">单元格7 <span class="built_in">&amp;</span> 单元格8 <span class="built_in">&amp;</span> 单元格9 </span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure><p>其中参数{c c c}表示共有3列，且每一列都是居中对齐，可以改成l或者r，表示左对齐或者右对齐</p><p>每一列的数据需要以&amp;符号隔开，表格每一行的数据需要以\\分割</p><p>竖直方向的边框：{|c|c|c|}</p><p>水平方向的边框：\hline，加在环境中，输入两次可以添加双横线的效果</p><p>加入列宽：把c改成p，{ p{2cm} c c }</p><p>添加标题：先把表格放到table环境里，增加\caption{}命令指定表格标题，并增加\center命令使表格居中显示</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;table&#125;</span><br><span class="line"><span class="keyword">\center</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123; | c | c | c | &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"><span class="keyword">\caption</span>&#123;表格标题&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;table&#125;</span><br></pre></td></tr></table></figure><h1 id="latex资料"><a href="#latex资料" class="headerlink" title="latex资料"></a>latex资料</h1><p><a href="https://github.com/CTeX-org/lshort-zh-cn">一份不太简短的LaTeX 2ε 介绍</a></p><h1 id="VScode配置Latex环境"><a href="#VScode配置Latex环境" class="headerlink" title="VScode配置Latex环境"></a>VScode配置Latex环境</h1><p>下载LaTeX Workshop插件</p><p>view latex打开文档的预览窗口，快捷键是Ctrl+Alt+V </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的个人博客——Hexo</title>
      <link href="/posts/0/"/>
      <url>/posts/0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a></p><h1 id="开始使用！"><a href="#开始使用！" class="headerlink" title="开始使用！"></a>开始使用！</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先安装Node.js和Git</p><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li></ul><blockquote><p>Mac 用户</p><p>如果在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> 安装命令行工具。</p></blockquote><blockquote><p>Windows 用户</p><p>对于中国大陆地区用户，可以前往 <a href="https://npm.taobao.org/mirrors/git-for-windows/">淘宝 Git for Windows 镜像</a> 下载 git 安装包。</p></blockquote><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>Node.js 为大多数平台提供了官方的 <a href="https://nodejs.org/zh-cn/download/">安装程序</a>。对于中国大陆地区用户，可以前往 <a href="https://npm.taobao.org/mirrors/node">淘宝 Node.js 镜像</a> 下载。</p><p>其它的安装方法：</p><ul><li>Windows：通过 <a href="https://github.com/jasongin/nvs/">nvs</a>（推荐）或者 <a href="https://github.com/nvm-sh/nvm">nvm</a> 安装。</li><li>Mac：使用 <a href="https://brew.sh/">Homebrew</a> 或 <a href="http://www.macports.org/">MacPorts</a> 安装。</li><li>Linux（DEB&#x2F;RPM-based）：从 <a href="https://github.com/nodesource/distributions">NodeSource</a> 安装。</li><li>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 <a href="https://nodejs.org/zh-cn/download/package-manager/">指导</a>。</li></ul><p>对于 Mac 和 Linux 同样建议使用 nvs 或者 nvm，以避免可能会出现的权限问题。</p><blockquote><p>Windows 用户</p><p>使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）</p></blockquote><blockquote><p>For Mac &#x2F; Linux 用户</p><p>如果在尝试安装 Hexo 的过程中出现 <code>EACCES</code> 权限错误，请遵循 <a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally">由 npmjs 发布的指导</a> 修复该问题。强烈建议 <strong>不要</strong> 使用 root、sudo 等方法覆盖权限</p></blockquote><blockquote><p>Linux</p><p>如果您使用 Snap 来安装 Node.js，在 <a href="https://hexo.io/zh-cn/docs/commands#init">初始化</a> 博客时您可能需要手动在目标文件夹中执行 <code>npm install</code>。</p></blockquote><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="进阶安装和使用"><a href="#进阶安装和使用" class="headerlink" title="进阶安装和使用"></a>进阶安装和使用</h3><p>对于熟悉 npm 的进阶用户，可以仅局部安装 <code>hexo</code> 包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo</span><br></pre></td></tr></table></figure><p>安装以后，可以使用以下两种方式执行 Hexo：</p><ol><li><code>npx hexo &lt;command&gt;</code></li><li>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27; &gt;&gt; ~/.profile</span><br></pre></td></tr></table></figure><h3 id="Node-js-版本限制"><a href="#Node-js-版本限制" class="headerlink" title="Node.js 版本限制"></a>Node.js 版本限制</h3><p>我们强烈建议永远安装最新版本的 Hexo，以及 <a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90">推荐的 Node.js 版本</a>。</p><table><thead><tr><th align="left">Hexo 版本</th><th align="left">最低版本 (Node.js 版本)</th><th align="left">最高版本 (Node.js 版本)</th></tr></thead><tbody><tr><td align="left">6.2+</td><td align="left">12.13.0</td><td align="left">latest</td></tr><tr><td align="left">6.0+</td><td align="left">12.13.0</td><td align="left">18.5.0</td></tr><tr><td align="left">5.0+</td><td align="left">10.13.0</td><td align="left">12.0.0</td></tr><tr><td align="left">4.1 - 4.2</td><td align="left">8.10</td><td align="left">10.0.0</td></tr><tr><td align="left">4.0</td><td align="left">8.6</td><td align="left">8.10.0</td></tr><tr><td align="left">3.3 - 3.9</td><td align="left">6.9</td><td align="left">8.0.0</td></tr><tr><td align="left">3.2 - 3.3</td><td align="left">0.12</td><td align="left">未知</td></tr><tr><td align="left">3.0 - 3.1</td><td align="left">0.10 或 iojs</td><td align="left">未知</td></tr><tr><td align="left">0.0.1 - 2.8</td><td align="left">0.10</td><td align="left">未知</td></tr></tbody></table><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package.json&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;hexo&quot;: &quot;^3.8.0&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class="line">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^0.3.3&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p><a href="https://hexo.io/zh-cn/docs/writing#%E6%A8%A1%E7%89%88%EF%BC%88Scaffold%EF%BC%89">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold&#x2F;post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>您可以在 <code>_config.yml</code> 中修改大部分的配置。</p><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>title</code></td><td align="left">网站标题</td></tr><tr><td align="left"><code>subtitle</code></td><td align="left">网站副标题</td></tr><tr><td align="left"><code>description</code></td><td align="left">网站描述</td></tr><tr><td align="left"><code>keywords</code></td><td align="left">网站的关键词。支持多个关键词。</td></tr><tr><td align="left"><code>author</code></td><td align="left">您的名字</td></tr><tr><td align="left"><code>language</code></td><td align="left">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td></tr><tr><td align="left"><code>timezone</code></td><td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td></tr></tbody></table><p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p><h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>url</code></td><td align="left">网址, 必须以 <code>http://</code> 或 <code>https://</code> 开头</td><td align="left"></td></tr><tr><td align="left"><code>root</code></td><td align="left">网站根目录</td><td align="left"><code>url&#39;s pathname</code></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式</td><td align="left"><code>:year/:month/:day/:title/</code></td></tr><tr><td align="left"><code>permalink_defaults</code></td><td align="left">永久链接中各部分的默认值</td><td align="left"></td></tr><tr><td align="left"><code>pretty_urls</code></td><td align="left">改写 <a href="https://hexo.io/zh-cn/docs/variables"><code>permalink</code></a> 的值来美化 URL</td><td align="left"></td></tr><tr><td align="left"><code>pretty_urls.trailing_index</code></td><td align="left">是否在永久链接中保留尾部的 <code>index.html</code>，设置为 <code>false</code> 时去除</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>pretty_urls.trailing_html</code></td><td align="left">是否在永久链接中保留尾部的 <code>.html</code>, 设置为 <code>false</code> 时去除 (<em>对尾部的 <code>index.html</code>无效</em>)</td><td align="left"><code>true</code></td></tr></tbody></table><blockquote><p>网站存放在子目录</p><p>如果您的网站存放在子目录中，例如 <code>http://example.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://example.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p></blockquote><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: false</span><br><span class="line"># 此时页面的永久链接会变为 http://example.com/foo/bar/</span><br></pre></td></tr></table></figure><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>source_dir</code></td><td align="left">资源文件夹，这个文件夹用来存放内容。</td><td align="left"><code>source</code></td></tr><tr><td align="left"><code>public_dir</code></td><td align="left">公共文件夹，这个文件夹用于存放生成的站点文件。</td><td align="left"><code>public</code></td></tr><tr><td align="left"><code>tag_dir</code></td><td align="left">标签文件夹</td><td align="left"><code>tags</code></td></tr><tr><td align="left"><code>archive_dir</code></td><td align="left">归档文件夹</td><td align="left"><code>archives</code></td></tr><tr><td align="left"><code>category_dir</code></td><td align="left">分类文件夹</td><td align="left"><code>categories</code></td></tr><tr><td align="left"><code>code_dir</code></td><td align="left">Include code 文件夹，<code>source_dir</code> 下的子目录</td><td align="left"><code>downloads/code</code></td></tr><tr><td align="left"><code>i18n_dir</code></td><td align="left">国际化（i18n）文件夹</td><td align="left"><code>:lang</code></td></tr><tr><td align="left"><code>skip_render</code></td><td align="left">跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 <code>public</code> 目录中。您可使用 <a href="https://github.com/micromatch/micromatch#extended-globbing">glob 表达式</a>来匹配路径。</td><td align="left"></td></tr></tbody></table><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">skip_render: &quot;mypage/**/*&quot;</span><br><span class="line"># 将会直接将 `source/mypage/index.html` 和 `source/mypage/code.js` 不做改动地输出到 &#x27;public&#x27; 目录</span><br><span class="line"># 你也可以用这种方法来跳过对指定文章文件的渲染</span><br><span class="line">skip_render: &quot;_posts/test-post.md&quot;</span><br><span class="line"># 这将会忽略对 &#x27;test-post.md&#x27; 的渲染</span><br></pre></td></tr></table></figure><blockquote><p>提示</p><p>如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p></blockquote><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>new_post_name</code></td><td align="left">新文章的文件名称</td><td align="left">:title.md</td></tr><tr><td align="left"><code>default_layout</code></td><td align="left">预设布局</td><td align="left">post</td></tr><tr><td align="left"><code>auto_spacing</code></td><td align="left">在中文和英文之间加入空格</td><td align="left">false</td></tr><tr><td align="left"><code>titlecase</code></td><td align="left">把标题转换为 title case</td><td align="left">false</td></tr><tr><td align="left"><code>external_link</code></td><td align="left">在新标签中打开链接</td><td align="left">true</td></tr><tr><td align="left"><code>external_link.enable</code></td><td align="left">在新标签中打开链接</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>external_link.field</code></td><td align="left">对整个网站（<code>site</code>）生效或仅对文章（<code>post</code>）生效</td><td align="left"><code>site</code></td></tr><tr><td align="left"><code>external_link.exclude</code></td><td align="left">需要排除的域名。主域名和子域名如 <code>www</code> 需分别配置</td><td align="left"><code>[]</code></td></tr><tr><td align="left"><code>filename_case</code></td><td align="left">把文件名称转换为 (1) 小写或 (2) 大写</td><td align="left">0</td></tr><tr><td align="left"><code>render_drafts</code></td><td align="left">显示草稿</td><td align="left">false</td></tr><tr><td align="left"><code>post_asset_folder</code></td><td align="left">启动 <a href="https://hexo.io/zh-cn/docs/asset-folders">Asset 文件夹</a></td><td align="left">false</td></tr><tr><td align="left"><code>relative_link</code></td><td align="left">把链接改为与根目录的相对位址</td><td align="left">false</td></tr><tr><td align="left"><code>future</code></td><td align="left">显示未来的文章</td><td align="left">true</td></tr><tr><td align="left"><code>highlight</code></td><td align="left">代码块的设置, 请参考 <a href="https://hexo.io/zh-cn/docs/syntax-highlight#Highlight-js">Highlight.js</a> 进行设置</td><td align="left"></td></tr><tr><td align="left"><code>prismjs</code></td><td align="left">代码块的设置, 请参考 <a href="https://hexo.io/zh-cn/docs/syntax-highlight#PrismJS">PrismJS</a> 进行设置</td><td align="left"></td></tr></tbody></table><blockquote><p>相对地址</p><p>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 <code>example.com</code>，您有一篇文章名为 <code>hello</code>，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是<strong>绝对</strong>于域名的。相对链接像这样：<code>/hello.html</code>，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p></blockquote><h3 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h3><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>default_category</code></td><td align="left">默认分类</td><td align="left"><code>uncategorized</code></td></tr><tr><td align="left"><code>category_map</code></td><td align="left">分类别名</td><td align="left"></td></tr><tr><td align="left"><code>tag_map</code></td><td align="left">标签别名</td><td align="left"></td></tr></tbody></table><h3 id="日期-x2F-时间格式"><a href="#日期-x2F-时间格式" class="headerlink" title="日期 &#x2F; 时间格式"></a>日期 &#x2F; 时间格式</h3><p>Hexo 使用 <a href="http://momentjs.com/">Moment.js</a> 来解析和显示时间。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>date_format</code></td><td align="left">日期格式</td><td align="left"><code>YYYY-MM-DD</code></td></tr><tr><td align="left"><code>time_format</code></td><td align="left">时间格式</td><td align="left"><code>HH:mm:ss</code></td></tr><tr><td align="left"><code>updated_option</code></td><td align="left">当 Front Matter 中没有指定 <a href="https://hexo.io/zh-cn/docs/variables#%E9%A1%B5%E9%9D%A2%E5%8F%98%E9%87%8F"><code>updated</code></a> 时 <code>updated</code> 的取值</td><td align="left"><code>mtime</code></td></tr></tbody></table><blockquote><p>updated_option</p><p><code>updated_option</code> 控制了当 Front Matter 中没有指定 <code>updated</code> 时，<code>updated</code> 如何取值：</p><ul><li><code>mtime</code>: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。</li><li><code>date</code>: 使用 <code>date</code> 作为 <code>updated</code> 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变</li><li><code>empty</code>: 直接删除 <code>updated</code>。使用这一选项可能会导致大部分主题和插件无法正常工作。</li></ul><p><code>use_date_for_updated</code> 选项已经被废弃，将会在下个重大版本发布时去除。请改为使用 <code>updated_option: &#39;date&#39;</code>。</p></blockquote><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>per_page</code></td><td align="left">每页显示的文章量 (0 &#x3D; 关闭分页功能)</td><td align="left"><code>10</code></td></tr><tr><td align="left"><code>pagination_dir</code></td><td align="left">分页目录</td><td align="left"><code>page</code></td></tr></tbody></table><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>theme</code></td><td align="left">当前主题名称。值为<code>false</code>时禁用主题</td></tr><tr><td align="left"><code>theme_config</code></td><td align="left">主题的配置文件。在这里放置的配置会覆盖主题目录下的 <code>_config.yml</code> 中的配置</td></tr><tr><td align="left"><code>deploy</code></td><td align="left">部署部分的设置</td></tr><tr><td align="left"><code>meta_generator</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#%E5%B1%9E%E6%80%A7">Meta generator</a> 标签。 值为 <code>false</code> 时 Hexo 不会在头部插入该标签</td></tr></tbody></table><p><strong>包括或不包括目录和文件</strong></p><p>在 Hexo 配置文件中，通过设置 include&#x2F;exclude 可以让 Hexo 进行处理或忽略某些目录和文件夹。你可以使用 <a href="https://github.com/isaacs/minimatch">glob 表达式</a> 对目录和文件进行匹配。</p><p><code>include</code> 和 <code>exclude</code> 选项只会应用到 <code>source/</code> ，而 <code>ignore</code> 选项会应用到所有文件夹.</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>include</code></td><td align="left">Hexo 默认会不包括 <code>source/</code> 下的文件和文件夹（包括名称以下划线和 <code>.</code> 开头的文件和文件夹，Hexo 的 <code>_posts</code> 和 <code>_data</code> 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 <code>source</code> 目录下。</td></tr><tr><td align="left"><code>exclude</code></td><td align="left">Hexo 不包括 <code>source/</code> 下的这些文件和目录</td></tr><tr><td align="left"><code>ignore</code></td><td align="left">Hexo 会忽略整个 Hexo 项目下的这些文件夹或文件</td></tr></tbody></table><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 处理或不处理目录或文件</span><br><span class="line">include:</span><br><span class="line">  - &quot;.nojekyll&quot;</span><br><span class="line">  # 处理 &#x27;source/css/_typing.css&#x27;</span><br><span class="line">  - &quot;css/_typing.css&quot;</span><br><span class="line">  # 处理 &#x27;source/_css/&#x27; 中的任何文件，但不包括子目录及其其中的文件。</span><br><span class="line">  - &quot;_css/*&quot;</span><br><span class="line">  # 处理 &#x27;source/_css/&#x27; 中的任何文件和子目录下的任何文件</span><br><span class="line">  - &quot;_css/**/*&quot;</span><br><span class="line"></span><br><span class="line">exclude:</span><br><span class="line">  # 不处理 &#x27;source/js/test.js&#x27;</span><br><span class="line">  - &quot;js/test.js&quot;</span><br><span class="line">  # 不处理 &#x27;source/js/&#x27; 中的文件、但包括子目录下的所有目录和文件</span><br><span class="line">  - &quot;js/*&quot;</span><br><span class="line">  # 不处理 &#x27;source/js/&#x27; 中的文件和子目录下的任何文件</span><br><span class="line">  - &quot;js/**/*&quot;</span><br><span class="line">  # 不处理 &#x27;source/js/&#x27; 目录下的所有文件名以 &#x27;test&#x27; 开头的文件，但包括其它文件和子目录下的单文件</span><br><span class="line">  - &quot;js/test*&quot;</span><br><span class="line">  # 不处理 &#x27;source/js/&#x27; 及其子目录中任何以 &#x27;test&#x27; 开头的文件</span><br><span class="line">  - &quot;js/**/test*&quot;</span><br><span class="line">  # 不要用 exclude 来忽略 &#x27;source/_posts/&#x27; 中的文件。你应该使用 &#x27;skip_render&#x27;，或者在要忽略的文件的文件名之前加一个下划线 &#x27;_&#x27;</span><br><span class="line">  # 在这里配置一个 - &quot;_posts/hello-world.md&quot; 是没有用的。</span><br><span class="line"></span><br><span class="line">ignore:</span><br><span class="line">  # 忽略任何一个名叫 &#x27;foo&#x27; 的文件夹</span><br><span class="line">  - &quot;**/foo&quot;</span><br><span class="line">  # 只忽略 &#x27;themes/&#x27; 下的 &#x27;foo&#x27; 文件夹</span><br><span class="line">  - &quot;**/themes/*/foo&quot;</span><br><span class="line">  # 对 &#x27;themes/&#x27; 目录下的每个文件夹中忽略名叫 &#x27;foo&#x27; 的子文件夹</span><br><span class="line">  - &quot;**/themes/**/foo&quot;</span><br></pre></td></tr></table></figure><p>列表中的每一项都必须用单引号或双引号包裹起来。</p><p><code>include</code> 和 <code>exclude</code> 并不适用于 <code>themes/</code> 目录下的文件。如果需要忽略 <code>themes/</code> 目录下的部分文件或文件夹，可以使用 <code>ignore</code> 或在文件名之前添加下划线 <code>_</code>。</p><p><strong>使用代替配置文件</strong></p><p>可以在 hexo-cli 中使用 <code>--config</code> 参数来指定自定义配置文件的路径。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 用 &#x27;custom.yml&#x27; 代替 &#x27;_config.yml&#x27;</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># 使用 &#x27;custom.yml&#x27; 和 &#x27;custom2.json&#x27;，优先使用 &#x27;custom3.yml&#x27;，然后是 &#x27;custom2.json&#x27;</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><p>例如，使用 <code>--options</code> 指定了两个自定义配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate --config custom.yml,custom2.json</span><br></pre></td></tr></table></figure><p>如果 <code>custom.yml</code> 中指定了 <code>foo: bar</code>，在 custom2.json 中指定了 <code>&quot;foo&quot;: &quot;dinosaur&quot;</code>，那么在 <code>_multiconfig.yml</code> 中你会得到 <code>foo: dinosaur</code>。</p><p><strong>使用代替主题配置文件</strong></p><p>通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 <code>_config.yml</code> 配置文件。</p><p>除了自行维护独立的主题配置文件，你也可以在其它地方对主题进行配置。</p><p>​<strong>配置文件中的 <code>theme_config</code></strong></p><blockquote><p>该特性自 Hexo 2.8.2 起提供</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># _config.yml</span><br><span class="line">theme: &quot;my-theme&quot;</span><br><span class="line">theme_config:</span><br><span class="line">  bio: &quot;My awesome bio&quot;</span><br><span class="line">  foo:</span><br><span class="line">    bar: &#x27;a&#x27;</span><br><span class="line"># themes/my-theme/_config.yml</span><br><span class="line">bio: &quot;Some generic bio&quot;</span><br><span class="line">logo: &quot;a-cool-image.png&quot;</span><br><span class="line">  foo:</span><br><span class="line">    baz: &#x27;b&#x27;</span><br></pre></td></tr></table></figure><p>最终主题配置的输出是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  bio: &quot;My awesome bio&quot;,</span><br><span class="line">  logo: &quot;a-cool-image.png&quot;,</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: &quot;a&quot;,</span><br><span class="line">    baz: &quot;b&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>独立的 <code>_config.[theme].yml</code> 文件</strong></p><blockquote><p>该特性自 Hexo 5.0.0 起提供</p></blockquote><p>独立的主题配置文件应放置于站点根目录下，支持 <code>yml</code> 或 <code>json</code> 格式。需要配置站点 <code>_config.yml</code> 文件中的 <code>theme</code> 以供 Hexo 寻找 <code>_config.[theme].yml</code> 文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># _config.yml</span><br><span class="line">theme: &quot;my-theme&quot;</span><br><span class="line"># _config.my-theme.yml</span><br><span class="line">bio: &quot;My awesome bio&quot;</span><br><span class="line">foo:</span><br><span class="line">  bar: &#x27;a&#x27;</span><br><span class="line"># themes/my-theme/_config.yml</span><br><span class="line">bio: &quot;Some generic bio&quot;</span><br><span class="line">logo: &quot;a-cool-image.png&quot;</span><br><span class="line">  foo:</span><br><span class="line">    baz: &#x27;b&#x27;</span><br></pre></td></tr></table></figure><p>最终主题配置的输出是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  bio: &quot;My awesome bio&quot;,</span><br><span class="line">  logo: &quot;a-cool-image.png&quot;,</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: &quot;a&quot;,</span><br><span class="line">    baz: &quot;b&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们强烈建议你将所有的主题配置集中在一处。如果你不得不在多处配置你的主题，那么这些信息对你将会非常有用：Hexo 在合并主题配置时，Hexo 配置文件中的 <code>theme_config</code> 的优先级最高，其次是 <code>_config.[theme].yml</code> 文件，最后是位于主题目录下的 <code>_config.yml</code> 文件。</p></blockquote><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><iframe src="https://www.youtube.com/embed/mgdXi5npArQ" frameborder="0" loading="lazy" allowfullscreen="" style="box-sizing: inherit; margin: 1em 0px; padding: 0px; border: 0px; outline: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; font-size: 15px; vertical-align: baseline;"></iframe><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li></ol><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about/me &quot;About me&quot;</span><br></pre></td></tr></table></figure><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about/me</span><br></pre></td></tr></table></figure><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>发表草稿。</p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>部署网站。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o</code>, <code>--output</code></td><td align="left">设置输出路径</td></tr></tbody></table><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure><p>列出网站资料。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure><p>显示 Hexo 版本。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h4 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new">提交调试信息到 GitHub</a>。</p><h4 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure><p>隐藏终端信息。</p><h4 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure><p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><h4 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h4 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --cwd /path/to/cwd</span><br></pre></td></tr></table></figure><p>自定义当前工作目录（Current working directory）的路径。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a></p><p><a href="https://github.com/JoeyBling/hexo-theme-yilia-plus">JoeyBling&#x2F;hexo-theme-yilia-plus: 一个简洁优雅的hexo主题 A simple and elegant theme for hexo. (github.com)</a></p><p>注意，主题的配置可以通过将theme文件夹下各个主题文件夹中的_config.yml文件拷贝一份放到根目录中，并改名为_config.主题名.yml，之后修改该文件即可，注，原_config.yml文件不需要删除</p><h1 id="进阶了一丢丢"><a href="#进阶了一丢丢" class="headerlink" title="进阶了一丢丢"></a>进阶了一丢丢</h1><p>参考资料：<a href="https://anzhiy.cn/posts/sdxhu.html">butterfly 重装日记 | 安知鱼 (anzhiy.cn)</a></p><h2 id="配置文章链接转数字或字母"><a href="#配置文章链接转数字或字母" class="headerlink" title="配置文章链接转数字或字母"></a>配置文章链接转数字或字母</h2><p>参考: <a href="https://github.com/rozbo/hexo-abbrlink">https://github.com/rozbo/hexo-abbrlink</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><h2 id="本地搜索依赖"><a href="#本地搜索依赖" class="headerlink" title="本地搜索依赖"></a>本地搜索依赖</h2><p>参考：<a href="https://github.com/wzpan/hexo-generator-search">https://github.com/wzpan/hexo-generator-search</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>另外，需要将主题配置文件中的local_search的enable置true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  preload: false</span><br><span class="line">  CDN:</span><br></pre></td></tr></table></figure><h2 id="live2d"><a href="#live2d" class="headerlink" title="live2d"></a>live2d</h2><p><a href="https://www.jianshu.com/p/3a6342e16e57">hexo 添加live2d看板动画 - 简书 (jianshu.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装live2d</span><br><span class="line">npm install --save hexo-helper-live2d</span><br><span class="line"># 安装模型</span><br><span class="line">npm install --save live2d-widget-model-hijiki</span><br></pre></td></tr></table></figure><p>在_config.yml文件中配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-hijiki  #模板目录，在node_modules里</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150 </span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: false  #是否在手机进行显示</span><br></pre></td></tr></table></figure><h2 id="sitemap"><a href="#sitemap" class="headerlink" title="sitemap"></a>sitemap</h2><p>便于爬虫爬的插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save-dev</span><br></pre></td></tr></table></figure><p> _config.yml配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># https://github.com/hexojs/hexo-generator-sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">  rel: false</span><br><span class="line">  tags: true</span><br><span class="line">  categories: true</span><br><span class="line"></span><br><span class="line"># https://github.com/coneycode/hexo-generator-baidu-sitemap</span><br><span class="line">baidusitemap:</span><br><span class="line">    path: baidusitemap.xml</span><br></pre></td></tr></table></figure><h2 id="Rss"><a href="#Rss" class="headerlink" title="Rss"></a>Rss</h2><p>增加文章摘要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>_config.yml配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># https://github.com/hexojs/hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">    type: atom</span><br><span class="line">    path: atom.xml</span><br><span class="line">    limit: 20</span><br><span class="line">rss: /atom.xml</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">plugins:</span><br><span class="line">    - hexo-generator-feed</span><br><span class="line">    - hexo-generator-baidu-sitemap</span><br><span class="line">    - hexo-generator-sitemap</span><br></pre></td></tr></table></figure><h2 id="aplayer-音乐播放器"><a href="#aplayer-音乐播放器" class="headerlink" title="aplayer 音乐播放器"></a>aplayer 音乐播放器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-tag-aplayer --save</span><br></pre></td></tr></table></figure><p>_config.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># APlayer</span><br><span class="line"># https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md</span><br><span class="line">aplayer:</span><br><span class="line">  meting: true</span><br><span class="line">  asset_inject: false</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>
